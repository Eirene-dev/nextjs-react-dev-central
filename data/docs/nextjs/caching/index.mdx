---
title: Next.js에서 캐싱
date: '2023-09-01 04:00'
summary: Next.js의 캐싱 메커니즘 개요.
---


Next.js는 렌더링 작업과 데이터 요청을 캐싱하여 애플리케이션의 성능을 향상시키고 비용을 절감합니다. 이 페이지에서는 Next.js의 캐싱 메커니즘, 그것을 구성하기 위해 사용할 수 있는 API, 그리고 그들이 어떻게 서로 상호 작용하는지에 대해 깊이 있는 정보를 제공합니다.

> **알아두면 좋아요**: 이 페이지는 Next.js가 내부적으로 어떻게 동작하는지 이해하는 데 도움을 주지만, Next.js를 효과적으로 사용하기 위해 **필수적인** 지식은 아닙니다. 대부분의 Next.js 캐싱 휴리스틱은 사용자의 API 사용 패턴에 의해 결정되며, 최적의 성능을 위한 기본 설정이 제공됩니다.

<details className="bg-gray-100 p-2 rounded-md">
  <summary>자세히 알아보기: **웹 개발에서의 캐싱(Caching)**</summary>
### 웹에서의 Cache (캐시)

웹에서의 캐시는 자주 사용되는 데이터나 파일들을 빠르게 재사용하기 위해 일시적으로 저장하는 기술입니다. 웹 캐싱은 사용자 경험을 향상시키기 위해 사용되며, 웹 사이트의 로딩 속도를 빠르게 만들고, 서버의 부하를 줄이며, 대역폭 사용량을 최소화하는 데 도움이 됩니다.

웹 캐시는 여러 레벨에서 작동할 수 있습니다. 예를 들어, 웹 브라우저는 최근 방문한 웹 페이지의 리소스를 로컬에 저장하여 다음 방문 시 더 빠른 응답을 제공할 수 있습니다. CDN (Content Delivery Network)는 전세계 여러 위치에 데이터를 캐시하여 사용자에게 가장 가까운 위치에서 데이터를 제공하며, 웹 서버는 자주 사용되는 결과나 데이터를 캐시하여 더 빠른 서비스를 제공할 수 있습니다.

### 일반적인 캐싱 기법:

1. **브라우저 캐싱**: 웹 브라우저는 사용자의 컴퓨터에 최근에 다운로드한 파일들 (이미지, 스크립트, 스타일시트 등)을 임시 저장소에 저장합니다. 사용자가 동일한 리소스에 다시 액세스하려고 할 때 브라우저는 네트워크 요청을 하는 대신 이 저장된 파일을 사용합니다.

2. **CDN 캐싱**: CDN은 전세계 여러 서버에 웹 컨텐츠를 복제하여 저장합니다. 사용자가 요청을 할 때, 가장 가까운 서버에서 캐시된 내용을 제공함으로써 응답 시간을 줄입니다.

3. **프록시 캐싱**: 중간에 위치한 프록시 서버가 사용자의 요청을 대신하여 웹 서버에 전달하고, 그 결과를 캐시에 저장합니다. 동일한 요청이 들어올 때, 프록시는 저장된 캐시를 사용하여 빠르게 응답할 수 있습니다.

4. **서버 캐싱**: 웹 서버 자체에 존재하는 여러 캐싱 기법이 있습니다. 예를 들면:
   - **메모리 캐싱**: 데이터를 서버의 RAM에 저장하므로 데이터베이스 쿼리나 파일 시스템 호출을 줄입니다.
   - **페이지 캐싱**: 전체 HTML 페이지를 캐시하여 동일한 요청이 있을 때 빠르게 제공합니다.
   - **오브젝트 캐싱**: 데이터베이스 쿼리 결과나 계산 집합 등의 개별 데이터 항목들을 캐시합니다.
   - **Opcode 캐싱**: PHP와 같은 스크립트 언어에서, 중간 코드 (opcode)를 캐시하여 재컴파일 없이 코드를 빠르게 실행합니다.

5. **HTTP 헤더를 사용한 캐싱**: 웹 서버와 브라우저 간의 통신에서 HTTP 헤더는 캐싱 동작을 제어하는 데 사용됩니다. `Cache-Control`, `ETag`, `Last-Modified` 등의 헤더가 여기에 해당합니다.

6. **데이터베이스 캐싱**: 데이터베이스 질의의 결과를 캐시하여 동일한 질의에 대한 반복 요청을 빠르게 처리할 수 있습니다.

웹 캐싱은 리소스 사용을 최적화하고 응답 시간을 줄이는 데 큰 도움을 줍니다. 그러나 캐싱 전략을 잘못 관리하면 오래된 또는 잘못된 데이터가 사용자에게 제공될 수 있으므로 주의가 필요합니다.
</details>

## 개요

다양한 캐싱 메커니즘과 그들의 목적에 대한 고수준 개요는 다음과 같습니다:

| 메커니즘                                     | 무엇을                             | 어디서 | 목적                                           | 지속 시간                      |
| ------------------------------------------ | ------------------------------ | ------ | -------------------------------------------- | ---------------------------- |
| [요청 메모이제이션](/docs/nextjs/caching/request-memoization)  | 함수의 반환 값                   | 서버   | React 컴포넌트 트리에서 데이터 재사용          | 요청당 수명 주기               |
| [데이터 캐시](/docs/nextjs/caching/data-cache)                 | 데이터                           | 서버   | 사용자 요청과 배포 간의 데이터 저장            | 영구적 (재검증 가능)            |
| [전체 루트 캐시](/docs/nextjs/caching/full-route-cache)        | HTML과 RSC 페이로드              | 서버   | 렌더링 비용 감소 및 성능 향상                  | 영구적 (재검증 가능)            |
| [라우터 캐시](/docs/nextjs/caching/router-cache)               | RSC 페이로드                     | 클라이언트 | 탐색 시 서버 요청 감소                      | 사용자 세션 또는 기간 기반       |

기본적으로 Next.js는 성능을 향상시키고 비용을 줄이기 위해 최대한 많은 것을 캐싱합니다. 이는 루트가 **정적으로 렌더링**되며 데이터 요청이 **캐싱**된다는 것을 의미합니다, 사용자가 선택하지 않는 한. 아래 다이어그램은 빌드 시간에 경로가 정적으로 렌더링될 때와 정적 경로가 처음 방문될 때의 기본 캐싱 동작을 보여줍니다.

!["네 가지 메커니즘에 대한 Next.js의 기본 캐싱 동작을 보여주는 다이어그램"](https://nextjs.org/_next/image?url=%2Fdocs%2Flight%2Fcaching-overview.png&w=1920&q=75&dpl=dpl_E2DMmJw3MgUzvPqW6x3tFd2oxLX6)


캐싱 동작은 루트가 정적으로 또는 동적으로 렌더링되는지, 데이터가 캐시되거나 캐시되지 않는지, 요청이 초기 방문의 일부인지 아니면 후속 탐색의 일부인지에 따라 변경됩니다. 사용 사례에 따라 개별 루트와 데이터 요청에 대한 캐싱 동작을 구성할 수 있습니다.


<div className="grid grid-cols-1 sm:grid-cols-2 gap-4">

<Card href="/docs/nextjs/caching/request-memoization">
### Request 메모이제이션

Next.js의 Request 메모이제이션에 기반한 캐싱 기법.
</Card>

<Card href="/docs/nextjs/caching/data-cache">
### 데이터 캐시

Next.js의 내장 데이터 캐시 사용 기법.
</Card>

<Card href="/docs/nextjs/caching/full-route-cache">
### 전체 라우트 캐시

Next.js의 캐싱 메커니즘 개요.
</Card>

<Card href="/docs/nextjs/caching/router-cache">
### 라우터 캐시

클라이언트 측에서의 라우터 캐시와 캐시 간에 상호 작용을 알아 봅니다.
</Card>

<Card href="/docs/nextjs/caching/affecting-api">
### 캐싱 영향 주는 APIs

Next.js의 캐싱 메커니즘 개요.
</Card>


</div>