---
title: "상태 관리"
date: '2023-08-30'
summary: Next.js와 React의 공식 문서를 참고하여 웹 개발에 필수적인 기술을 안내합니다.
---

화면의 일부 요소는 사용자 입력에 응답하여 업데이트됩니다. 예를 들어, 이미지 갤러리를 클릭하면 활성 이미지가 변경됩니다. React에서 시간이 지남에 따라 변경되는 데이터를 상태(state)라고 합니다. 모든 컴포넌트에 상태를 추가하고 필요에 따라 업데이트할 수 있습니다. 이 장에서는 상호 작용을 처리하고 상태를 업데이트하며 시간에 따라 다른 출력을 표시하는 컴포넌트를 작성하는 방법을 배우게 될 것입니다.

## 이벤트에 응답하기

React는 JSX에 이벤트 핸들러를 추가할 수 있게 해줍니다. 이벤트 핸들러는 클릭, 호버링, 폼 입력에 대한 응답과 같은 사용자 상호작용에 따라 트리거되는 사용자 정의 함수입니다.


### 이벤트 핸들러 추가하기

이벤트 핸들러를 추가하기 위해 먼저 함수를 정의하고 해당 함수를 적절한 JSX 태그에 [속성(props)으로 전달](https://react.dev/learn/passing-props-to-a-component)해야 합니다. 예를 들어, 아직 아무런 동작을 하지 않는 버튼을 생각해보겠습니다.

<iframe 
  src="https://codesandbox.io/embed/mutable-night-iy9k29?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="mutable-night-iy9k29"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


버튼을 클릭할 때 메시지를 표시하도록 만들기 위해 다음 세 가지 단계를 따릅니다.

1. Button 컴포넌트 내에 handleClick이라는 함수를 선언합니다.
2. 해당 함수 내에 로직을 구현합니다 (메시지를 표시하기 위해 alert를 사용합니다).
3. `<button>` JSX에 `onClick={handleClick}`를 추가합니다.

<iframe 
  src="https://codesandbox.io/embed/holy-tree-kkj3dr?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="holy-tree-kkj3dr"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


handleClick 함수를 정의하고 `<button>`에 [속성(props)으로 전달](https://react.dev/learn/passing-props-to-a-component)했습니다. handleClick은 **이벤트 핸들러**입니다. 이벤트 핸들러 함수는 다음과 같은 특징을 가집니다.

- 보통 컴포넌트 내에서 정의됩니다.
- 이벤트 이름 뒤에 handle을 붙인 이름으로 작성됩니다.

관례적으로 이벤트 핸들러 함수는 이벤트 이름에 handle을 붙인 형태로 작성하는 것이 일반적입니다. `onClick={handleClick}`, `onMouseEnter={handleMouseEnter}`와 같이 많이 볼 수 있습니다.

또는 JSX 내에서 인라인으로 이벤트 핸들러를 정의할 수도 있습니다.

```jsx
<button onClick={function handleClick() {
  alert('You clicked me!');
}}>
```

또는 화살표 함수를 사용하여 더 간결하게 정의할 수도 있습니다.

```jsx
<button onClick={() => {
  alert('You clicked me!');
}}>
```

이러한 스타일은 모두 동일한 결과를 가져옵니다. 인라인 이벤트 핸들러는 간단한 함수에 편리합니다.




<Callout type="warning">
**주의사항**

이벤트 핸들러에 전달하는 함수는 호출되는 것이 아니라 전달되어야 합니다. 예를 들어:

| 함수 전달 (올바른 방법) | 함수 호출 (잘못된 방법) |
| --- | --- |
| `<button onClick={handleClick}>` | `<button onClick={handleClick()}>` |


차이는 미묘합니다. 첫 번째 예제에서 handleClick 함수는 onClick 이벤트 핸들러로 전달됩니다. 이렇게 하면 React가 해당 함수를 기억하고 사용자가 버튼을 클릭할 때만 함수를 호출하도록 합니다.

두 번째 예제에서 handleClick()의 괄호 ()는 클릭 없이도 렌더링 중에 즉시 함수를 실행합니다. 이는 JSX `{` 및 `}` 내의 JavaScript가 즉시 실행되기 때문입니다.

인라인으로 작성한 코드의 경우에도 동일한 함정이 다른 형태로 나타납니다:

| 함수 전달 (올바른 방법) | 함수 호출 (잘못된 방법) |
| --- | --- |
| `<button onClick={() => alert('...')}>` | `<button onClick={alert('...')}>` |


이와 같이 인라인 코드를 전달하면 클릭 시 실행되지 않고, 컴포넌트가 렌더링될 때마다 실행됩니다.

```jsx
// 이 경고는 버튼을 클릭하는 대신 컴포넌트가 렌더링될 때마다 실행됩니다!
<button onClick={alert('You clicked me!')}>
```

인라인으로 이벤트 핸들러를 정의하는 경우 다음과 같이 익명 함수로 감싸야 합니다.

```jsx
<button onClick={() => alert('You clicked me!')}>
```

이를테면 이렇게 작성된 코드는 함수를 전달하려는 것입니다.

- `<button onClick={handleClick}>`는 `handleClick` 함수를 전달합니다.
- `<button onClick={() => alert('...')}>`는 `() => alert('...')` 함수를 전달합니다.

[화살표 함수에 대해 자세히 알아보세요.](https://javascript.info/arrow-functions-basics)
</Callout>


#### 이벤트 핸들러에서 props 읽기

이벤트 핸들러는 컴포넌트 내에서 정의되므로 컴포넌트의 props에 접근할 수 있습니다. 다음은 클릭 시 메시지 prop을 표시하는 버튼입니다.

<iframe 
  src="https://codesandbox.io/embed/fast-cdn-rkshhm?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="fast-cdn-rkshhm"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


이렇게 하면 두 개의 버튼이 다른 메시지를 표시할 수 있습니다. 메시지를 변경해 보세요.


#### 이벤트 핸들러를 속성으로 전달하기

자주 사용되는 시나리오 중 하나는 상위 컴포넌트에서 자식의 이벤트 핸들러를 지정하는 것입니다. 예를 들어 버튼을 고려해 보겠습니다. Button 컴포넌트를 사용하는 위치에 따라 다른 기능을 실행할 수 있습니다. 예를 들어 한 컴포넌트에서는 영화 재생을 실행하고 다른 컴포넌트에서는 이미지를 업로드할 수 있습니다.

이를 위해 다음과 같이 이벤트 핸들러로 전달되는 속성을 사용합니다.

<iframe 
  src="https://codesandbox.io/embed/jovial-frost-y81hok?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="jovial-frost-y81hok"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


여기에서 Toolbar 컴포넌트는 PlayButton과 UploadButton을 렌더링합니다.

- PlayButton은 내부의 Button에 onClick prop으로 handlePlayClick을 전달합니다.
- UploadButton은 내부의 Button에 onClick prop으로 `() => alert('Uploading!')`을 전달합니다.

마지막으로 Button 컴포넌트는 onClick이라는 prop을 허용합니다. 이 prop을 바로 내장된 브라우저의 `<button>`에 `onClick={onClick}`로 전달합니다. 이렇게 하면 React가 클릭 시 전달된 함수를 호출합니다.

디자인 시스템을 사용하는 경우 버튼과 같은 컴포넌트에는 스타일링만 포함되고 동작은 지정되지 않는 것이 일반적입니다. 대신 PlayButton과 UploadButton과 같은 컴포넌트에서 이벤트 핸들러를 전달합니다.


#### 이벤트 핸들러 속성의 이름 정하기

`<button>` 및 `<div>`와 같은 내장된 컴포넌트는 onClick과 같은 [브라우저 이벤트 이름](https://react.dev/reference/react-dom/components/common#common-props)만 지원합니다. 그러나 직접 만드는 컴포넌트에서는 이벤트 핸들러 속성의 이름을 원하는 대로 지정할 수 있습니다.

관례적으로 이벤트 핸들러 속성은 on으로 시작하고 대문자로 시작하는 형식으로 작성해야 합니다.

예를 들어 Button 컴포넌트의 onClick prop은 `onSmash`로 지정할 수 있습니다.

<iframe 
  src="https://codesandbox.io/embed/trusting-villani-hwd014?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="trusting-villani-hwd014"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


이 예제에서 `<button onClick={onSmash}>`는 브라우저의 `<button>` (소문자)에 여전히 onClick이라는 prop이 필요하지만, 사용자 정의 Button 컴포넌트에서 받는 prop 이름은 개발자의 선택에 따라 달라집니다.

컴포넌트가 여러 상호작용을 지원하는 경우 앱 특정 개념에 대한 이벤트 핸들러 속성의 이름을 지정할 수 있습니다. 예를 들어 Toolbar 컴포넌트는 `onPlayMovie` 및 `onUploadImage` 이벤트 핸들러를 받습니다.

<iframe 
  src="https://codesandbox.io/embed/cool-wildflower-h1031c?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="cool-wildflower-h1031c"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


App 컴포넌트는 Toolbar가 onPlayMovie 또는 onUploadImage를 어떻게 사용하는지 알 필요가 없습니다. 이것은 Toolbar의 구현 세부사항입니다. 여기에서 Toolbar는 이를 onClick 핸들러로 Button에 전달하지만, 나중에 키보드 단축키에서도 실행할 수 있습니다. onPlayMovie과 같은 앱 특정 상호작용에 대한 props 이름을 사용하면 나중에 사용 방식을 변경할 수 있는 유연성을 제공합니다.

> 참고
이벤트 핸들러에 적합한 HTML 태그를 사용하는지 확인하세요. 예를 들어, 클릭을 처리하려면 [`<button onClick={handleClick}>`](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button)와 같이 `<div onClick={handleClick}>` 대신 실제 브라우저 `<button>`을 사용해야 합니다. 실제 브라우저 `<button>`을 사용하면 키보드 탐색과 같은 내장된 브라우저 동작이 가능해집니다. 버튼의 기본 브라우저 스타일을 좋아하지 않고 링크나 다른 UI 요소와 유사한 모습으로 변경하려면 CSS를 사용하여 구현할 수 있습니다. [접근성 있는 마크업 작성에 대해 자세히 알아보세요.](https://developer.mozilla.org/en-US/docs/Learn/Accessibility/HTML)



### 이벤트 전파

이벤트 핸들러는 해당 컴포넌트의 자식 요소에서도 이벤트를 캐치합니다. 이벤트가 "버블링" 또는 "전파"되어 트리 상위로 이동한다고 말합니다. 이 `<div>`는 두 개의 버튼을 포함하고 있습니다. `<div>`와 각 버튼에는 자체적인 onClick 핸들러가 있습니다. 버튼을 클릭하면 어떤 핸들러가 실행될 것 같나요?

<iframe 
  src="https://codesandbox.io/embed/intelligent-rui-u3njul?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="intelligent-rui-u3njul"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


버튼을 클릭하면 해당 버튼의 onClick이 먼저 실행되고 그 다음에 부모 `<div>`의 onClick이 실행됩니다. 따라서 두 개의 메시지가 표시됩니다. 툴바 자체를 클릭하면 부모 `<div>`의 onClick만 실행됩니다.

<Callout type="warning">
**주의사항**

모든 이벤트는 React에서 전파되며, 그 중에서도 onScroll은 연결된 JSX 태그에서만 작동합니다.
</Callout>



#### 전파 중지

이벤트 핸들러는 **이벤트 객체**를 유일한 인수로 받습니다. 관례적으로 이벤트 객체의 변수명은 e로 사용됩니다. 이 객체를 사용하여 이벤트에 대한 정보를 읽을 수 있습니다.

이벤트 전파를 중지할 수도 있습니다. 이벤트가 상위 컴포넌트로 전달되지 않도록 하려면 e.stopPropagation()을 호출해야 합니다. Button 컴포넌트에서 이렇게 하고 있습니다.

<iframe 
  src="https://codesandbox.io/embed/jolly-hooks-xeej9l?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="jolly-hooks-xeej9l"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


버튼을 클릭하면 다음과 같은 작업을 수행합니다.

1. React는 `<button>`에 전달된 onClick 핸들러를 호출합니다.
2. Button에서 정의된 이 핸들러는 다음 작업을 수행합니다.
    - `e.stopPropagation()`을 호출하여 이벤트가 더 이상 전파되지 않도록 합니다.
    - onClick 함수를 호출합니다. 이 함수는 Toolbar 컴포넌트에서 전달된 prop입니다.
3. Toolbar 컴포넌트에서 정의된 이 함수는 버튼의 알림을 표시합니다.
4. 전파가 중지되었기 때문에 부모 `<div>`의 onClick 핸들러는 실행되지 않습니다.

`e.stopPropagation()`을 통해 버튼을 클릭하면 두 개의 알림 대신 하나의 알림만 표시됩니다. 이는 버튼을 클릭하는 것과 툴바 자체를 클릭하는 것은 다른 동작이기 때문에 전파를 중지하는 것이 이 UI에 맞습니다.

<Callout>
**캡처 단계 이벤트**

드물게, 전파가 중지된 이벤트에 대해서도 모든 자식 요소의 이벤트를 캐치해야 할 수 있습니다. 예를 들어 전파 논리와 상관없이 모든 클릭을 분석에 기록하려는 경우입니다. 다음과 같이 이벤트 이름 끝에 Capture를 추가하여 이를 수행할 수 있습니다.

```jsx
<div onClickCapture={() => { /* 이것이 가장 먼저 실행됩니다 */ }}>
  <button onClick={e => e.stopPropagation()} />
  <button onClick={e => e.stopPropagation()} />
</div>
```

각 이벤트는 세 단계로 전파됩니다.

1. 모든 onClickCapture 핸들러를 호출하면서 아래로 이동합니다.
2. 클릭한 요소의 onClick 핸들러를 실행합니다.
3. 위로 이동하면서 모든 onClick 핸들러를 호출합니다.

Capture 이벤트는 라우터나 분석과 같은 코드에 유용하지만, 앱 코드에서는 사용하지 않을 것입니다.
</Callout>

#### 전파 대신 핸들러 전달하기

다음과 같이 이 클릭 핸들러는 코드 한 줄을 실행하고 그 다음에 부모로부터 전달받은 onClick prop을 호출합니다.

```jsx
function Button({ onClick, children }) {
  return (
    <button onClick={e => {
      e.stopPropagation();
      onClick();
    }}>
      {children}
    </button>
  );
}
```

onClick 이벤트 핸들러 전에 더 많은 코드를 추가하여도 됩니다. 이 패턴은 전파 대신에 대체 수단을 제공합니다. 자식 컴포넌트에서 이벤트를 처리하면서 동시에 부모 컴포넌트에서 일부 추가 동작을 지정할 수 있습니다. 전파와 달리 이 방식은 자동적이지 않습니다. 하지만 이 패턴의 장점은 어떤 이벤트로 인해 일어나는 전체 코드 체인을 명확하게 따를 수 있다는 점입니다.

전파에 의존하고 있고 어떤 핸들러가 실행되는지 추적하기 어려운 경우에는 이 접근 방식을 대신 사용해 보세요.

#### 기본 동작 방지

일부 브라우저 이벤트에는 기본 동작이 연결되어 있습니다. 예를 들어 `<form>` 내에서 버튼을 클릭할 때 발생하는 제출(submit) 이벤트는 기본적으로 전체 페이지를 다시 로드합니다.

<iframe 
  src="https://codesandbox.io/embed/still-hill-uqe5bm?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="still-hill-uqe5bm"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


이를 방지하기 위해 이벤트 객체에서 `e.preventDefault()`를 호출할 수 있습니다.

<iframe 
  src="https://codesandbox.io/embed/zen-mccarthy-g080oe?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="zen-mccarthy-g080oe"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


`e.stopPropagation()`와 `e.preventDefault()`을 혼동하지 마세요. 두 가지 모두 유용하지만 관련성이 없습니다.

- [e.stopPropagation()](https://developer.mozilla.org/docs/Web/API/Event/stopPropagation)은 상위 태그에 연결된 이벤트 핸들러의 실행을 막습니다.
- [e.preventDefault()](https://developer.mozilla.org/docs/Web/API/Event/preventDefault)은 일부 이벤트에 대한 브라우저의 기본 동작을 막습니다.

### 이벤트 핸들러에서 Side-effect이 가능한가요?

절대로 가능합니다! 이벤트 핸들러는 Side-effect을 위한 최적의 장소입니다.

렌더링 함수와는 달리 이벤트 핸들러는 [순수함](https://react.dev/learn/keeping-components-pure)이 될 필요가 없으므로 입력 타이핑에 따라 입력의 값 변경이나 버튼 누름에 따라 목록 변경과 같은 작업을 수행하는 데 좋은 장소입니다. 그러나 정보를 변경하기 위해서는 먼저 정보를 저장하는 방법이 필요합니다. React에서는 이를 [상태(state), 컴포넌트의 메모리](https://react.dev/learn/state-a-components-memory)를 사용하여 수행합니다. 이에 대해 다음 페이지에서 자세히 알아보게 됩니다.

### 요약

- `<button>`과 같은 요소에 함수를 prop으로 전달하여 이벤트를 처리할 수 있습니다.
- 이벤트 핸들러는 호출하지 않고 전달해야 합니다! `onClick={handleClick}`이 아닌 `onClick={handleClick()}`입니다.
- 이벤트 핸들러 함수를 별도로 정의하거나 JSX 내에서 인라인으로 정의할 수 있습니다.
- 이벤트 핸들러는 컴포넌트 내에서 정의되므로 props에 액세스할 수 있습니다.
- 부모에서 정의된 이벤트 핸들러를 자식에게 전달하는 prop으로 전달할 수 있습니다.
- 앱별 개념을 위해 사용자 정의 이벤트 핸들러 prop의 이름을 지정할 수 있습니다.
- 이벤트는 상위로 전파합니다. 이를 막으려면 첫 번째 인수에 `e.stopPropagation()`을 호출하세요.
- 원하지 않는 기본 브라우저 동작이 있는 이벤트가 있을 수 있습니다. 이를 방지하려면 `e.preventDefault()`를 호출하세요.
- 자식 핸들러에서 부모 핸들러의 prop을 명시적으로 호출하는 것은 전파에 대한 대체 수단입니다.





## 상태(state): 컴포넌트의 메모리

컴포넌트는 상호작용 결과로 화면에 표시되는 내용을 변경해야 하는 경우가 많습니다. 예를 들어, 폼에 입력하면 입력 필드가 업데이트되어야 하고, 이미지 캐로셀에서 "다음"을 클릭하면 표시되는 이미지가 변경되어야 하며, "구매"를 클릭하면 제품이 장바구니에 추가되어야 합니다. 컴포넌트는 이런 정보를 "기억"해야 합니다. 현재 입력 값, 현재 이미지, 장바구니와 같은 것들을 말이죠. React에서는 이러한 컴포넌트별 메모리를 상태(state)라고 합니다.

다음 내용을 배우게 됩니다.

- [useState](https://react.dev/reference/react/useState) Hook을 사용하여 상태 변수를 추가하는 방법
- useState Hook이 반환하는 값의 쌍
- 여러 개의 상태 변수를 추가하는 방법
- 상태가 왜 로컬(local)이라고 불리는지

### 일반 변수만으로는 부족할 때

다음과 같이 조각 이미지를 렌더링하는 컴포넌트가 있습니다. "다음" 버튼을 클릭하면 인덱스가 1, 2 등으로 변경되어 다음 조각이 표시되어야 합니다. 그러나 이 방식은 **작동하지 않습니다**(시도해 볼 수 있습니다!):

<iframe 
  src="https://codesandbox.io/embed/compassionate-chaplygin-tejhuy?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="compassionate-chaplygin-tejhuy"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


handleClick 이벤트 핸들러는 로컬 변수인 index를 업데이트합니다. 그러나 변경 사항이 보이지 않게 하는 두 가지 이유가 있습니다:

1. **로컬 변수는 렌더링 간에 지속되지 않습니다.** React는 이 컴포넌트를 두 번째로 렌더링할 때 완전히 처음부터 렌더링하므로 로컬 변수의 변경 사항을 고려하지 않습니다.
2. **로컬 변수의 변경 사항은 렌더링을 트리거하지 않습니다.** React는 새로운 데이터로 컴포넌트를 다시 렌더링해야 함을 인지하지 못합니다.

새로운 데이터로 컴포넌트를 업데이트하려면 두 가지 작업이 필요합니다:

1. **데이터를 유지**합니다(렌더링 간에).
2. 새 데이터로 컴포넌트를 다시 **렌더링**합니다.

이러한 두 가지를 제공하는 것이 [useState](https://react.dev/reference/react/useState) Hook입니다:

1. **상태 변수**를 유지하는 데 사용됩니다.
2. **상태 설정 함수**를 제공하여 상태 변수를 업데이트하고 React에 컴포넌트를 다시 렌더링하도록 합니다.



### 상태 변수 추가

먼저 파일 상단에서 React에서 useState를 가져오세요:

```jsx
import { useState } from 'react';
```

그런 다음 이 줄:

```jsx
let index = 0;
```

다음과 같이 대체하세요:

```jsx
const [index, setIndex] = useState(0);
```

index는 상태 변수이고 setIndex는 설정 함수입니다.

> 여기서 사용된 `[`와 `]` 구문은 [배열 비구조화](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)라고 하며, 배열에서 값을 읽는 데 사용됩니다. useState에서 반환되는 배열은 항상 두 개의 항목이 있습니다.

다음은 handleClick에서 이들이 함께 작동하는 방식입니다:

```jsx
function handleClick() {
  setIndex(index + 1);
}
```

이제 "다음" 버튼을 클릭하면 현재 조각이 전환됩니다:

<iframe 
  src="https://codesandbox.io/embed/upbeat-keldysh-0efc0f?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="upbeat-keldysh-0efc0f"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


#### 첫 번째 Hook 만나보기

React에서 useState와 같이 "use"로 시작하는 함수를 포함하여 다른 기능을 사용할 때는 Hook이라고 부릅니다.

Hook은 React가 [렌더링](https://react.dev/learn/render-and-commit#step-1-trigger-a-render)하는 동안에만 사용할 수 있는 특별한 함수입니다(다음 페이지에서 자세히 알아보겠습니다). 이를 통해 다양한 React 기능에 "연결"할 수 있습니다.

상태는 이러한 기능 중 하나일 뿐이지만, 나중에 다른 Hook들을 배우게 될 것입니다.

<Callout type="warning">
**주의사항**

**Hook은 use로 시작하는 함수로써 컴포넌트의 최상위 수준이나 [자체적인 Hook](https://react.dev/learn/reusing-logic-with-custom-hooks) 내에서만 호출할 수 있습니다.** 조건문, 반복문 또는 다른 중첩된 함수 내에서는 Hook을 호출할 수 없습니다. Hook은 함수이지만 컴포넌트의 필요에 대한 무조건적인 선언으로 생각하는 것이 도움이 됩니다. 파일의 최상단에서 모듈을 가져오는 방식과 유사하게, 컴포넌트의 최상단에서 React 기능을 "사용"합니다.
</Callout>

#### useState의 구조

[useState](https://react.dev/reference/react/useState)를 호출하면 이 컴포넌트가 어떤 정보를 기억하길 원하는지 React에 알리는 것입니다:

```jsx
const [index, setIndex] = useState(0);
```

이 경우 React에 index를 기억하길 원한다고 알립니다.

<Callout>

관례적으로 이러한 쌍을 `const [something, setSomething]`과 같이 지정합니다. 이름을 원하는 대로 지정할 수 있지만, 관례를 따르면 다른 프로젝트에서 이해하기 쉽습니다.

useState의 유일한 인수는 상태 변수의 **초기 값**입니다. 이 예제에서 index의 초기 값은 `useState(0)`으로 설정됩니다.

컴포넌트가 렌더링될 때마다 useState는 다음과 같은 두 개의 값을 포함하는 배열을 제공합니다:

1. 현재 상태 값을 가진 **상태 변수**(index)
2. 상태 변수를 업데이트하고 React에 컴포넌트를 다시 렌더링하도록 하는 **상태 설정 함수**(setIndex)

다음은 실제로 동작하는 방식입니다:

```jsx
const [index, setIndex] = useState(0);
```

1. **컴포넌트가 처음 렌더링됩니다.** index의 초기 값으로 0을 useState에 전달했으므로, `[0, setIndex]`를 반환합니다. React는 0이 최신 상태 값이라는 것을 기억합니다.
2. **상태를 업데이트합니다.** 사용자가 버튼을 클릭하면 `setIndex(index + 1)`를 호출합니다. index는 0이므로 `setIndex(1)`로 설정됩니다. 이는 React에 index가 이제 1이라는 것을 기억하고 다시 렌더링을 트리거합니다.
3. **컴포넌트가 두 번째로 렌더링됩니다.** React는 여전히 `useState(0)`을 보지만, index가 1로 설정된 것을 기억하고 `[1, setIndex]`를 반환합니다.
4. 그리고 이어집니다!
</Callout>


### 컴포넌트에 여러 개의 상태 변수 제공

한 컴포넌트에 여러 개의 상태 변수와 여러 가지 타입의 상태 변수를 가질 수 있습니다. 다음 컴포넌트는 숫자 index와 "자세히 보기" 버튼을 클릭할 때 토글되는 불리언 showMore의 두 가지 상태 변수를 가지고 있습니다:

<iframe 
  src="https://codesandbox.io/embed/agitated-burnell-jcnbsj?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="agitated-burnell-jcnbsj"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


index와 showMore와 같이 상태가 관련 없을 경우에는 여러 개의 상태 변수를 가지는 것이 좋은 아이디어입니다. 그러나 두 상태 변수를 함께 자주 변경한다는 것을 알게 된다면, 두 변수를 하나로 결합하는 것이 더 편리할 수 있습니다. 예를 들어, 여러 필드가 있는 폼인 경우, 필드마다 상태 변수를 갖는 것보다 객체를 하나의 상태 변수로 가지는 것이 더 편리합니다. 더 많은 팁은 [상태 구조 선택하기](https://react.dev/learn/choosing-the-state-structure)에서 읽어볼 수 있습니다.

<Callout>
**React는 어떻게 상태를 반환할까요?**

useState 호출에는 어떤 상태 변수를 참조하는지에 대한 정보가 전달되지 않는다는 사실을 알 수 있습니다. useState에 전달되는 "식별자"가 없으므로 상태 변수 중 어떤 것을 반환할지를 어떻게 알까요? 이를 위해 함수를 구문 분석하는 것과 같은 마법같은 방법을 사용할까요? 답은 아닙니다.

대신, 간결한 구문을 위해 Hook은 **동일한 컴포넌트의 모든 렌더링에서 안정된 호출 순서에 의존**합니다. 이는 실제로는 잘 작동하는데, 위의 규칙("Hook은 최상위 수준에서만 호출하세요")을 따른다면 Hook은 항상 동일한 순서로 호출됩니다. 또한 [린터 플러그인](https://www.npmjs.com/package/eslint-plugin-react-hooks)이 대부분의 실수를 잡아줍니다.

내부적으로 React는 모든 컴포넌트에 대해 상태 쌍 배열을 유지합니다. 또한 현재 쌍 인덱스를 유지하며, 렌더링 전에 인덱스를 0으로 설정합니다. useState를 호출할 때마다 React는 다음 상태 쌍을 제공하고 인덱스를 증가시킵니다. 이 메커니즘에 대한 자세한 내용은 [React Hooks: Not Magic, Just Arrays](https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e)에서 읽을 수 있습니다.

이 예제는 **React를 사용하지 않지만**, useState가 내부적으로 어떻게 작동하는지에 대한 개념을 이해하는 데 도움이 될 수 있습니다:

React를 사용하기 위해 이해할 필요는 없지만, 이것은 유용한 개념 모델일 수 있습니다.
</Callout>



### 상태는 격리되고 비공개입니다.

상태는 화면의 컴포넌트 인스턴스에 대해 로컬입니다. 다른 말로 하면, **동일한 컴포넌트를 두 번 렌더링하면 각각이 완전히 격리된 상태를 가집니다!** 그 중 하나를 변경해도 다른 하나에는 영향을 미치지 않습니다.

이 예제에서는 이전에 보여준 갤러리 컴포넌트가 로직에 변경 없이 두 번 렌더링됩니다. 각 갤러리 안의 버튼을 클릭해 보세요. 그들의 상태가 독립적임을 알 수 있습니다:

<iframe 
  src="https://codesandbox.io/embed/divine-currying-rodp3h?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="divine-currying-rodp3h"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


이것이 상태를 모듈의 맨 위에 선언하는 일반 변수와 다른 점입니다. 상태는 특정 함수 호출이나 코드의 위치에 연결되지 않지만, 화면의 특정 위치에 "로컬"되어 있습니다. 여러분은 두 개의 `<Gallery />` 컴포넌트를 렌더링했으므로 그들의 상태는 별도로 저장됩니다.

또한 Page 컴포넌트가 갤러리 상태를 "알지" 않거나 상태가 있는지 여부를 모릅니다. props와 달리 **상태는 선언한 컴포넌트에 완전히 비공개**입니다. 부모 컴포넌트는 상태를 변경할 수 없습니다. 이렇게 하면 다른 컴포넌트에 영향을 주지 않고 어떤 컴포넌트에든 상태를 추가하거나 제거할 수 있습니다.

만약 두 개의 갤러리가 상태를 동기화하여 유지하려면 React에서는 자식 컴포넌트에서 상태를 제거하고 가장 가까운 공유 부모에 상태를 추가하는 것이 옳은 방법입니다. 다음 몇 페이지에서는 단일 컴포넌트의 상태를 조직화하는 방법에 초점을 맞출 것이지만, [컴포넌트 간에 상태 공유하기](https://react.dev/learn/sharing-state-between-components) 주제로 돌아올 것입니다.

### 요약

- 컴포넌트가 렌더링 간에 일부 정보를 "기억"해야 할 때 상태 변수를 사용합니다.
- 상태 변수는 useState Hook을 호출하여 선언합니다.
- Hook은 "use"로 시작하는 특별한 함수입니다. 이를 통해 상태와 같은 React 기능에 "연결"할 수 있습니다.
- Hook은 import와 비슷한 방식으로 호출되어야 합니다. useState를 포함한 Hook 호출은 컴포넌트의 최상위 수준이나 다른 Hook 내에서만 유효합니다.
- useState Hook은 현재 상태와 상태를 업데이트할 수 있는 함수의 쌍을 반환합니다.
- 여러 개의 상태 변수를 가질 수 있습니다. React 내부적으로 순서를 맞춥니다.
- 상태는 컴포넌트에 대해 비공개입니다. 동일한 컴포넌트를 여러 곳에서 렌더링하면 각각의 사본에는 독립적인 상태가 있습니다.





## 렌더링과 커밋


컴포넌트가 화면에 표시되기 전에 React에 의해 렌더링되어야 합니다. 이 과정에서의 단계를 이해하면 코드가 실행되는 방식을 생각하고 그 동작을 설명할 수 있습니다.

배울 내용

- React에서 렌더링이란 무엇인지
- 컴포넌트가 언제 그리고 왜 렌더링되는지
- 컴포넌트를 화면에 표시하는 과정
- 렌더링이 항상 DOM 업데이트를 유발하지 않는 이유

상상해보세요. 컴포넌트는 주방에서 재료를 사용하여 맛있는 요리를 조리하는 요리사입니다. 이 시나리오에서 React는 손님의 요청을 받고 주문을 전달하는 웨이터입니다. UI에 대한 요청과 제공이 이루어지는 과정은 세 가지 단계로 이루어집니다:

1. 렌더를 **트리거**합니다(손님의 주문을 주방에 전달합니다).
2. 컴포넌트를 **렌더링**합니다(주문을 주방에서 처리합니다).
3. DOM에 **커밋**합니다(주문을 테이블에 올려놓습니다).

### 단계 1: 렌더 트리거

컴포넌트가 렌더링되는 이유는 두 가지입니다:

1. 컴포넌트의 **초기 렌더링**입니다.
2. 컴포넌트(또는 그 조상 중 하나)의 **상태가 업데이트**되었습니다.

#### 초기 렌더링

앱이 시작될 때 초기 렌더링을 트리거해야 합니다. 프레임워크나 샌드박스는 때로 이 코드를 숨깁니다. 그러나 대상 DOM 노드로 [createRoot](https://react.dev/reference/react-dom/client/createRoot)를 호출하고 컴포넌트와 함께 렌더 메서드를 호출함으로써 이를 수행합니다:

<iframe 
  src="https://codesandbox.io/embed/gallant-waterfall-mnfdp5?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="gallant-waterfall-mnfdp5"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


`root.render()` 호출을 주석 처리하고 컴포넌트가 사라지는 것을 확인해보세요!

#### 상태 업데이트에 따른 재렌더링

컴포넌트가 초기 렌더링된 후에는 상태를 업데이트하여 추가적인 렌더링을 트리거할 수 있습니다. [set 함수](https://react.dev/reference/react/useState#setstate)를 사용하여 컴포넌트의 상태를 업데이트하면 자동으로 렌더링이 대기열에 추가됩니다. (각 상태 업데이트마다 고객의 목마름이나 배고픔에 따라 차, 디저트 및 다른 다양한 주문을 넣는 고객처럼 상상해볼 수 있습니다.)

### 단계 2: React가 컴포넌트를 렌더링

렌더링을 트리거한 후에 React는 화면에 표시할 내용을 결정하기 위해 컴포넌트를 호출합니다. **"렌더링"은 React가 컴포넌트를 호출하는 것입니다.**

- **초기 렌더링에서** React는 루트 컴포넌트를 호출합니다.
- **추가적인 렌더링에서** React는 렌더링을 트리거한 함수 컴포넌트를 호출합니다.

이 프로세스는 재귀적으로 진행됩니다. 업데이트된 컴포넌트가 다른 컴포넌트를 반환하면 React는 해당 컴포넌트를 다음으로 렌더링하고, 그 컴포넌트도 무언가를 반환하면 다음 컴포넌트를 렌더링하고, 이런 식으로 계속 진행됩니다. 이 프로세스는 중첩된 컴포넌트가 더 이상 없을 때까지 계속되며, React는 정확히 어떤 내용을 화면에 표시해야 하는지 알게 됩니다.

다음 예제에서 React는 `Gallery()`와 `Image()`를 여러 번 호출합니다:

<iframe 
  src="https://codesandbox.io/embed/practical-mccarthy-1p08zd?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="practical-mccarthy-1p08zd"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


- **초기 렌더링 중** React는 `<section>`, `<h1>`, 그리고 세 개의 `<img>` 태그에 대한 [DOM 노드를 생성](https://developer.mozilla.org/docs/Web/API/Document/createElement)합니다.
- **재렌더링 중** React는 이전 렌더링과 비교하여 변경된 속성을 계산합니다. 이 정보를 다음 단계인 커밋 단계에서 사용하기 전까지는 아무 작업도 수행하지 않습니다.

<Callout type="warning">
**주의점**

렌더링은 항상 [순수한 계산](https://react.dev/learn/keeping-components-pure)이어야 합니다:

- **동일한 입력에 대해 동일한 출력을 반환**합니다. 동일한 입력이 주어지면 컴포넌트는 항상 동일한 JSX를 반환해야 합니다. (샐러드에 토마토를 주문한 사람은 양파가 들어간 샐러드를 받아서는 안 됩니다!)
- **자신의 업무에만 집중**해야 합니다. 렌더링 이전에 존재한 객체나 변수를 변경해서는 안 됩니다. (한 주문이 다른 사람의 주문을 변경해서는 안 됩니다.)

그렇지 않으면 코드베이스가 복잡해짐에 따라 혼란스러운 버그와 예측할 수 없는 동작을 경험할 수 있습니다. "Strict 모드"에서 개발할 때 React는 각 컴포넌트 함수를 두 번 호출하여 비순수 함수에 의한 오류를 파악하는 데 도움이 됩니다.
</Callout>

<Callout>
**성능 최적화**

업데이트된 컴포넌트의 모든 중첩된 컴포넌트를 렌더링하는 기본 동작은 트리에서 상위에 위치한 업데이트된 컴포넌트의 성능에는 적합하지 않습니다. 성능 문제가 발생하는 경우, [성능](https://reactjs.org/docs/optimizing-performance.html) 섹션에 설명된 몇 가지 최적화 방법을 선택적으로 사용하여 문제를 해결할 수 있습니다. **너무 일찍 최적화하지 마세요!**
</Callout>

### 단계 3: React가 DOM에 변경 사항을 커밋

컴포넌트를 렌더링(호출)한 후에 React는 DOM을 수정합니다.

- **초기 렌더링에서** React는 생성한 모든 DOM 노드를 [appendChild()](https://developer.mozilla.org/docs/Web/API/Node/appendChild) DOM API를 사용하여 화면에 배치합니다.
- **재렌더링에서** React는 (렌더링 중 계산된) 최소한의 작업을 수행하여 DOM을 최신 렌더링 결과와 일치하도록 합니다.

**React는 렌더링 결과가 이전과 동일한 경우에는 DOM 노드를 변경하지 않습니다.** 예를 들어, 다음은 부모로부터 전달되는 다른 속성으로 재렌더링되는 컴포넌트입니다. `<input>`에 텍스트를 추가하여 값을 업데이트할 수 있지만, 컴포넌트가 재렌더링되어도 텍스트가 사라지지 않습니다:

<iframe 
  src="https://codesandbox.io/embed/modern-snowflake-y5b4hi?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="modern-snowflake-y5b4hi"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>



이 작동하는 이유는 마지막 단계에서 React가 `<h1>`의 내용만 새로운 시간으로 업데이트하기 때문입니다. JSX에서 `<input>`이 동일한 위치에 있음을 알 수 있으므로 React는 `<input>` 또는 그 값을 변경하지 않습니다!

### 에필로그: 브라우저 페인팅

렌더링이 완료되고 React가 DOM을 업데이트한 후에 브라우저는 화면을 다시 그립니다. 이 과정을 "브라우저 렌더링"이라고 알려져 있지만 이 문서에서는 혼동을 피하기 위해 "페인팅"으로 표현합니다.

### 요약

- React 앱에서 화면 업데이트는 세 단계로 진행됩니다:
    1. 트리거
    2. 렌더
    3. 커밋
- Strict 모드를 사용하여 컴포넌트의 오류를 찾을 수 있습니다.
- 렌더링 결과가 이전과 동일한 경우 React는 DOM을 변경하지 않습니다.


## 상태(state)를 스냅샷으로 사용


상태 변수는 읽고 쓸 수 있는 일반적인 JavaScript 변수처럼 보일 수 있습니다. 하지만 상태는 더 이상의 스냅샷과 비슷한 동작을 합니다. 상태를 설정하면 이미 가지고 있는 상태 변수가 변경되는 것이 아니라, 리렌더링을 트리거합니다.

배울 내용

- 상태를 설정하는 것이 어떻게 리렌더링을 트리거하는지
- 상태가 언제와 어떻게 업데이트되는지
- 상태를 설정한 후에 즉시 업데이트되지 않는 이유
- 이벤트 핸들러가 상태의 "스냅샷"에 접근하는 방법

### 상태 설정이 리렌더링을 트리거합니다

사용자 인터페이스를 클릭과 같은 사용자 이벤트에 직접 반응하여 변경된다고 생각할 수 있습니다. React에서는 이러한 개념과 약간 다르게 동작합니다. 이전 페이지에서 [상태 설정이 React에게 리렌더링을 요청한다는 것을 보았습니다](https://react.dev/learn/render-and-commit#step-1-trigger-a-render). 즉, 인터페이스가 이벤트에 반응하려면 상태를 업데이트해야 합니다.

이 예제에서 "send"를 누를 때 `setIsSent(true)`는 React에게 UI를 리렌더링하도록 지시합니다:

<iframe 
  src="https://codesandbox.io/embed/laughing-benji-yxnodj?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="laughing-benji-yxnodj"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


버튼을 클릭할 때 일어나는 일은 다음과 같습니다:

1. `onSubmit` 이벤트 핸들러가 실행됩니다.
2. `setIsSent(true)`는 `isSent`를 true로 설정하고 새로운 리렌더링을 큐에 추가합니다.
3. React는 새로운 `isSent` 값을 기반으로 컴포넌트를 다시 렌더링합니다.

상태와 렌더링 사이의 관계를 좀 더 자세히 살펴보겠습니다.


### 렌더링은 시간에 대한 스냅샷을 취합니다

[렌더링(Rendering)](https://react.dev/learn/render-and-commit#step-2-react-renders-your-components)은 React가 함수인 컴포넌트를 호출하는 것을 의미합니다. 해당 함수에서 반환하는 JSX는 시간에 따른 UI의 스냅샷과 유사합니다. 해당 스냅샷에서는 프롭스, 이벤트 핸들러 및 로컬 변수가 모두 계산되며 **해당 렌더링의 상태를 사용하여 계산**됩니다.

사진이나 동영상 프레임과 달리 반환하는 UI "스냅샷"은 상호작용할 수 있습니다. 이는 이벤트 핸들러와 같은 로직을 포함하며 입력에 대한 응답으로 어떤 작업이 수행되어야 하는지를 지정합니다. React는 화면을이 스냅샷과 일치하도록 업데이트하고 이벤트 핸들러를 연결합니다. 결과적으로 버튼을 누르면 JSX에서 지정한대로 클릭 핸들러가 트리거됩니다.

React가 컴포넌트를 다시 렌더링할 때:

1. React가 함수를 다시 호출합니다.
2. 함수는 새로운 JSX 스냅샷을 반환합니다.
3. React는 반환된 스냅샷에 맞게 화면을 업데이트합니다.

컴포넌트의 상태로서, 상태는 함수가 반환한 JSX의 스냅샷이 아닌 일반 변수와 같이 함수가 반환된 후에 사라지는 것이 아닙니다. 상태는 실제로 React 자체에 "살아있는" 것처럼 함수 외부의 장소에 "거주"합니다. React가 컴포넌트를 호출할 때 해당 렌더링을 위해 상태의 스냅샷을 제공합니다. 컴포넌트는 해당 렌더링의 상태 값을 사용하여 프롭스와 이벤트 핸들러가 포함된 JSX의 스냅샷을 반환합니다.

이 동작 방식을 보여주기 위해 작은 실험을 해보겠습니다. 이 예제에서 "3+" 버튼을 클릭하면 카운터가 세 번 증가할 것으로 예상할 수 있습니다. 왜냐하면 `setNumber(number + 1)`이 세 번 호출되기 때문입니다.

"3+" 버튼을 클릭할 때 어떤 일이 일어나는지 살펴보세요:

<iframe 
  src="https://codesandbox.io/embed/dry-forest-7os05q?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="dry-forest-7os05q"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


버튼을 클릭할 때 number가 한 번만 증가하는 것을 알 수 있습니다!

**상태 설정은 다음 렌더링을 위해만 변경합니다.** 첫 번째 렌더링에서 number는 0이었습니다. 이것은 렌더링의 `onClick` 핸들러에서도 `setNumber(number + 1)`이 호출된 후에도 number의 값이 여전히 0인 이유입니다:

```jsx
<button onClick={() => {
  setNumber(number + 1);
  setNumber(number + 1);
  setNumber(number + 1);
}}>+3</button>
```

이 버튼의 클릭 핸들러가 React에게 요청하는 일은 다음과 같습니다:

1. `setNumber(number + 1)`: number가 0이므로 `setNumber(0 + 1)`.
    - React는 다음 렌더링에서 number를 1로 변경하도록 준비합니다.
2. `setNumber(number + 1)`: number가 0이므로 `setNumber(0 + 1)`.
    - React는 다음 렌더링에서 number를 1로 변경하도록 준비합니다.
3. `setNumber(number + 1)`: number가 0이므로 `setNumber(0 + 1)`.
    - React는 다음 렌더링에서 number를 1로 변경하도록 준비합니다.

`setNumber(number + 1)`을 세 번 호출했지만, 이 렌더링의 이벤트 핸들러에서 number의 값은 항상 0입니다. 따라서 이벤트 핸들러가 완료된 후 React는 number가 3이 아닌 1인 상태로 컴포넌트를 다시 렌더링합니다.

이를 시각화하는 방법은 상태 변수를 코드에서 해당 값으로 대체하는 것입니다. 이 렌더링에서 number 상태 변수가 0이기 때문에 이벤트 핸들러는 다음과 같이 보입니다.

```jsx
<button onClick={() => {
  setNumber(0 + 1);
  setNumber(0 + 1);
  setNumber(0 + 1);
}}>+3</button>
```

다음 렌더링에서 number는 1이므로 해당 렌더링의 클릭 핸들러는 다음과 같이 보입니다.

```jsx
<button onClick={() => {
  setNumber(1 + 1);
  setNumber(1 + 1);
  setNumber(1 + 1);
}}>+3</button>
```

따라서 버튼을 다시 클릭하면 카운터가 2로, 다음 클릭에서는 3으로 설정됩니다.

### 시간에 따른 상태

재미있었죠. 이 버튼을 클릭하면 경고창에 어떤 내용이 표시되는지 추측해보세요:

<iframe 
  src="https://codesandbox.io/embed/cranky-breeze-qvkn25?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="cranky-breeze-qvkn25"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


이전과 같은 대체 방법을 사용하면 경고창이 "0"을 표시할 것으로 예상할 수 있습니다.

```jsx
setNumber(0 + 5);
alert(0);
```

그러나 경고창에 타이머를 설정하여 컴포넌트가 다시 렌더링된 후에만 활성화되도록 할 경우에는 어떻게 될까요? "0"이 표시될까요 아니면 "5"가 표시될까요? 아래 예제에서 예상해보고 실행해보세요!

<iframe 
  src="https://codesandbox.io/embed/small-mountain-9162ll?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="small-mountain-9162ll"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


놀라셨나요? 대체 방법을 사용하면 사용자가 해당 상태로 상호작용할 때 스냅샷으로 예약된 상태가 경고 실행 시점에 사용됩니다.

```jsx
setNumber(0 + 5);
setTimeout(() => {
  alert(0);
}, 3000);
```

React는 경고가 실행되는 시점에 상태가 변경되었을 수 있지만, 사용자가 상호작용하는 시점에서의 상태 스냅샷을 사용하여 예약되었습니다!

**렌더링 내에서 상태 변수의 값은 변경되지 않습니다.** 이벤트 핸들러의 코드가 비동기적인 경우에도 해당 렌더링의 `onClick`에서 number의 값은 계속 0입니다. React가 컴포넌트를 호출하여 UI의 스냅샷을 취할 때, number의 값이 "고정"되었습니다.

이로 인해 이벤트 핸들러가 시간에 민감한 오류를 일으키지 않도록 도와줍니다. 다음과 같은 시나리오를 상상해보세요. 다음과 같은 양식이 있는데, 이 양식은 5초 후에 메시지를 전송합니다.

1. "Send" 버튼을 눌러 "Hello"를 Alice에게 보냅니다.
2. 5초 지연이 끝나기 전에 "To" 필드의 값을 "Bob"으로 변경합니다.

경고창이 어떤 내용을 표시할지 예측해보세요. "You said Hello to Alice"가 표시될까요? 아니면 "You said Hello to Bob"이 표시될까요? 예측한 후에 실행해보세요!

<iframe 
  src="https://codesandbox.io/embed/nifty-burnell-r7e88v?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="nifty-burnell-r7e88v"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


**React는 렌더링 내에서 상태 값이 "고정"됩니다.** 코드가 실행되는 동안 상태가 변경되었는지 걱정할 필요가 없습니다.

하지만 다음 렌더링 이전에 최신 상태를 읽고 싶다면, 다음 페이지에서 다루는 [상태 업데이터 함수](https://react.dev/learn/queueing-a-series-of-state-updates)를 사용해야 합니다!

### 요약

- 상태를 설정하면 새로운 렌더링이 요청됩니다.
- React는 상태를 컴포넌트 외부에 저장합니다.
- useState를 호출하면 React는 해당 렌더링의 상태 스냅샷을 제공합니다.
- 변수와 이벤트 핸들러는 리렌더링 간에 "유지"되지 않습니다. 각 렌더링에는 고유한 이벤트 핸들러가 있습니다.
- 각 렌더링(및 해당 내부 함수)은 항상 해당 렌더링에게 주어진 상태 스냅샷을 "보게 됩니다.
- 상태를 이벤트 핸들러에서 사용할 때 상태를 마음속으로 대체하여 생각할 수 있습니다. 렌더링된 JSX를 생각하는 방식과 유사합니다.
- 과거에 생성된 이벤트 핸들러는 해당 렌더링에서 생성된 상태 값을 가집니다.





## 여러 개의 상태 업데이트를 큐에 저장하기


상태 변수를 설정하면 다음 렌더링이 예약됩니다. 하지만 때로는 다음 렌더링을 예약하기 전에 값을 여러 번 수정하고 싶을 수도 있습니다. 이를 위해 React가 상태 업데이트를 어떻게 일괄 처리하는지 이해하는 것이 도움이 됩니다.

배울 내용

- "일괄 처리(batching)"가 무엇이며 React가 여러 상태 업데이트를 처리하는 방법
- 같은 상태 변수에 여러 번 업데이트를 적용하는 방법

### React는 상태 업데이트를 일괄 처리합니다.

"3 추가" 버튼을 클릭하면 카운터가 세 번 증가할 것으로 예상할 수 있습니다. 왜냐하면 setNumber(number + 1)을 세 번 호출하기 때문입니다.

<iframe 
  src="https://codesandbox.io/embed/dry-forest-7os05q?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="dry-forest-7os05q"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


하지만 이전 섹션에서 살펴보았던 것처럼 [각 렌더링의 상태 값은 고정되어 있습니다](https://react.dev/learn/state-as-a-snapshot#rendering-takes-a-snapshot-in-time), 따라서 첫 번째 렌더링의 이벤트 핸들러 내부에서 number의 값은 항상 0입니다. setNumber(1)을 몇 번 호출하더라도 그렇습니다.

```jsx
setNumber(0 + 1);
setNumber(0 + 1);
setNumber(0 + 1);
```

그러나 여기에는 또 다른 요소가 작용합니다. **React는 이벤트 핸들러의 모든 코드가 실행된 후에 상태 업데이트를 처리합니다.** 이것이 setNumber() 호출 이후에만 재렌더링이 발생하는 이유입니다.

이는 레스토랑에서 웨이터가 주문을 받는 것을 떠올리게 할 수 있습니다. 웨이터는 처음 주문을 받는 순간부터 주방으로 달려가지 않습니다! 대신 주문을 마무리하고 변경할 수 있도록 하고, 심지어 테이블에서 다른 사람들의 주문을 받을 수 있습니다.

이를 통해 여러 개의 상태 변수를(심지어 여러 컴포넌트에서도) 업데이트할 수 있지만, [재렌더링을 일으키지 않고도](https://react.dev/learn/render-and-commit#re-renders-when-state-updates) 많은 수의 상태 업데이트를 처리할 수 있습니다. 하지만 이는 이벤트 핸들러와 그 안의 코드가 완료된 후에야 UI가 업데이트되는 것을 의미합니다. 이러한 동작은 **일괄 처리(batching)**라고도 불리며 React 앱을 더 빠르게 실행시키는 데 도움이 됩니다. 또한 일부 변수만이 업데이트된 "미완성" 렌더링으로 처리하는 혼란스러운 상황을 피할 수 있습니다.

**React는 클릭과 같은 여러 의도적인 이벤트를 일괄 처리하지 않습니다.** 각 클릭은 별개로 처리됩니다. React는 안전한 경우에만 일괄 처리를 수행하도록 합니다. 이렇게 함으로써 첫 번째 버튼 클릭이 양식을 비활성화하는 경우 두 번째 클릭이 양식을 다시 제출하지 않도록 합니다.

### 다음 렌더링 전에 동일한 상태를 여러 번 업데이트하기

이는 일반적으로 사용되지 않는 사용 사례이지만, 다음 렌더링 전에 동일한 상태 변수를 여러 번 업데이트하려면 `setNumber(number + 1)`과 같은 다음 상태 값을 전달하는 대신, `setNumber(n => n + 1)`과 같이 이전 상태를 기반으로 다음 상태를 계산하는 함수를 전달할 수 있습니다. 이는 React에게 "상태 값으로 무언가를 수행하라"고 말하는 방법입니다. 단순히 상태를 대체하는 것이 아니라 상태 값을 계산하는 함수를 전달하는 것입니다.

이제 카운터를 증가시켜보세요:

<iframe 
  src="https://codesandbox.io/embed/dazzling-minsky-vyqj9q?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="dazzling-minsky-vyqj9q"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


여기서 `n => n + 1`은 **업데이터 함수(updater function)**라고 불립니다. 이를 상태 setter에 전달할 때:

1.  React는 이 함수를 이벤트 핸들러의 다른 코드가 모두 실행된 후에 처리하기 위해 큐에 추가합니다.
2.  다음 렌더링 중에 React는 큐를 확인하고 최종 업데이트된 상태를 제공합니다.

```jsx
setNumber(n => n + 1);
setNumber(n => n + 1);
setNumber(n => n + 1);
```

다음과 같은 코드 라인을 실행하는 동안 React가 작동하는 방식은 다음과 같습니다.

1.  `setNumber(n => n + 1)`: `n => n + 1`은 함수입니다. React는 이를 큐에 추가합니다.
2.  `setNumber(n => n + 1)`: `n => n + 1`은 함수입니다. React는 이를 큐에 추가합니다.
3.  `setNumber(n => n + 1)`: `n => n + 1`은 함수입니다. React는 이를 큐에 추가합니다.

다음 렌더링 중에 useState를 호출할 때 React는 큐를 처리합니다. 이전 number 상태는 0이므로 첫 번째 업데이터 함수에 n 인수로 전달됩니다. 그런

 다음 React는 이전 업데이터 함수의 반환 값을 n으로 전달하고, 이 과정을 반복합니다.

| 큐에 대기 중인 업데이트 | n | 반환 값 |
| --- | --- | --- |
| n => n + 1 | 0 | 0 + 1 = 1 |
| n => n + 1 | 1 | 1 + 1 = 2 |
| n => n + 1 | 2 | 2 + 1 = 3 |

React는 최종 결과로 3을 저장하고 useState에서 반환합니다.

이것이 위의 예제에서 "3 추가"를 클릭하면 값이 정확히 3만큼 증가하는 이유입니다.

#### 상태를 대체한 후에 상태를 업데이트하는 경우

이벤트 핸들러에서 number를 업데이트하는 경우 다음 렌더링에서 number의 값이 어떻게 될지 생각해보세요.

```jsx
<button onClick={() => {
  setNumber(number + 5);
  setNumber(n => n + 1);
}}>
```

<iframe 
  src="https://codesandbox.io/embed/patient-shadow-xwehl7?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="patient-shadow-xwehl7"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


이벤트 핸들러가 하는 일은 다음과 같습니다.

1.  `setNumber(number + 5)`: number는 0이므로 `setNumber(0 + 5)`입니다. React는 "5로 대체"를 큐에 추가합니다.
2.  `setNumber(n => n + 1)`: `n => n + 1`은 업데이터 함수입니다. React는 이를 큐에 추가합니다.

다음 렌더링 중에 React는 상태 큐를 처리합니다.

| 큐에 대기 중인 업데이트 | n | 반환 값 |
| --- | --- | --- |
| "5로 대체" | 0 (사용하지 않음) | 5 |
| n => n + 1 | 5 | 5 + 1 = 6 |

React는 최종 결과로 6을 저장하고 useState에서 반환합니다.

> 참고 
`setState(5)`가 실제로 `setState(n => 5)`처럼 작동한다는 것을 알 수 있습니다. 하지만 여기서 n은 사용되지 않습니다!

#### 업데이트한 후에 상태를 대체하는 경우

하나 더 예제를 시도해보겠습니다. 다음 렌더링에서 number의 값은 어떻게 될까요?

```jsx
<button onClick={() => {
  setNumber(number + 5);
  setNumber(n => n + 1);
  setNumber(42);
}}>
```
<iframe 
  src="https://codesandbox.io/embed/musing-varahamihira-f420lm?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="musing-varahamihira-f420lm"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

이벤트 핸들러를 실행하는 동안 React가 이 코드를 처리하는 방식은 다음과 같습니다.

1.  `setNumber(number + 5)`: number는 0이므로 `setNumber(0 + 5)`입니다. React는 "5로 대체"를 큐에 추가합니다.
2.  `setNumber(n => n + 1)`: `n => n + 1`은 업데이터 함수입니다. React는 이를 큐에 추가합니다.
3.  `setNumber(42)`: React는 "42로 대체"를 큐에 추가합니다.

다음 렌더링 중에 React는 상태 큐를 처리합니다.

| 큐에 대기 중인 업데이트 | n | 반환 값 |
| --- | --- | --- |
| "5로 대체" | 0 (사용하지 않음) | 5 |
| n => n + 1 | 5 | 5 + 1 = 6 |
| "42로 대체" | 6 (사용하지 않음) | 42 |

그러면 React는 42를 최종 결과로 저장하고 useState에서 반환합니다.

요약하자면, setNumber 상태 setter에 전달하는 내용을 다음과 같이 생각할 수 있습니다.

- **업데이터 함수** (예: `n => n + 1`)는 큐에 추가됩니다.
- **다른 값** (예: number 5)은 "대체하기"를 큐에 추가하며, 이미 큐에 있는 내용을 무시합니다.

이벤트 핸들러가 완료되면 React가 재렌더링을 트리거합니다. 재렌더링 중에 React는 큐를 처리합니다. 업데이터 함수는 렌더링 중에 실행되므로 업데이터 함수는 [순수 함수](https://react.dev/learn/keeping-components-pure)이어야 하며 결과만 반환해야 합니다. 업데이터 함수 내부에서 상태를 설정하거나 다른 부작용을 실행하지 않도록 주의해야 합니다. Strict Mode에서는 React가 각 업데이터 함수를 두 번 실행하지만 (두 번째 결과는 버림), 실수를 찾는 데 도움이 됩니다.

#### 명명 규칙

일반적으로 업데이터 함수의 인수는 해당 상태 변수의 첫 글자를 사용하여 이름을 지정하는 것이 일반적입니다.

```jsx
setEnabled(e => !e);
setLastName(ln => ln.reverse());
setFriendCount(fc => fc * 2);
```

더 상세한 코드를 선호하는 경우 다른 일반적인 관례는 `setEnabled(enabled => !enabled)`와 같이 상태 변수 이름을 반복하거나, `setEnabled(prevEnabled => !prevEnabled)`와 같이 접두사를 사용하는 것입니다.

### 요약

- 상태를 설정하면 기존 렌더링 내의 변수가 변경되지 않지만 새로운 렌더링을 요청합니다.
- React는 이벤트 핸들러의 실행이 완료된 후에 상태 업데이트를 처리합니다. 이를 일괄 처리(batching)라고 합니다.
- 한 이벤트에서 여러 번 상태를 업데이트하려면 `setNumber(n => n + 1)`과 같은 업데이터 함수를 사용할 수 있습니다.



## 상태에서 객체 업데이트하기

상태(state)는 객체를 포함하여 모든 종류의 JavaScript 값을 저장할 수 있습니다. 그러나 React 상태에 있는 객체를 직접 변경해서는 안됩니다. 대신, 객체를 업데이트할 때는 새로운 객체를 생성하거나 기존 객체의 사본을 만들고, 그 사본을 상태로 설정해야 합니다.

다음 내용을 배우게 됩니다

- React 상태에서 객체를 올바르게 업데이트하는 방법
- 객체를 변경하지 않고 중첩된 객체를 업데이트하는 방법
- 불변성이란 무엇이며, 어떻게 깨지 않게 할 것인지
- Immer를 사용하여 객체 복사를 간소화하는 방법

### 무엇이 변이인가요?

상태에는 숫자, 문자열, 불리언과 같은 모든 종류의 JavaScript 값들을 저장할 수 있습니다.

```jsx
const [x, setX] = useState(0);
```

지금까지 숫자, 문자열, 불리언과 같은 값들을 다루었습니다. 이러한 종류의 JavaScript 값은 "불변"이라고 하며, 변경할 수 없거나 "읽기 전용"입니다. 값을 교체하기 위해 재렌더링을 트리거할 수 있습니다.

```jsx
setX(5);
```

x 상태가 0에서 5로 변경되었지만, 숫자 0 자체는 변경되지 않았습니다. JavaScript에서 기본 제공하는 원시값인 숫자, 문자열, 불리언과 같은 값들은 변경할 수 없습니다.

이제 객체를 생각해보세요.

```jsx
const [position, setPosition] = useState({ x: 0, y: 0 });
```

기술적으로 객체 자체의 내용을 변경하는 것은 가능합니다. **이를 "변이(mutation)"**이라고 합니다.

```jsx
position.x = 5;
```

그러나 React 상태에 있는 객체는 기술적으로 변경 가능하지만, 그들을 숫자, 불리언, 문자열과 같이 **읽기 전용인 것처럼 취급해야 합니다.** 객체를 변경하는 대신 항상 새로운 객체로 대체해야 합니다.

### 상태를 읽기 전용으로 취급하기

즉, 상태에 저장한 JavaScript 객체를 **읽기 전용으로 취급해야 합니다.**

이 예제는 현재 포인터 위치를 나타내기 위해 상태에 객체를 저장합니다. 레드 닷은 미리보기 영역에 터치하거나 커서를 이동시킬 때 움직이는 것이 목표입니다. 그러나 닷은 초기 위치에 그대로 있습니다.

<iframe 
  src="https://codesandbox.io/embed/proud-dawn-gwbwpr?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="proud-dawn-gwbwpr"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


문제는 다음 코드 부분에 있습니다.

```jsx
onPointerMove={e => {
  position.x = e.clientX;
  position.y = e.clientY;
}}
```

이 코드는 [이전 렌더링](https://react.dev/learn/state-as-a-snapshot#rendering-takes-a-snapshot-in-time)에서 position에 할당된 객체를 수정합니다. 그러나 상태 설정 함수를 사용하지 않고 객체를 변경하면 React는 해당 객체가 변경되었다는 사실을 알 수 없습니다. 따라서 React는 어떠한 변화도 일어나지 않습니다. 이미 식사를 한 후에 주문을 변경하려는 것과 같습니다. 상태를 변이시키는 것은 몇 가지 경우에 동작할 수 있지만 권장하지 않습니다. 렌더링 내에서 액세스할 수 있는 상태 값을 읽기 전용으로 취급해야 합니다.

이 경우 실제로 [재렌더링을 트리거](https://react.dev/learn/state-as-a-snapshot#setting-state-triggers-renders)하기 위해 **새로운 객체를 생성하고 해당 객체를 상태 설정 함수에 전달**해야 합니다.

```jsx
onPointerMove={e => {
  setPosition({
    x: e.clientX,
    y: e.clientY
  });
}}
```

setPosition을 사용하여 React에게 다음을 알립니다.

- position을 이 새로운 객체로 대체하고
- 이 컴포넌트를 다시 렌더링하라고 요청합니다.

이제 빨간 닷이 미리보기 영역에서 터치하거나 커서를 올리면 포인터를 따라 움직임을 확인할 수 있습니다.

<iframe 
  src="https://codesandbox.io/embed/epic-kalam-zyozg3?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="epic-kalam-zyozg3"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


<Callout>
**로컬 변이는 괜찮습니다.**

다음과 같은 코드는 상태 내에 있는 기존 객체를 수정하므로 문제가 됩니다.

```jsx
position.x = e.clientX;
position.y = e.clientY;
```

하지만 다음과 같은 코드는 새로 생성한 객체를 변이시키는 것이므로 **전혀 문제가 없습니다**.

```jsx
const nextPosition = {};
nextPosition.x = e.clientX;
nextPosition.y = e.clientY;
setPosition(nextPosition);
```

사실, 다음과 같이 작성한 것과 완전히 동일합니다.

```jsx
setPosition({
  x: e.clientX,
  y: e.clientY
});
```

변이는 이미 존재하는 상태 객체를 변경할 때만 문제가 됩니다. 방금 생성한 객체를 변이시키는 것은 다른 코드에서 이 객체를 참조하지 않았기 때문에 괜찮습니다. 이 객체에 변경사항이 적용되는 것이 이 객체에 의존하는 다른 부분에 영향을 미치지 않습니다. 이것을 "로컬 변이(local mutation)"라고 합니다. 실제로 렌더링 중에도 로컬 변이를 수행할 수 있습니다. 매우 편리하고 완전히 허용되는 방법입니다!
</Callout>

### 스프레드 구문을 사용하여 객체 복사하기

이전 예제에서 position 객체는 항상 현재 커서 위치에서 새로 생성됩니다. 그러나 종종 기존 데이터를 새로 생성하는 객체에 포함시키고 싶을 수 있습니다. 예를 들어, 하나의 필드만 업데이트하고 다른 모든 필드의 이전 값을 유지하고 싶을 수 있습니다.

이 입력 필드는 작동하지 않습니다. onChange 핸들러가 상태를 변이시킵니다.

<iframe 
  src="https://codesandbox.io/embed/peaceful-thunder-65nfcr?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="peaceful-thunder-65nfcr"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

예를 들어, 다음 코드는 이전 렌더링에서 상태를 변이시킵니다.

```jsx
person.firstName = e.target.value;
```

원하는 동작을 얻기 위해선 실제로 **새로운 객체를 생성하고 setPerson에 전달해야** 합니다. 그러나 여기서는 **기존 데이터를 복사**하여 새로운 객체에 포함시켜야 합니다. 왜냐하면 하나의 필드만 변경되었기 때문입니다.

```jsx
setPerson({
  firstName: e.target.value, // 입력 필드에서 새로운 이름
  lastName: person.lastName,
  email: person.email
});
```

`... `객체 펼침 구문을 사용하여 각 속성을 복사하지 않아도 됩니다.

```jsx
setPerson({
  ...person, // 기존 필드 복사
  firstName: e.target.value // 하지만 이 필드만 변경
});
```

이제 양식이 작동합니다!

각 입력 필드에 대해 별도의 상태 변수를 선언하지 않았음에 유의하세요. 대형 양식의 경우 모든 데이터를 객체에 그룹화하여 유지하는 것이 매우 편리합니다. 단지 올바르게 업데이트하기만 하면 됩니다!

<iframe 
  src="https://codesandbox.io/embed/goofy-ellis-j99jb6?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="goofy-ellis-j99jb6"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


`...` 스프레드 구문은 "얕은(shallow)" 복사입니다. 한 단계까지만 복사되지만 빠릅니다. 중첩된 속성을 업데이트하려면 스프레드 구문을 여러 번 사용해야 합니다.

<Callout>
**하나의 이벤트 핸들러로 여러 필드 업데이트하기**

`[` 와 `]` 중괄호를 사용하여 동적인 이름의 속성을 지정할 수도 있습니다. 다음은 세 개의 다른 이벤트 핸들러 대신 하나의 이벤트 핸들러를 사용한 동일한 예제입니다.

<iframe 
  src="https://codesandbox.io/embed/wizardly-drake-g2lnrt?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="wizardly-drake-g2lnrt"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


여기서 `e.target.name`은 `<input>` DOM 요소에 지정된 name 속성을 참조합니다.
</Callout>

### 중첩된 객체 업데이트하기

다음과 같은 중첩된 객체 구조를 고려해 보겠습니다.

```jsx
const [person, setPerson] = useState({
  name: 'Niki de Saint Phalle',
 

 artwork: {
    title: 'Blue Nana',
    city: 'Hamburg',
    image: 'https://i.imgur.com/Sd1AgUOm.jpg',
  }
});
```

person.artwork.city를 업데이트하려면 변이로 수행하는 방법이 명확합니다.

```jsx
person.artwork.city = 'New Delhi';
```

그러나 React에서는 상태를 불변으로 취급합니다! city를 변경하려면 먼저 이전 데이터를 포함한 새로운 artwork 객체를 생성한 다음, 새로운 artwork를 가리키는 새로운 person 객체를 생성해야 합니다.

```jsx
const nextArtwork = { ...person.artwork, city: 'New Delhi' };
const nextPerson = { ...person, artwork: nextArtwork };
setPerson(nextPerson);
```

또는, 단일 함수 호출로 작성된 경우:

```jsx
setPerson({
  ...person, // 기타 필드 복사
  artwork: { // 하지만 artwork를
    ...person.artwork, // 동일한 것으로 대체
    city: 'New Delhi' // 단지 New Delhi로!
  }
});
```

이렇게 조금 장황해질 수 있지만 대부분의 경우 잘 작동합니다.

<iframe 
  src="https://codesandbox.io/embed/cool-jasper-geo3mo?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="cool-jasper-geo3mo"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


<Callout>
**객체는 실제로 중첩되지 않습니다.**

다음과 같은 객체는 코드에서 "중첩"되어 있는 것처럼 보입니다.

```jsx
let obj = {
  name: 'Niki de Saint Phalle',
  artwork: {
    title: 'Blue Nana',
    city: 'Hamburg',
    image: 'https://i.imgur.com/Sd1AgUOm.jpg',
  }
};
```

그러나 "중첩"은 객체의 동작 방식을 잘못 이해한 것입니다. 코드가 실행될 때 "중첩"된 객체는 실제로 존재하지 않습니다. 다른 두 개의 다른 객체를 보고 있는 것입니다.

```jsx
let obj1 = {
  title: 'Blue Nana',
  city: 'Hamburg',
  image: 'https://i.imgur.com/Sd1AgUOm.jpg',
};

let obj2 = {
  name: 'Niki de Saint Phalle',
  artwork: obj1
};
```

obj1 객체는 obj2 객체 안에 "내부에 있는" 것이 아닙니다. 예를 들어, obj3도 obj1을 "가리킬" 수 있습니다.

```jsx
let obj1 = {
  title: 'Blue Nana',
  city: 'Hamburg',
  image: 'https://i.imgur.com/Sd1AgUOm.jpg',
};

let obj2 = {
  name: 'Niki de Saint Phalle',
  artwork: obj1
};

let obj3 = {
  name: 'Copycat',
  artwork: obj1
};
```

`obj3.artwork.city`를 변이시키면 `obj2.artwork.city`와 `obj1.city`에 영향을 미칩니다. 이는 `obj3.artwork`, `obj2.artwork`, `obj1`이 동일한 객체를 가리키기 때문입니다. 이것은 객체를 "중첩"되었다고 생각할 때 볼 수 없는 것입니다. 대신, 이들은 속성을 통해 서로를 "가리키는" 별개의 객체입니다.
</Callout>

#### Immer를 사용하여 간결한 업데이트 로직 작성하기

상태가 깊게 중첩되어 있는 경우, [평면화(flattening)](https://react.dev/learn/choosing-the-state-structure#avoid-deeply-nested-state)를 고려해볼 수 있습니다. 그러나 상태 구조를 변경하지 않고 원하는 경우 중첩된 스프레드를 위한 단축 방법을 선호할 수 있습니다. [Immer](https://github.com/immerjs/use-immer)는 편리하고 변이 문법을 사용하고 필요한 복사본을 생성하는 작업을 처리해주는 인기 있는 라이브러리입니다. Immer를 사용하면 작성하는 코드가 규칙을 어긴 것처럼 보이고 객체를 변이시키는 것처럼 보이지만, 이전 상태를 덮어쓰지 않습니다!

<Callout>
**Immer는 어떻게 동작하는가?**

Immer에서 제공하는 draft는 "기록"하는 특수한 종류의 객체입니다. draft를 자유롭게 변이시킬 수 있는 이유입니다! 내부적으로 Immer는 draft에서 변경된 부분을 찾아내고, 편집한 내용을 포함하는 완전히 새로운 객체를 생성합니다.
</Callout>

Immer를 사용해보려면 다음을 수행하세요:

1. `npm install use-immer`를 실행하여 의존성으로 Immer를 추가합니다.
2. 그런 다음 `import { useState } from 'react'`를 `import { useImmer } from 'use-immer'`로 바꿉니다.

다음은 위의 예제를 Immer로 변환한 것입니다:

<iframe 
  src="https://codesandbox.io/embed/vigilant-wood-vr01ks?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="vigilant-wood-vr01ks"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>



이벤트 핸들러가 훨씬 간결해진 것을 알 수 있습니다. useState와 useImmer를 원하는대로 혼합하여 단일 컴포넌트에서 사용할 수 있습니다. Immer는 상태의 중첩 여부와 객체 복사가 반복적으로 발생하는 경우 업데이트 핸들러를 간결하게 유지하는 훌륭한 방법입니다.

<Callout>
**React에서 상태를 변이시키지 않는 것이 권장되는 이유는 무엇인가요?**

다음과 같은 몇 가지 이유가 있습니다:

- **디버깅:** state를 변이시키지 않고 console.log를 사용하면 이전 로그가 최신 상태 변경으로 덮어씌워지지 않습니다. 따라서 렌더 사이에 상태가 어떻게 변경되었는지 명확하게 확인할 수 있습니다.
- **최적화:** React의 일반적인 [최적화 전략](https://react.dev/reference/react/memo)은 이전 props나 state가 다음과 동일한 경우 작업을 건너뛰는 것에 의존합니다. state를 변이시키지 않으면 변경 사항이 있는지 확인하는 작업이 매우 빠릅니다. prevObj === obj라면 내부에 변경된 내용이 없을 것입니다.
- **새로운 기능:** 우리가 개발 중인 새로운 React 기능은 상태가 [스냅샷으로 취급](https://react.dev/learn/state-as-a-snapshot)되도록 필요로 합니다. 과거 버전의 상태를 변이시키면 새로운 기능을 사용할 수 없을 수 있습니다.
- **요구 사항 변경:** 상태를 변이시키지 않는다면 실행 취소/다시 실행 구현, 변경 내용의 이력 표시, 양식을 이전 값으로 재설정하는 것과 같은 애플리케이션 기능을 쉽게 구현할 수 있습니다. 이는 메모리에 상태의 이전 사본을 유지하고, 적절한 경우 재사용할 수 있기 때문입니다. 변이적인 접근 방식으로 시작하면 이러한 기능을 나중에 추가하기가 어려울 수 있습니다.
- **구현이 간단해집니다:** React는 변이에 의존하지 않기 때문에 객체를 특별하게 처리할 필요가 없습니다. 속성을 빼앗거나 항상 프록시로 감싸거나 초기화 시 추가 작업을 할 필요가 없습니다. 이것은 React가 성능이나 정확성과 관련된 문제 없이 어떤 크기의 객체든 상태로 사용할 수 있는 이유입니다.

실제로 React에서 상태를 변이시키는 것은 종종 "먹히기는" 하지만, 이러한 접근 방식을 고려하여 개발된 새로운 React 기능을 사용할 수 있도록 강력히 권장하지 않습니다. 나중에 이에 대해 기여하게 될 다른 사람들, 아마도 미래의 자신조차도 이를 감사히 받을 것입니다!
</Callout>

### 요약

- React에서는 모든 상태를 불변으로 취급합니다.
- 객체를 상태에 저장할 때, 객체를 변이시키면 렌더링이 트리거되지 않고 이전 렌더링 "스냅샷"의 상태가 변경됩니다.
- 객체를 변이시키는 대신 새로운 버전의 객체를 생성하고 상태를 해당 객체로 설정하여 재렌더링을 트리거해야 합니다.
- `{...obj, something: 'newValue'}` 객체 스프레드 구문을 사용하여 객체의 사본을 생성할 수 있습니다.
- 스프레드 구문은 "얕은(shallow)" 복사이며, 한 단계까지만 복사됩니다.
- 중첩된 객체를 업데이트하려면 해당 위치에서부터 모든 사본을 생성해야 합니다.
- 반복적인 복사 코드를 줄이려면 Immer를 사용하세요.



## 상태에서 배열 업데이트하기



JavaScript에서 배열은 가변(mutable)이지만, React의 상태에 저장할 때는 불변(immutable)으로 취급해야 합니다. 객체와 마찬가지로, 상태에 저장된 배열을 업데이트할 때는 새로운 배열을 생성하고 상태를 새 배열로 설정해야 합니다.

배울 내용

- React 상태에서 배열에 아이템을 추가, 제거, 변경하는 방법
- 배열 내부의 객체를 업데이트하는 방법
- Immer를 사용하여 배열 복사를 더 간결하게 하는 방법

### 변이를 사용하지 않고 배열 업데이트하기

JavaScript에서 배열은 객체의 한 종류입니다. [객체와 마찬가지로](https://react.dev/learn/updating-objects-in-state), React 상태에서 배열은 읽기 전용으로 취급해야 합니다. 이는 `arr[0] = 'bird'`와 같이 배열의 항목을 재할당하거나, `push()`와 `pop()`과 같이 배열을 변이시키는 메서드를 사용해서는 안 된다는 의미입니다.

대신, 배열을 업데이트하고자 할 때마다 상태 설정 함수에 새 배열을 전달해야 합니다. 이를 위해 상태의 원래 배열에서 filter()와 map()과 같은 변이하지 않는 메서드를 호출하여 새 배열을 생성한 다음, 상태를 새 배열로 설정합니다.

다음은 일반적인 배열 작업에 대한 참조 표입니다. React 상태 내부에서 배열을 다룰 때, 왼쪽 열에 있는 메서드는 피하고, 오른쪽 열에 있는 메서드를 사용하는 것이 좋습니다:

|  | 피하기(배열을 변이시킴) | 선호하기(새 배열 반환) | 
| --- | --- | --- |
| 추가하기 | `push`, `unshift` | `concat`, `[...arr] `(스프레드 구문) ([예제](https://react.dev/learn/updating-arrays-in-state#adding-to-an-array)) |
| 제거하기 | `pop`, `shift`, `splice` | `filter`, `slice` (예제](https://react.dev/learn/updating-arrays-in-state#removing-from-an-array)) |
| 변경하기 | `splice, arr[i] = ...` 할당 | `map` (예제](https://react.dev/learn/updating-arrays-in-state#replacing-items-in-an-array)) |
| 정렬하기 | `reverse`, `sort` | 먼저 배열을 복사 ([예제](https://react.dev/learn/updating-arrays-in-state#making-other-changes-to-an-array)) |

또는 [Immer를 사용](https://react.dev/learn/updating-arrays-in-state#write-concise-update-logic-with-immer)할 수도 있습니다. 이는 양쪽 열의 메서드를 모두 사용할 수 있게 해줍니다.

<Callout type="warning">

유감스럽게도, [slice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)와 [splice](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice)는 이름은 비슷하지만 매우 다릅니다:

- slice는 배열 또는 배열의 일부를 복사합니다.
- splice는 배열을 변이시킵니다(아이템을 삽입하거나 삭제합니다).

React에서는 배열을 변이시키지 않으므로 slice(마지막 문자 'p'가 없음)를 훨씬 더 자주 사용하게 됩니다. [객체 업데이트하기](https://react.dev/learn/updating-objects-in-state)에서 변이(mutation)가 무엇이며 상태에 권장되지 않는 이유에 대해 설명합니다.
</Callout>


#### 배열에 추가하기

`push()`는 배열을 변이시키므로 사용하면 안됩니다:

<iframe 
  src="https://codesandbox.io/embed/nice-shannon-1vkb9e?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="nice-shannon-1vkb9e"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


대신, 기존 아이템과 새 아이템을 포함한 새 배열을 생성합니다. 이를 위해 여러 가지 방법이 있지만, 가장 간단한 방법은 ... [배열 스프레드 구문](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_array_literals)을 사용하는 것입니다:

```jsx
setArtists( // 상태를 바꿉니다
  [ // 새 배열로 대체합니다
    ...artists, // 기존 아이템을 포함한 새 배열
    { id: nextId++, name: name } // 새 아이템을 마지막에 추가합니다
  ]
);
```

이제 제대로 작동합니다:

<iframe 
  src="https://codesandbox.io/embed/elastic-tereshkova-m1jpw3?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="elastic-tereshkova-m1jpw3"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


배열 스프레드 구문은 `...artists`를 원래 배열 앞에 배치함으로써 아이템을 앞에 추가할 수도 있습니다:

```jsx
setArtists([
  { id: nextId++, name: name },
  ...artists // 기존 아이템을 뒤에 추가합니다
]);
```

이 방법으로 spread 구문은 배열의 끝에 추가하는 push()와 배열의 시작에 추가하는 unshift()의 역할을 할 수 있습니다. 위의 샌드박스에서 한 번 시도해보세요!

#### 배열에서 제거하기

배열에서 아이템을 제거하는 가장 쉬운 방법은 해당 아이템을 필터링하여 제외하는 것입니다. 즉, 해당 아이템을 포함하지 않은 새 배열을 생성합니다. 이를 위해 filter 메서드를 사용할 수 있습니다. 예를 들어:

<iframe 
  src="https://codesandbox.io/embed/exciting-dirac-2q2hmx?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="exciting-dirac-2q2hmx"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


"Delete" 버튼을 여러 번 클릭하고, 그 클릭 핸들러를 살펴보세요.

```jsx
setArtists(
  artists.filter(a => a.id !== artist.id)
);
```

여기서 `artists.filter(a => a.id !== artist.id)`는 "아티스트의 ID가 artist.id와 다른 아티스트로 구성된 배열을 생성한다"는 의미입니다. 즉, 각 아티스트의 "Delete" 버튼은 해당 아티스트를 배열에서 필터링하고, 결과 배열로 리렌더링을 요청합니다. filter는 원래 배열을 변경하지 않습니다.

#### 배열 변형하기

배열의 일부 또는 모든 아이템을 변경하고자 할 때는 `map()`을 사용하여 **새로운** 배열을 생성할 수 있습니다. map에 전달하는 함수는 데이터나 인덱스(또는 둘 모두)를 기반으로 각 아이템에 대해 수행할 작업을 결정할 수 있습니다.

이 예제에서는 배열이 두 개의 원과 한 개의 사각형의 좌표를 보유하고 있습니다. 버튼을 누를 때, 원만 아래로 50픽셀 이동합니다. 이를 위해 `map()`을 사용하여 데이터를 기반으로 새로운 배열을 생성합니다:

<iframe 
  src="https://codesandbox.io/embed/new-dew-crvphm?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="new-dew-crvphm"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


#### 배열에서 아이템 교체하기

일부 또는 모든 아이템을 교체하고자 하는 경우, 배열을 변이시키는 할당(`arr[0] = 'bird'`)과 같은 방식은 사용해서는 안 됩니다. 대신 map을 사용하여 교체할 수 있습니다.

아이템을 교체하기 위해, map과 함께 새 배열을 생성합니다. map 호출 내부에서 첫 번째 인수로 전달되는 아이템을 반환할지 또는 다른 것을 반환할지를 결정하기 위해 두 번째 인수로 아이템 인덱스를 사용합니다:

<iframe 
  src="https://codesandbox.io/embed/kind-architecture-5qhfff?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="kind-architecture-5qhfff"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


#### 배열에 삽입하기

때로는 시작이나 끝이 아닌 특정 위치에 아이템을 삽입하고 싶을 수 있습니다. 이를 위해 ... 배열 스프레드 구문과 slice() 메서드를 함께 사용할 수 있습니다. slice() 메서드는 배열을 "슬라이스"하여 자를 수 있습니다. 아이템을 삽입하기 위해, 삽입 지점 이전의 슬라이스, 그리고 새로운 아이템, 그리고 원래 배열의 나머지를 포함하는 배열을 생성합니다.

이 예제에서 "Insert" 버튼은 항상 인덱스 1에 삽입합니다:

<iframe 
  src="https://codesandbox.io/embed/infallible-rgb-z0pqn3?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="infallible-rgb-z0pqn3"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


#### 배열에 대한 기타 변경사항

배열을 뒤집거나 정렬하는 등 일부 작업은 스프레드 구문과 map() 및 filter() 같은 변이하지 않는 메서드만으로는 할 수 없는 작업입니다. JavaScript의 reverse()와 sort() 메서드는 원래 배열을 변이시키므로 직접 사용할 수 없습니다.

**하지만, 먼저 배열을 복사한 다음 변경을 가할 수 있습니다.**

예를 들어:

<iframe 
  src="https://codesandbox.io/embed/sharp-nobel-e3b91r?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="sharp-nobel-e3b91r"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


여기서는 `[...list]` 스프레드 구문을 사용하여 원래 배열의 사본을 생성합니다. 이제 사본을 사용하여 nextList.reverse() 또는 nextList.sort()와 같은 변이 메서드를 사용하거나, `nextList[0] = "something"`과 같이 개별 항목을 할당할 수 있습니다.

그러나 **배열을 복사하더라도 기존 항목을 직접 변이시킬 수는 없습니다.** 이는 복사가 얕은(shallow) 복사이기 때문입니다. 새 배열은 원래 배열과 동일한 항목을 포함합니다. 따라서 복사된 배열에서 객체를 수정하면 기존 상태를 변이시키는 것입니다. 예를 들어, 다음과 같은 코드는 문제가 됩니다.

```jsx
const nextList = [...list];
nextList[0].seen = true; // 문제: list[0]을 변이시킴
setList(nextList);
```

nextList와 list는 두 개의 다른 배열이지만, **nextList\[0\]과 list\[0\]은 동일한 객체를 가리킵니다.** 따라서 `nextList[0].seen`을 변경하면 `list[0].seen`도 변경됩니다. 이는 상태 변이이므로 피해야 합니다! 이 문제를 해결하기 위해 [중첩된 JavaScript 객체 업데이트](https://react.dev/learn/updating-objects-in-state#updating-a-nested-object)와 비슷한 방식으로 변경하려는 개별 항목을 복사하는 방법을 사용할 수 있습니다. 다음과 같습니다.

### 배열 내부의 객체 업데이트하기

객체는 실제로 배열 "내부"에 위치하지 않습니다. 코드에서는 배열 내부에 있는 것처럼 보일 수 있지만, 배열 내의 각 객체는 별개의 값으로 취급됩니다. 따라서 list\[0\]과 같은 중첩된 필드를 변경할 때 주의해야 합니다. 다른 사람의 작품 목록이 배열의 동일한 요소를 가리킬 수 있기 때문입니다!

**중첩된 상태를 업데이트할 때는 업데이트하려는 지점부터 최상위까지 복사본을 생성해야 합니다.** 이 작업이 어떻게 이루어지는지 살펴봅시다.

이 예제에서 두 개의 별도의 작품 목록이 동일한 초기 상태를 가지고 있습니다. 이들은 격리되어야 하지만 변이로 인해 상태가 실수로 공유되어 하나의 목록에서 체크박스를 선택하면 다른 목록에도 영향을 미칩니다:

<iframe 
  src="https://codesandbox.io/embed/trusting-wescoff-env1fs?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="trusting-wescoff-env1fs"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


문제는 다음과 같은 코드에 있습니다.

```jsx
const myNextList = [...myList];
const artwork = myNextList.find(a => a.id === artworkId);
artwork.seen = nextSeen; // 문제: 기존 항목을 변이시킴
setMyList(myNextList);
```

myNextList 배열 자체는 새로운 것이지만, 항목들은 원래 myList 배열과 동일합니다. 따라서 artwork.seen을 변경하면 원래 artwork 항목이 변경됩니다. 해당 artwork 항목은 또한 myList에 있으므로 버그가 발생합니다. 이러한 버그는 생각하기 어려울 수 있지만, 다행히도 상태 변이를 피하면 해결됩니다.

**map을 사용하여 이전 항목을 업데이트된 버전으로 대체할 수 있습니다.**

```jsx
setMyList(myList.map(artwork => {
  if (artwork.id === artworkId) {
    // 변경된 항목을 가진 *새로운* 객체를 생성합니다.
    return { ...artwork, seen: nextSeen };
  } else {
    // 변경 없음
    return artwork;
  }
}));
```

여기서 `...`은 객체 스프레드 구문을 사용하여 객체의 사본을 [생성하는](https://react.dev/learn/updating-objects-in-state#copying-objects-with-the-spread-syntax) 것입니다.

이 방법을 사용하면 기존 상태 항목을 변이시키지 않으며 버그가 수정됩니다:

<iframe 
  src="https://codesandbox.io/embed/competent-cohen-q21nk7?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="competent-cohen-q21nk7"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


일반적으로 **새로 생성한 객체만 변이시켜야 합니다.** 새로운 작품을 삽입하는 경우에는 변이할 수 있지만, 이미 상태에 있는 항목을 처리할 때는 사본을 만들어야 합니다.

#### Immer를 사용하여 간결한 업데이트 로직 작성하기

중첩된 배열을 변이하지 않고 업데이트하는 것은 조금 반복적일 수 있습니다. [객체와 마찬가지로](https://react.dev/learn/updating-objects-in-state#write-concise-update-logic-with-immer):

- 일반적으로 상태를 몇 단계까지 업데이트할 필요는 없습니다. 상태 객체가 매우 깊다면 [다른 방식으로 구조를 재조정](https://react.dev/learn/choosing-the-state-structure#avoid-deeply-nested-state)하여 평평하게 만드는 것이 좋습니다.
- 상태 구조를 변경하지 않으려면 편리하지만 변이 구문을 사용할 수 있는 [Immer](https://github.com/immerjs/use-immer)를 사용하는 것이 좋습니다. 이를 통해 변이 구문을 사용하여 코드를 작성하고, 복사본 생성을 Immer가 처리해줍니다.

다음은 Immer를 사용하여 다시 작성한 Art Bucket List 예제입니다:

<iframe 
  src="https://codesandbox.io/embed/beautiful-chaum-mfvh7f?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="beautiful-chaum-mfvh7f"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


Immer를 사용하면 `artwork.seen = nextSeen`과 같은 변이가 가능합니다:

```jsx
updateMyTodos(draft => {
  const artwork = draft.find(a => a.id === artworkId);
  artwork.seen = nextSeen;
});
```

이는 원래 상태를 변이시키지 않고, Immer가 제공하는 특수 draft 객체를 변이합니다. 마찬가지로 draft의 내용에 push()나 pop()과 같은 변이 메서드를 적용할 수도 있습니다.

내부적으로 Immer는 draft에 대한 변경 사항에 따라 항상 다음 상태를 새롭게 구성합니다. 이렇게 하면 상태 변이 없이 이벤트 핸들러를 매우 간결하게 유지할 수 있습니다.

### 요약

- 배열을 상태에 넣을 수 있지만, 변경해서는 안 됩니다.
- 배열을 변이하는 대신, 새로운 버전의 배열을 생성하고 상태를 해당 배열로 업데이트합니다.
- `[...arr, newItem]` 배열 스프레드 구문을 사용하여 새로운 항목이 있는 배열을 생성할 수 있습니다.
- `filter()`와 `map()`을 사용하여 필터링된 또는 변형된 항목이 있는 새로운 배열을 생성할 수 있습니다.
- 코드를 간결하게 유지하기 위해 Immer를 사용할 수 있습니다.
