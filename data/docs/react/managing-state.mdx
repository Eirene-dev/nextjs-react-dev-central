---
title: "상태 관리"
description: 이 튜토리얼에서는 작은 틱택토 게임을 만들어 볼 것입니다. 
---

애플리케이션이 커지면서 상태를 어떻게 구성하고 구성 요소 간에 데이터가 어떻게 흐르는지에 대해 의도적으로 고려하는 것이 도움이 됩니다. 중복된 상태는 버그의 일반적인 원인입니다. 이 장에서는 상태를 잘 구조화하는 방법, 상태 업데이트 로직을 유지보수하기 좋게 유지하는 방법, 그리고 먼 컴포넌트 간에 상태를 공유하는 방법을 배우게 됩니다.

이 장에서 배우는 내용

- UI 변경을 상태 변경으로 생각하는 방법
- 상태를 잘 구성하는 방법
- 상태를 "끌어올려" 컴포넌트 간에 공유하는 방법
- 상태의 보존 또는 초기화 여부를 제어하는 방법
- 복잡한 상태 로직을 함수로 통합하는 방법
- "속성 던지기" 없이 정보를 전달하는 방법
- 앱이 성장함에 따라 상태 관리의 확장

## 사용자 입력에 대한 상태 반응하기


React는 UI를 조작하는 선언적인 방법을 제공합니다. 직접 UI의 개별 요소를 조작하는 대신 컴포넌트가 취할 수 있는 다양한 상태를 설명하고, 사용자 입력에 대한 응답으로 상태 변경을 전환합니다. 이는 디자이너가 UI를 생각하는 방식과 유사합니다.

배울 내용

- 명령적인 UI 프로그래밍과 선언적인 UI 프로그래밍의 차이점
- 컴포넌트의 다양한 시각적 상태를 열거하는 방법
- 코드에서 다른 시각적 상태 사이의 변경을 트리거하는 방법

### 선언적인 UI와 명령적인 UI의 비교

UI 상호작용을 설계할 때는 사용자 동작에 따라 UI가 어떻게 변경되는지 고려할 것입니다. 사용자가 답변을 제출할 수 있는 양식을 생각해보세요.

- 양식에 입력을 입력하면 "제출" 버튼은 **활성화됩니다**.
- "제출"을 클릭하면 양식과 버튼은 **비활성화되고**, 대신 스피너가 **표시됩니다**.
- 네트워크 요청이 성공하면 양식은 **숨겨지고**, "감사합니다" 메시지가 **표시됩니다**.
- 네트워크 요청이 실패하면 **에러 메시지**가 표시되며, 양식은 다시 **활성화됩니다**.

**명령적 프로그래밍**에서는 위와 같은 내용을 상호작용을 구현하는 방식으로 직접 조작합니다. 발생한 사건에 따라 UI를 조작하는 정확한 명령을 작성해야 합니다. 예를 들어, 차 안에서 옆 사람에게 차례로 회전 방향을 알려주는 것과 유사합니다.

상태를 업데이트하는 코드만 작성하면 되며, 스피너에서 버튼까지 각 요소를 "명령"하여 컴퓨터에게 UI를 업데이트하는 방법을 알려줍니다.

명령적인 UI 프로그래밍 예제에서는 React를 사용하지 않고, 브라우저 [DOM](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model)만 사용하여 양식을 구축합니다:

<iframe 
  src="https://codesandbox.io/embed/practical-kepler-wh03mi?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="practical-kepler-wh03mi"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


명령적인 방식으로 UI를 조작하는 것은 독립된 예제에서는 잘 작동하지만, 더 복잡한 시스템에서는 관리하기가 기하급수적으로 어려워집니다. 이와 같은 양식이 포함된 페이지를 업데이트해야 한다면 어려움을 겪을 수 있습니다. 새로운 UI 요소나 상호작용을 추가하려면 기존의 모든 코드를 주의 깊게 확인하여 버그가 없는지 확인해야 합니다(예: 누락된 표시 또는 숨김).

React는 이러한 문제를 해결하기 위해 만들어졌습니다.

React에서는 UI를 직접 조작하지 않습니다. 즉, 컴포넌트를 활성화, 비활성화, 표시 또는 숨김하는 등의 작업을 직접 수행하지 않습니다. 대신 **표시할 UI를 설명**하고, React가 UI를 업데이트하는 방법을 결정합니다. 차에 타고 가서 목적지를 명확하게 알려주는 대신 어디로 가고 싶은지 말해주는 것입니다. 운전자의 역할은 목적지에 도달하는 것이며, 그들은 고려하지 못한 일부 지름길을 알 수도 있습니다!

### 선언적인 UI에 대해 생각하기

위에서 명령적인 방식으로 양식을 구현하는 방법을 살펴보았습니다. React로 생각하는 방법을 이해하기 위해 아래에서 React로 이 UI를 다시 구현해보겠습니다.

1. **컴포넌트의 다른 시각적 상태**를 확인합니다.
2. **어떤 입력에 의해 상태 변경이 트리거되는지** 확인합니다.
3. **useState**를 사용하여 상태를 메모리에 표현합니다.

#### 단계 1: 컴포넌트의 다른 시각적 상태 확인

컴퓨터 과학에서 "상태 기계"가 여러 "상태" 중 하나에 있는 것을 들어본 적이 있을 것입니다. 디자이너와 함께 일하는 경우 다른 "시각적 상태"에 대한 모킹(mocking)을 볼 수 있을 것입니다. React는 디자인과 컴퓨터 과학의 교차점에 위치하기 때문에 두 가지 아이디어 모두 영감의 원천입니다.

먼저 사용자가 볼 수 있는 UI의 다양한 "상태"를 시각화해야 합니다.

- **Empty**: 양식에 비활성화된 "제출" 버튼이 있습니다.
- **Typing**: 양식에 활성화된 "제출" 버튼이 있습니다.
- **Submitting**: 양식이 완전히 비활성화되었고, 스피너가 표시됩니다.
- **Success**: 양식 대신 "감사합니다" 메시지가 표시됩니다.
- **Error**: 추가로 에러 메시지가 있는 Typing 상태와 동일합니다.

디자이너처럼 UI의 다른 상태에 대한 "모킹" 또는 "모형"을 만들어 로직을 추가하기 전에 빠르게 UI를 반복해볼 수 있습니다. 예를 들어, 여기는 양식의 시각적 부분에 대한 모킹입니다. 이 모킹은 'status'라는 기본값이 'empty'인 속성에 의해 제어됩니다.

<iframe 
  src="https://codesandbox.io/embed/wild-water-ewr4uj?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="wild-water-ewr4uj"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


속성의 이름은 중요하지 않습니다. `status = 'empty'`를 `status = 'success'`로 편집하여 성공 메시지가 나타나는지 확인해보세요. 모킹을 통해 로직을 연결하기 전에 UI를 빠르게 반복할 수 있습니다. 여기에 더 구체적인 프로토 타입이 있습니다. 여전히 'status' prop에 의해 "제어"됩니다.

<iframe 
  src="https://codesandbox.io/embed/determined-jones-pmnojw?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="determined-jones-pmnojw"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


<Callout>
**여러 시각적 상태를 동시에 표시하기**

컴포넌트에 많은 시각적 상태가 있는 경우 모든 상태를 한 페이지에 표시하는 것이 편리할 수 있습니다.

<iframe 
  src="https://codesandbox.io/embed/peaceful-leaf-f0p7sj?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="peaceful-leaf-f0p7sj"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

이와 같은 페이지는 종종 "리빙 스타일 가이드" 또는 "스토리북"이라고 불립니다.
</Callout>

#### 단계 2: 상태 변경을 트리거하는 입력 확인

두 종류의 입력에 응답하여 상태 업데이트를 트리거할 수 있습니다.

- **사용자 입력**: 버튼 클릭, 필드 입력, 링크 탐색과 같은 작업입니다.
- **컴퓨터 입력**: 네트워크 응답 도착, 타임아웃 완료, 이미지 로딩과 같은 작업입니다.

두 경우 모두 **상태 변수를 설정하여 UI를 업데이트해야 합니다**. 개발 중인 양식에서는 다음과 같은 몇 가지 다른 입력에 응답하여 상태를 변경해야 합니다.

- **텍스트 입력 변경**(사용자 입력)은 상자가 비어 있는지 여부에 따라 Empty 상태에서 Typing 상태로 전환하거나 그 반대로 전환해야 합니다.
- **제출 버튼 클릭**(사용자 입력)은 Submitting 상태로 전환해야 합니다.
- **네트워크 응답 성공**(컴퓨터 입력)은 Success 상태로 전환해야 합니다.
- **네트워크 응답 실패**(컴퓨터 입력)는 Error 상태와 해당하는 에러 메시지로 전환해야 합니다.

> 참고  
사용자 입력은 종종 [이벤트 핸들러](https://react.dev/learn/responding-to-events)가 필요합니다!

이 흐름을 시각화하기 위해 각 상태를 레이블이 지정된 원으로 종이에 그리고 두 상태 사이의 각 변경을 화살표로 그릴 수 있습니다. 이렇게 여러 흐름을 스케치하고 구현 이전에 버그를 해결할 수 있습니다.

![](https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fresponding_to_input_flow.png&w=750&q=75)  
양식 상태

#### 단계 3: useState를 사용하여 상태를 메모리에 표현

이제 컴포넌트의 시각적 상태를 [useState](https://react.dev/reference/react/useState)를 사용하여 메모리에 표현해야 합니다. 간단함이 가장 중요합니다. 각각의 상태는 "움직이는 부분"이며, **"움직이는 부분"을 최소화**해야 합니다. 복잡성이 증가하면 버그가 더 많이 발생합니다!

먼저 반드시 필요한 상태를 저장해야 합니다. 예를 들어, 입력에 대한 답변과 오류(있을 경우)를 저장해야 합니다.

```jsx
const [answer, setAnswer] = useState('');
const [error, setError] = useState(null);
```

그런 다음 표시할 시각적 상태 중 하나를 나타내는 상태 변수가 필요합니다. 일반적으로 이를 메모리에 표현하는 방법은 여러 가지입니다. 따라서 여러 가지 방법을 실험해봐야 합니다.

최선의 방법을 즉시 생각하는 것이 어렵다면 가능한 시각적 상태를 모두 포함하는 상태가 있는지 확실히 확인할 수 있을 정도의 상태를 추가로 추가해보세요.

```jsx
const [isEmpty, setIsEmpty] = useState(true);
const [isTyping, setIsTyping] = useState(false);
const [isSubmitting, setIsSubmitting] = useState(false);
const [isSuccess, setIsSuccess] = useState(false);
const [isError, setIsError] = useState(false);
```

처음 생각한 방법이 최선의 방법이 아닐 수 있지만 괜찮습니다. 상태를 리팩토링하는 것은 과정의 일부입니다!

#### 단계 4: 필요하지 않은 상태 변수 제거

상태 내용에서 중복을 피하려면 핵심적인 것만 추적하여 필요한 상태만 저장하도록 해야 합니다. 상태 구조를 리팩토링하는 시간을 투자하면 컴포넌트를 이해하기 쉽게 만들 수 있으며, 중복을 줄이고 의도하지 않은 의미를 방지할 수 있습니다. 목표는 **메모리에 있는 상태가 사용자가 보기를 원하는 유효한 UI를 나타내지 않는 경우를 방지**하는 것입니다(예: 에러 메시지를 표시하고 입력을 비활성화하면 사용자가 오류를 수정할 수 없게 됩니다!).

다음은 상태 변수에 대해 물어볼 수 있는 몇 가지 질문입니다.

- **이 상태는 모순을 일으키는가요?** 예를 들어, isTyping과 isSubmitting은 둘 다 true일 수 없습니다. 모순은 상태가 충분히 제한되지 않은 것을 의미합니다. 두 개의 부울 값에 대한 네 가지 가능한 조합이 있지만, 유효한 상태는 세 가지뿐입니다. "불가능한" 상태를 제거하기 위해 이들을 typing, submitting 또는 success 중 하나인 status로 결합할 수 있습니다.
- **동일한 정보를 이미 다른 상태 변수에서 사용할 수 있나요?** 또 다른 모순: isEmpty와 isTyping은 동시에 true일 수 없습니다. 이들을 별도의 상태 변수로 만들면 동기화 문제가 발생하여 버그가 발생할 수 있습니다. 다행히 isEmpty를 제거하고 `answer.length === 0`을 확인할 수 있습니다.
- **다른 상태 변수의 반대에서 동일한 정보를 얻을 수 있나요?** `isError`는 `error !== null`을 확인하는 대신에는 필요하지 않습니다.

이 정리 작업 이후에는 7개에서 3개의 (감소된) 필수 상태 변수가 남게 됩니다.

```jsx
const [answer, setAnswer] = useState('');
const [error, setError] = useState(null);
const [status, setStatus] = useState('typing'); // 'typing', 'submitting', 또는 'success'
```

#### 단계 5: 이벤트 핸들러를 연결하여 상태 설정

마지막으로 상태를 업데이트하는 이벤트 핸들러를 만듭니다. 아래에는 모든 이벤트 핸들러가 연결된 최종 양식이 있습니다.

<iframe 
  src="https://codesandbox.io/embed/gallant-sun-vpttuv?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="gallant-sun-vpttuv"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


이 코드는 초기 명령적인 예제보다 길지만 훨씬 견고합니다. 모든 상호작용을 상태 변경으로 표현하면 새로운 시각적 상태를 손쉽게 추가할 수 있고, 기존 상태를 깨뜨리지 않고 각 상태에 표시할 내용을 변경할 수 있습니다.

### 요약

- 선언적 프로그래밍은 UI의 각 시각적 상태를 설명하므로 UI를 세밀하게 관리(명령적인)하는 것과 다릅니다.
- 컴포넌트를 개발할 때:
  1. 시각적 상태를 모두 식별합니다.
  2. 상태 변경을 위한 사용자 및 컴퓨터 트리거를 결정합니다.
  3. `useState`를 사용하여 상태를 모델링합니다.
  4. 버그와 모순을 피하기 위해 비필수 상태를 제거합니다.
  5. 이벤트 핸들러를 연결하여 상태를 설정합니다.



## 상태 구조 선택하기


상태를 잘 구조화하는 것은 수정 및 디버깅이 쉬운 컴포넌트와 버그가 계속 발생하는 컴포넌트 간의 차이를 만들어 줄 수 있습니다. 상태를 구조화할 때 고려해야 할 몇 가지 팁이 있습니다.

배울 내용

- 단일 상태 변수와 여러 상태 변수를 사용할 때의 선택 시기
- 상태를 구성할 때 피해야 할 사항
- 상태 구조의 일반적인 문제를 해결하는 방법

### 상태를 구조화하기 위한 원칙

일부 상태를 보유한 컴포넌트를 작성할 때, 얼마나 많은 상태 변수를 사용하고 그 데이터의 형태는 무엇이어야 하는지에 대한 선택을 해야 합니다. 최적이 아닌 상태 구조로도 올바른 프로그램을 작성할 수는 있지만, 몇 가지 원칙을 따르면 더 나은 선택을 할 수 있습니다.

1. **관련된 상태를 그룹화합니다.** 항상 두 개 이상의 상태 변수를 동시에 업데이트하는 경우, 이들을 하나의 상태 변수로 통합하는 것을 고려해 보세요.
2. **상태에서 모순을 피합니다.** 상태가 서로 모순되고 서로 "일치하지 않는" 여러 상태를 가질 수 있는 방식으로 구조화되어 있다면, 실수할 여지를 남기게 됩니다. 이를 피하기 위해 노력해야 합니다.
3. **중복 상태를 피합니다.** 구성 요소의 props나 기존 상태 변수에서 렌더링 중에 일부 정보를 계산할 수 있다면, 해당 정보를 구성 요소의 상태로 넣지 않아야 합니다.
4. **상태에서 중복을 피합니다.** 동일한 데이터가 여러 상태 변수나 중첩된 객체 내에 중복되어 있는 경우, 이들을 동기화하는 것이 어렵습니다. 가능한 경우 중복을 줄이세요.
5. **깊게 중첩된 상태를 피합니다.** 깊게 중첩된 계층 구조의 상태는 업데이트하기 편리하지 않습니다. 가능한 경우 상태를 평평하게 구조화하는 것이 좋습니다.

이러한 원칙의 목표는 실수를 최소화하면서 상태를 쉽게 업데이트하는 것입니다. 중복된 데이터와 중복을 제거하여 상태의 모든 부분이 동기화되도록하는 것입니다. 이는 데이터베이스 엔지니어가 버그의 가능성을 줄이기 위해 데이터베이스 구조를 "정규화"하려는 방식과 유사합니다. Albert Einstein의 말을 para하면 **"상태를 가능한 한 단순하게 만들지만 그 이상으로 단순하게 만들지는 마십시오."**

이제 이러한 원칙이 어떻게 적용되는지 살펴보겠습니다.

### 관련된 상태 그룹화하기

가끔씩 단일 상태 변수를 사용할지 여러 개의 상태 변수를 사용할지 확신이 서지 않을 수 있습니다.

다음과 같이 해야 할까요?

```javascript
const [x, setX] = useState(0);
const [y, setY] = useState(0);
```

아니면 이렇게 할까요?

```javascript
const [position, setPosition] = useState({ x: 0, y: 0 });
```

원칙적으로 이러한 접근 방식을 모두 사용할 수 있습니다. 그러나 **두 개 이상의 상태 변수가 항상 함께 변경된다면, 이들을 하나의 상태 변수로 통합하는 것이 좋습니다.** 그러면 항상 동기화를 유지하는 것을 잊지 않을 것입니다. 이 예제에서는 커서를 이동하면 빨간 점의 좌표를 모두 업데이트하는 것과 같습니다.

사용자가 커서를 움직이면 좌표의 두 가지 값을 모두 업데이트해야 하는 상황이라면 이렇게 그룹화하는 것이 좋습니다.

<iframe 
  src="https://codesandbox.io/embed/mutable-moon-k3wul4?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="mutable-moon-k3wul4"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


또 다른 경우로는 사용자가 사용자 정의 필드를 추가할 수 있는 폼이 있는 경우입니다.

<Callout type="warning">
**주의하기**

상태 변수가 객체인 경우, 다른 필드를 명시적으로 복사하지 않고는 하나의 필드만 업데이트할 수 없다는 점을 기억하십시오. 예를 들어, 위의 예제에서 `setPosition({ x: 100 })`를 수행할 수 없습니다. 왜냐하면 y 속성은 아예 없기 때문입니다! 대신 x만 설정하려면 `setPosition({ ...position, x: 100 })`와 같이 하거나, 두 개의 상태 변수로 분할하고 `setX(100)`을 수행해야 합니다.
</Callout>

### 모순을 피하기

다음은 isSending과 isSent 상태 변수를 사용한 호텔 피드백 폼의 예입니다.

<iframe 
  src="https://codesandbox.io/embed/serene-mclaren-7qx53i?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="serene-mclaren-7qx53i"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


이 코드는 작동하지만 "불가능한" 상태의 가능성을 남겨둡니다. 예를 들어, setIsSent와 setIsSending을 동시에 호출하는 것을 잊어버리면 isSending과 isSent가 동시에 true인 상태가 될 수 있습니다. 컴포넌트가 복잡해질수록 어떤 일이 발생했는지 이해하기가 더 어려워집니다.

**isSending과 isSent는 절대로 동시에 true가 되지 않아야 하므로, 이들을 하나의 상태 변수인 status로 대체하는 것이 좋습니다.** status는 'typing' (초기값), 'sending', 'sent'와 같은 세 가지 유효한 상태 중 하나를 가질 수 있습니다.

<iframe 
  src="https://codesandbox.io/embed/restless-sound-2t7gxo?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="restless-sound-2t7gxo"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


가독성을 위해 몇 가지 상수를 선언할 수 있습니다.

```javascript
const isSending = status === 'sending';
const isSent = status === 'sent';
```

하지만 이들은 상태 변수가 아니므로 서로 동기화되지 않을 걱정할 필요가 없습니다.

### 중복 상태 피하기

이 폼은 firstName, lastName 및 fullName 세 가지 상태 변수를 가지고 있습니다. 그러나 fullName은 중복입니다. **firstName과 lastName을 렌더링 중에 항상 fullName으로 계산할 수 있으므로, fullName을 상태에서 제거하세요.**

<iframe 
  src="https://codesandbox.io/embed/musing-silence-dnvs2u?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="musing-silence-dnvs2u"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


이렇게 할 수 있습니다.

<iframe 
  src="https://codesandbox.io/embed/amazing-lena-sc71ts?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="amazing-lena-sc71ts"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


여기에서 fullName은 상태 변수가 아닙니다. 대신 렌더링 중에 계산됩니다.

```javascript
const fullName = firstName + ' ' + lastName;
```

결과적으로 변경 핸들러는 fullName을 업데이트하기 위해 특별한 작업을 수행할 필요가 없습니다. setFirstName 또는 setLastName을 호출하면 다시 렌더링이 트리거되고, 다음 fullName은 새로운 데이터를 기반으로 계산됩니다.

<Callout>
**상태에 props 복제하지 않기**

상태에 복제하는 일반적인 예는 다음과 같은 코드입니다.

```javascript
function Message({ messageColor }) {
  const [color, setColor] = useState(messageColor);
```

여기서 color 상태 변수는 messageColor props로 초기화됩니다. 문제는, **부모 컴포넌트가 나중에 messageColor의 다른 값을 전달하는 경우(예: 'blue' 대신 'red'), color 상태 변수는 업데이트되지 않습니다!** 상태는 첫 번째 렌더링 시에만 초기화됩니다.

이렇게 props을 상태 변수에 "복제"하는 것은 혼란을 야기할 수 있습니다. 대신 코드에서 messageColor props을 직접 사용하세요. 이름을 더 짧게 지정하려면 상수를 사용하세요.

```javascript
function Message({ messageColor }) {
  const color = messageColor;
```

이렇게 하면 부모 컴포넌트에서 전달된 props과 동기화되지 않습니다.

props를 상태에 "복제"하는 것은 특정 props의 모든 업데이트를 무시하려는 경우에만 의미가 있습니다. 관례적으로 이러한 케이스의 prop 이름은 initial이나 default로 시작하여 새로운 값이 무시됨을 명확히 합니다.

```javascript
function Message({ initialColor }) {
  // `color` 상태 변수는 `initialColor`의 *첫 번째* 값을 보유합니다.
  // `initialColor` prop의 후속 변경은 무시됩니다.
  const [color, setColor] = useState(initialColor);
```
</Callout>


### 중복 상태 피하기

이 메뉴 목록 컴포넌트는 여러 가지 옵션 중 하나를 선택할 수 있습니다.

<iframe 
  src="https://codesandbox.io/embed/nice-mclean-0m3ydb?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="nice-mclean-0m3ydb"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


현재 선택한 항목을 selectedItem 상태 변수에 객체로 저장합니다. 그러나 이는 좋지 않습니다: **selectedItem의 내용은 items 목록 내의 항목과 동일한 객체입니다.** 이는 항목 자체에 대한 정보가 두 곳에서 중복됨을 의미합니다.

이것이 문제인 이유를 알아봅시다. 각 항목을 편집할 수 있도록 해 보겠습니다.

<iframe 
  src="https://codesandbox.io/embed/boring-wu-769ixj?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="boring-wu-769ixj"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>



"Choose"를 먼저 클릭한 다음에 편집하면, **입력은 업데이트되지만 하단에 있는 레이블은 편집 사항을 반영하지 않습니다.** 이는 상태의 중복으로 인해 발생하며, selectedItem을 업데이트하는 것을 잊었습니다.

selectedItem도 업데이트할 수 있지만, 더 쉬운 해결책은 중복을 제거하는 것입니다. 이 예제에서는 items 목록 내의 객체와 중복을 일으키는 대신 상태로 선택된 ID를 유지하고, 해당 ID와 일치하는 항목을 items 배열에서 검색하여 selectedItem을 가져옵니다. (또는 상태로 선택한 인덱스를 유지할 수도 있습니다.)

<iframe 
  src="https://codesandbox.io/embed/tender-frog-ubzyo9?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="tender-frog-ubzyo9"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


상태가 이렇게 중복되었던 예제는 다음과 같이 변경되었습니다.

-   `items = [{ id: 0, title: 'pretzels'}, ...]`
-   `selectedItem = {id: 0, title: 'pretzels'}`

하지만 변경 후에는 다음과 같이 되었습니다.

-   `items = [{ id: 0, title: 'pretzels'}, ...]`
-   `selectedId = 0`

중복이 제거되었고, 필수적인 상태만 유지되었습니다!

이제 선택한 항목을 편집하면 아래의 메시지가 즉시 업데이트됩니다. setItems는 다시 렌더링을 트리거하고, items.find(...)는 업데이트된 제목을 가진 항목을 찾을 것입니다. 상태를 유지할 필요가 없기 때문에 선택한 항목을 상태에 저장하지 않았습니다. 필수적인 것은 선택한 ID뿐이었고, 나머지는 렌더링 중에 계산될 수 있었습니다.

### 깊게 중첩된 상태 피하기

행성, 대륙 및 국가로 구성된 여행 계획을 상태로 구조화하려고 할 수 있습니다. 이 예제와 같이 중첩된 객체와 배열을 사용하여 상태를 구조화하려고 할 수 있습니다.
<iframe 
  src="https://codesandbox.io/embed/admiring-dijkstra-1pun7l?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="admiring-dijkstra-1pun7l"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

이제 방문한 장소를 삭제하는 버튼을 추가하려고 합니다. 어떻게 해야 할까요? [중첩된 상태 업데이트](https://react.dev/learn/updating-objects-in-state#updating-a-nested-object)는 변경된 부분에서부터 상위 부분까지 객체를 복사하는 것을 의미합니다. 깊게 중첩된 장소를 삭제하는 경우, 해당 장소의 전체 부모 장소 체인을 복사해야 합니다. 이러한 코드는 매우 번거로울 수 있습니다.

**상태가 너무 깊게 중첩되어 업데이트하기 어려운 경우, "평평하게" 만드는 것을 고려하세요.** 이 데이터를 다시 구조화하는 방법을 살펴보겠습니다. 각 장소가 자식 장소의 배열을 보유하는 트리와 같은 구조 대신, 각 장소가 자식 장소 ID의 배열을 보유하도록 변경하고, 각 장소 ID에 해당하는 장소와의 매핑을 저장합니다.

이 데이터 구조화는 데이터베이스 테이블을 보는 것과 유사합니다:
<iframe 
  src="https://codesandbox.io/embed/beautiful-solomon-pz7l98?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="beautiful-solomon-pz7l98"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

**이제 상태가 "평평"해졌습니다(또는 "정규화"되었습니다).** 중첩된 항목을 삭제하려면 두 수준의 상태를 업데이트하는 것만으로 충분합니다.

-   업데이트된 "부모" 장소 버전은 삭제된 ID를 자식 ID 배열에서 제외해야 합니다.
-   업데이트된 루트 "테이블" 객체 버전에는 업데이트된 부모 장소 버전이 포함되어야 합니다.

이렇게 할 수 있습니다.
<iframe 
  src="https://codesandbox.io/embed/clever-parm-x9kuzx?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="clever-parm-x9kuzx"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

원하는 대로 상태를 중첩시킬 수 있지만, "평평"하게 만들면 많은 문제를 해결할 수 있습니다. 상태를 쉽게 업데이트할 수 있게 되며, 중첩된 객체의 서로 다른 부분에서 중복을 가질 수 없도록 보장됩니다.

<Callout>
**메모리 사용량 향상**

이상적으로는 삭제된 항목(및 해당 하위 항목!)을 "테이블" 객체에서 제거하여 메모리 사용량을 개선해야 합니다. 이 버전은 그렇게 합니다. 또한 업데이트 로직을 더 간결하게 작성하기 위해 [Immer](https://react.dev/learn/updating-objects-in-state#write-concise-update-logic-with-immer)를 사용합니다.

<iframe 
  src="https://codesandbox.io/embed/quizzical-noyce-zim79i?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="quizzical-noyce-zim79i"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


때로는 일부 중첩된 상태를 자식 컴포넌트로 이동하여 상태의 중첩을 줄일 수도 있습니다. 이는 저장할 필요가 없는 일시적인 UI 상태에 대해 잘 작동합니다(예: 항목이 호버되었는지 여부 등).
</Callout>

### 요약

- 두 상태 변수가 항상 함께 업데이트된다면, 하나로 통합하는 것을 고려하세요.
- "불가능한" 상태를 만들지 않도록 주의하여 상태 변수를 선택하세요.
- 상태를 업데이트하는 데 실수를 줄이기 위해 상태를 구조화하세요.
- 중복과 중복 상태를 피하여 동기화해야 하는 상태를 최소화하세요.
- 특별한 경우가 아니라면 props을 상태로 넣지 마세요.
- 선택과 같은 UI 패턴의 경우 객체 자체 대신 ID나 인덱스를 상태로 유지하세요.
- 깊게 중첩된 상태를 업데이트하는 것이 복잡하다면, 평평하게 만들어 보세요.




## 컴포넌트 간에 상태 공유하기


때로는 두 컴포넌트의 상태가 항상 함께 변경되기를 원할 때가 있습니다. 이를 위해 두 컴포넌트에서 상태를 제거하고, 가장 가까운 공통 부모 컴포넌트로 이동시킨 다음, props를 통해 컴포넌트에 전달합니다. 이것을 상태를 "위로 올리는" 것이라고 하며, React 코드를 작성할 때 가장 흔한 작업 중 하나입니다.

배울 내용

- 상태를 "위로 올려서" 컴포넌트 간에 공유하는 방법
- 제어 컴포넌트와 비제어 컴포넌트에 대해 알아봅니다.

### 예시를 통한 상태를 위로 올리기

이 예시에서 부모인 Accordion 컴포넌트는 두 개의 별도 패널을 Panel합니다:

- Accordion
  - Panel
  - Panel

각 Panel 컴포넌트는 콘텐츠가 표시되는지 여부를 결정하는 isActive라는 부울 상태를 가지고 있습니다.

각 패널의 "Show" 버튼을 눌러보세요:

<iframe 
  src="https://codesandbox.io/embed/beautiful-fire-9edh28?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="beautiful-fire-9edh28"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


한 패널의 버튼을 눌렀을 때 다른 패널에는 영향을 주지 않는 것을 알 수 있습니다. 패널은 독립적입니다.

<div style={{ textAlign: 'center' }}>
  <table style={{ borderCollapse: 'collapse', border: 'none' }}>
    <tbody>
      <tr>
        <td style={{ border: 'none', padding: 20 }}>
          <img src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fsharing_state_child.png&w=640&q=75" alt="React Sharing Data" width={320} />
          <p style={{ margin: 0 }}>처음에는 각 Panel의 isActive 상태가 false이므로, 두 패널 모두 축소된 상태로 나타납니다.</p>
        </td>
        <td style={{ border: 'none', padding: 20 }}>
          <img src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fsharing_state_child_clicked.png&w=640&q=75" alt="React Sharing Data" width={320} />
          <p style={{ margin: 0 }}>Panel 버튼을 클릭하면 해당 Panel의 isActive 상태만 업데이트됩니다. 다른 Panel의 isActive 상태는 변경되지 않습니다.</p>
        </td>
      </tr>
    </tbody>
  </table>
</div>


**하지만 이제 한 번에 하나의 패널만 확장되도록 변경하고 싶다고 가정해 봅시다.** 이 디자인에서는 두 번째 패널을 확장하면 첫 번째 패널이 축소되어야 합니다. 이를 어떻게 해야 할까요?

이러한 두 패널을 조율하기 위해 상태를 "위로 올려" 공통 부모 컴포넌트로 이동해야 합니다. 이를 위해 다음 세 단계를 따릅니다:

1. **자식 컴포넌트에서 상태를 제거**합니다.
2. **공통 부모에서 하드코딩된 데이터를 전달**합니다.
3. **공통 부모에 상태를 추가**하고 이벤트 핸들러와 함께 하위 컴포넌트에 전달합니다.

이렇게 하면 Accordion 컴포넌트가 두 개의 패널을 조율하고 한 번에 하나만 확장하게 됩니다.

#### 단계 1: 자식 컴포넌트에서 상태 제거

Panel의 isActive를 부모 컴포넌트에게 제어권을 넘깁니다. 즉, 부모 컴포넌트는 isActive를 Panel에게 props로 전달합니다. 먼저 Panel 컴포넌트에서 다음 줄을 **제거**합니다:

```javascript
const [isActive, setIsActive] = useState(false);
```

그리고 isActive를 Panel의 props 목록에 추가합니다:

```javascript
function Panel({ title, children, isActive }) {
```

이제 Panel의 부모 컴포넌트는 isActive를 props로 전달하여 isActive를 제어할 수 있습니다. 반대로, Panel 컴포넌트는 이제 isActive의 값을 직접 제어할 수 없습니다. isActive의 값은 이제 부모 컴포넌트에 달렸습니다!

#### 단계 2: 공통 부모로부터 하드코딩된 데이터 전달

상태를 위로 올리려면 조율하려는 두 자식 컴포넌트의 가장 가까운 공통 부모 컴포넌트를 찾아야 합니다:

- Accordion (가장 가까운 공통 부모)
  - Panel
  - Panel

이 예시에서는 Accordion 컴포넌트가 해당됩니다. Accordion 컴포넌트는 두 패널을 모두 제어할 수 있으므로, 현재 활성화된 패널에 대한 isActive의 하드코딩된 값을 두 패널에 전달합니다(예: true):

    <iframe 
      src="https://codesandbox.io/embed/nervous-orla-xftw4c?fontsize=14&hidenavigation=1&theme=dark"
      style={{
        width: '100%',
        height: '500px',
        border: '0',
        borderRadius: '4px',
        overflow: 'hidden'
      }}
      title="nervous-orla-xftw4c"
      allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
      sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
    >
    </iframe>

Accordion 컴포넌트에서 하드코딩된 isActive 값을 수정해보고, 화면에서 결과를 확인해보세요.


#### 단계 3: 공통 부모에 상태 추가

상태를 위로 올리면서 상태의 성격이 변경될 수 있습니다.

이 경우에는 한 번에 하나의 패널만 활성화되어야 합니다. 이는 Accordion 공통 부모 컴포넌트가 현재 활성화된 패널의 인덱스를 추적해야 함을 의미합니다. 불리언 값 대신에 상태 변수의 일부로서 활성 패널의 인덱스로 사용할 수 있습니다:


```javascript
const [activeIndex, setActiveIndex] = useState(0);
```

activeIndex가 0일 때는 첫 번째 패널이 활성화되고, 1일 때는 두 번째 패널이 활성화됩니다.

Panel의 "Show" 버튼을 클릭하여 Accordion에서 활성 인덱스를 변경해야 합니다. Panel은 직접 activeIndex 상태를 설정할 수 없습니다. 왜냐하면 activeIndex는 Accordion 내부에 정의되어 있기 때문입니다. Panel 컴포넌트가 부모의 상태를 변경할 수 있도록 부모가 이

벤트 핸들러를 전달해야 합니다. [이벤트 핸들러를 props로 전달하는 방법](https://react.dev/learn/responding-to-events#passing-event-handlers-as-props)을 사용하여 다음과 같이 Accordion 컴포넌트 내부에서 Panel 컴포넌트에 전달합니다:

```javascript
<>
  <Panel
    isActive={activeIndex === 0}
    onShow={() => setActiveIndex(0)}
  >
    ...
  </Panel>
  <Panel
    isActive={activeIndex === 1}
    onShow={() => setActiveIndex(1)}
  >
    ...
  </Panel>
</>
```

Panel 내부의 `<button>`은 이제 onShow prop을 클릭 이벤트 핸들러로 사용합니다:

<iframe src="https://codesandbox.io/embed/upbeat-satoshi-4wsn52?fontsize=14&hidenavigation=1&theme=dark"
     style={{ width: '100%', height: '500px', border: '0', borderRadius: '4px', overflow: 'hidden' }}
     title="upbeat-satoshi-4wsn52"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts">
</iframe>

이로써 상태를 위로 올리는 작업이 완료되었습니다! 상태를 공통 부모 컴포넌트로 이동함으로써 두 패널을 조율할 수 있게 되었습니다. 두 개의 "보이기" 버튼 중 하나를 클릭하여 활성 인덱스를 변경할 수 있습니다. 두 개의 "보이기" 플래그 대신에 활성 인덱스를 사용하면 한 번에 하나의 패널만 활성화되도록 보장할 수 있습니다. 그리고 하위 컴포넌트로 이벤트 핸들러를 전달하여 하위 컴포넌트가 상위 컴포넌트의 상태를 변경할 수 있게 했습니다.

<div style={{ textAlign: 'center' }}>
  <table style={{ borderCollapse: 'collapse', border: 'none', margin: 'auto' }}>
    <tr>
      <td style={{ border: 'none', padding: 20 }}>
        <img src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fsharing_state_parent.png&w=640&q=75" alt="React Sharing Data" width="320" height="auto"/>
        <p style={{ margin: 0 }}>초기에 Accordion의 activeIndex 값은 0이므로 첫 번째 Panel은 isActive 값이 true로 설정됩니다.</p>
      </td>
      <td style={{ border: 'none', padding: 20 }}>
        <img src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fsharing_state_parent_clicked.png&w=640&q=75" alt="React Sharing Data" width="320" height="auto"/>
        <p style={{ margin: 0 }}>Accordion의 activeIndex 상태가 1로 변경되면 두 번째 Panel은 isActive 값이 true로 설정됩니다.</p>
      </td>
    </tr>
  </table>
</div>

<Callout>
**제어 컴포넌트와 비제어 컴포넌트**

로컬 상태를 가진 컴포넌트를 "비제어(uncontrolled)" 컴포넌트라고 부르는 것은 일반적입니다. 예를 들어, isActive 상태 변수를 가진 원래 Panel 컴포넌트는 부모가 패널이 활성화되어 있는지 여부에 영향을 줄 수 없으므로 비제어 컴포넌트입니다.

반면에, 중요한 정보가 로컬 상태가 아니라 props에 의해 결정되는 경우 컴포넌트를 "제어(controlled)" 컴포넌트라고 할 수 있습니다. 이는 부모 컴포넌트가 해당 컴포넌트의 동작을 완전히 지정할 수 있게 합니다. isActive prop을 사용하는 최종 Panel 컴포넌트는 Accordion 컴포넌트에 의해 제어됩니다.

비제어 컴포넌트는 구성이 덜 필요하기 때문에 부모 컴포넌트 내에서 사용하기 쉽습니다. 그러나 여러 컴포넌트를 함께 조율하려는 경우에는 제어 컴포넌트가 훨씬 유연합니다. 제어 컴포넌트는 최대한 유연하지만, 부모 컴포넌트가 props로 완전히 구성해주어야 합니다.

실제로, "제어"와 "비제어"는 엄격한 기술적인 용어는 아닙니다. 각 컴포넌트는 일반적으로 로컬 상태와 props를 혼합해서 사용합니다. 그러나 이는 컴포넌트의 설계 방식과 제공하는 기능에 대해 이야기하는 유용한 방법입니다.

컴포넌트를 작성할 때, 어떤 정보가 props(을 통해)로 제어되어야 하는지, 어떤 정보가 비제어 상태(로컬 상태)로 제어되어야 하는지를 고려해야 합니다. 하지만 언제든지 생각을 변경하고 리팩토링할 수 있습니다.
</Callout>



### 각 상태에 대한 단일 소스(컴포넌트)

React 애플리케이션에서는 많은 컴포넌트가 자체적인 상태를 가집니다. 어떤 상태는 입력과 같은 리프 컴포넌트 근처에 "거주"할 수 있습니다. 다른 상태는 앱의 상위 부분에 더 "거주"할 수 있습니다. 예를 들어, 클라이언트 측 라우팅 라이브러리는 보통 현재 경로를 React 상태에 저장하고, 이를 props로 전달하여 구현됩니다!

**고유한 각 상태에 대해 해당 상태를 "소유"하는 컴포넌트를 선택합니다.** 이 원칙은 [“단일 진실의 원천(single source of truth)”](https://en.wikipedia.org/wiki/Single_source_of_truth)이라고도 알려져 있습니다. 모든 상태가 한 곳에 존재해야 한다는 의미는 아니지만, 각 상태의 정보를 보유하는 특정 컴포넌트가 있어야 합니다. 상태를 공유하기 위해 컴포넌트 간에 공유 상태를 복제하는 대신, 공유 상태를 공통 부모 컴포넌트로 올리고 필요한 하위 컴포넌트에 전달합니다.

앱을 개발하면서 상태의 "소유자"를 찾는 과정에서 상태를 하위로 이동시키거나 다시 상위로 올리는 경우가 있을 수 있습니다. 이 모두 프로세스의 일부입니다!

더 많은 컴포넌트와 함께 실제로 어떻게 느껴지는지 확인하려면 [React로 생각하기](https://react.dev/learn/thinking-in-react)를 읽어보세요.

### 요약

- 두 개의 컴포넌트를 조율하려면 상태를 공통 부모 컴포넌트로 이동합니다.
- 그런 다음 공통 부모 컴포넌트를 통해 정보를 하위 컴포넌트로 props로 전달합니다.
- 마지막으로 이벤트 핸들러를 전달하여 자식 컴포넌트가 부모의 상태를 변경할 수 있도록 합니다.
- 컴포넌트를 "제어" 컴포넌트(Props로 제어됨) 또는 "비제어" 컴포넌트(로컬 상태로 제어됨)로 고려하는 것이 유용합니다.


## 상태 보존과 재설정 

상태는 컴포넌트 간에 격리되어 있습니다. React는 UI 트리 내의 위치를 기반으로 어떤 상태가 어떤 컴포넌트에 속하는지 추적합니다. 상태를 언제 보존하고 언제 리셋할지를 제어할 수 있습니다.

배울 내용

- React가 컴포넌트 구조를 "보는" 방식
- React가 상태를 보존하거나 리셋하는 시점
- React에게 컴포넌트 상태를 강제로 리셋시키는 방법
- 키와 타입이 상태 보존 여부에 어떤 영향을 미치는지

### UI 트리

브라우저는 UI를 모델링하기 위해 여러 트리 구조를 사용합니다. [DOM](https://developer.mozilla.org/docs/Web/API/Document_Object_Model/Introduction)은 HTML 요소를 나타내고, [CSSOM](https://developer.mozilla.org/docs/Web/API/CSS_Object_Model)은 CSS를 나타냅니다. 심지어 [접근성 트리](https://developer.mozilla.org/docs/Glossary/Accessibility_tree)도 있습니다!

React도 UI를 관리하고 모델링하기 위해 트리 구조를 사용합니다. React는 JSX로부터 **UI 트리**를 만듭니다. 그런 다음 React DOM은 브라우저 DOM 요소를 해당 UI 트리와 일치하도록 업데이트합니다. (React Native는 이러한 트리를 모바일 플랫폼에 특화된 요소로 변환합니다.)
<div style={{ textAlign: "center" }}>
  <img 
    src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_dom_tree.png&w=1080&q=75" 
    alt="React Sharing Data" 
    width="100%" 
    style={{ height: "auto" }}
  />
  <p>컴포넌트로부터, React는 UI 트리를 생성하고 React DOM은 이를 사용하여 DOM을 렌더링합니다.</p>
</div>

### 상태는 트리 내의 위치에 연결됩니다

컴포넌트에 상태를 제공할 때, 상태가 컴포넌트 내에 "존재"한다고 생각할 수 있습니다. 하지만 실제로 상태는 React 내부에 보관됩니다. React는 상태 조각을 컴포넌트가 UI 트리 내의 어떤 위치에 있는지에 따라 올바른 컴포넌트와 연결합니다.

여기에서는 `<Counter />` JSX 태그가 하나만 있지만, 서로 다른 위치에 두 개의 별도의 Counter가 렌더링됩니다:
<iframe src="https://codesandbox.io/embed/elated-frog-zcc3dp?fontsize=14&hidenavigation=1&theme=dark"
     style={{ width: '100%', height: '500px', border: '0', borderRadius: '4px', overflow: 'hidden' }}
     title="elated-frog-zcc3dp"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts">
</iframe>

이것이 트리로 표시된 모습입니다:
<div style={{ textAlign: 'center' }}>
  <img src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_tree.png&w=640&q=75" alt="React Sharing Data" style={{ width: '400px' }} />
  <p>React 트리</p>
</div>

**이것은 두 개의 별도의 카운터입니다. 각각은 고유한 위치에 렌더링되기 때문입니다.** React를 사용할 때는 일반적으로 이러한 위치를 고려할 필요는 없지만, 작동 방식을 이해하는 데 유용할 수 있습니다.

React에서 화면의 각 컴포넌트는 완전히 격리된 상태를 가지고 있습니다. 예를 들어, 두 개의 Counter 컴포넌트를 옆에 렌더링한다면, 각각에는 독립적인 점수(score)와 호버(hover) 상태가 있게 됩니다.

두 개의 카운터를 모두 클릭해보고, 서로에게 영향을 주지 않는다는 점을 확인하세요:

<iframe src="https://codesandbox.io/embed/inspiring-pike-3jz97w?fontsize=14&hidenavigation=1&theme=dark"
     style={{ width: '100%', height: '500px', border: '0', borderRadius: '4px', overflow: 'hidden' }}
     title="inspiring-pike-3jz97w"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

보시다시피 한 컴포넌트가 업데이트될 때 해당 컴포넌트의 상태만 업데이트됩니다:
<div style={{ display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center' }}>
  <img src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_increment.png&w=640&q=75" alt="React Sharing Data" width="400" height="auto" />
  <p>상태 업데이트</p>
</div>

React는 동일한 컴포넌트가 동일한 위치에서 렌더링되는 한 상태를 계속 유지합니다. 이를 확인하려면 두 개의 카운터를 증가시킨 다음 "두 번째 카운터 렌더링" 확인란을 선택 해제하여 두 번째 컴포넌트를 제거한 다음 다시 선택하여 추가하세요:

  <iframe
    src="https://codesandbox.io/embed/romantic-wildflower-wxsc2o?fontsize=14&hidenavigation=1&theme=dark"
    style={{ width: '100%', height: '500px', border: '0', borderRadius: '4px', overflow: 'hidden' }}
    title="romantic-wildflower-wxsc2o"
    allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
    sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
  />

두 번째 카운터를 더 이상 렌더링하지 않게되면, 해당 상태가 완전히 사라집니다. 그 이유는 React가 컴포넌트를 제거할 때 상태를 파괴하기 때문입니다.

<div style={{ textAlign: 'center' }}>
  <img src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_remove_component.png&w=640&q=75" alt="React Sharing Data" width="400" />
  <p>컴포넌트 삭제</p>
</div>

React는 동일한 컴포넌트가 UI 트리에서 동일한 위치에 렌더링되는 한 상태를 유지합니다.

<div style={{ textAlign: 'center' }}>
  <img src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_add_component.png&w=640&q=75" alt="React Sharing Data" width="400" />
  <p>컴포넌트 추가</p>
</div>


### 동일한 위치에 있는 동일한 컴포넌트는 상태를 보존합니다

이 예제에서는 두 개의 다른 `<Counter />` 태그가 있습니다:
    <iframe 
      src="https://codesandbox.io/embed/bold-einstein-8swdmv?fontsize=14&hidenavigation=1&theme=dark"
      style={{ width: "100%", height: "500px", border: "0", borderRadius: "4px", overflow: "hidden" }}
      title="bold-einstein-8swdmv"
      allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
      sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
    />
체크박스를 선택하거나 선택 해제할 때, 카운터 상태는 리셋되지 않습니다. isFancy가 true이든 false이든, 항상 root App 컴포넌트에서 반환된 div의 첫 번째 자식으로 `<Counter />`가 있습니다:

<div style={{ textAlign: 'center' }}>
  <img src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_same_component.png&w=640&q=75" alt="React Sharing Data" width="640" />
  <p>앱 상태를 업데이트해도 Counter는 리셋되지 않습니다. 이는 Counter가 동일한 위치에 남아 있기 때문입니다.</p>
</div>

React의 관점에서 동일한 컴포넌트이므로 구분됩니다.

<Callout type="warning">
**주의하기**

React에서 중요한 점은 **JSX 마크업이 아니라 UI 트리 내의 위치가 중요하다는 것입니다!** 이 컴포넌트는 if문 내부와 외부에 서로 다른 `<Counter />` JSX 태그를 포함하는 두 개의 return 절이 있습니다:
</Callout>


<iframe 
  src="https://codesandbox.io/embed/nostalgic-alex-18c6we?fontsize=14&hidenavigation=1&theme=dark"
  style={{ width: "100%", height: "500px", border: "0", borderRadius: "4px", overflow: "hidden" }}
  title="nostalgic-alex-18c6we"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
/>


체크박스를 선택할 때 상태가 리셋될 것으로 예상할 수 있지만, 그렇지 않습니다! 이는 **이 두 개의 `<Counter />` 태그가 동일한 위치에서 렌더링되기 때문입니다.** React는 함수 내에서 조건을 어디에 두었는지 알지 못합니다. React가 "보는" 것은 반환한 트리뿐입니다.

두 경우 모두 App 컴포넌트가 `<Counter />`를 첫 번째 자식으로 포함하는 `<div>`를 반환합니다. React는 이 두 카운터가 동일한 "주소"를 가지고 있다고 간주합니다. 즉, root의 첫 번째 자식의 첫 번째 자식입니다. 이것은 React가 이전과 다음 렌더링 사이에서 이들을 일치시키기 위해 사용하는 방법이며, 로직을 구조화하는 방식과 상관없이 동작합니다.

### 동일한 위치에 있는 다른 컴포넌트는 상태를 리셋합니다

이 예제에서는 체크박스를 선택하면 `<Counter>`를 `<p>`로 바꿉니다:

<iframe 
  src="https://codesandbox.io/embed/sharp-pine-6gbws5?fontsize=14&hidenavigation=1&theme=dark"
  style={{ width: "100%", height: "500px", border: "0", borderRadius: "4px", overflow: "hidden" }}
  title="sharp-pine-6gbws5"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
/>


여기에서 동일한 위치에서 다른 컴포넌트 유형으로 전환합니다. 초기에는 `<div>`의 첫 번째 자식에 Counter가 포함되어 있습니다. 그러나 p로 교체할 때, React는 Counter를 UI 트리에서 제거하고 해당 상태를 파괴합니다.

<div style={{ textAlign: 'center' }}>
  <img src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_pt1.png&w=828&q=75" alt="React Sharing Data" width="600" />
  <p>Counter가 p로 변경되면 Counter는 삭제되고 p가 추가됩니다.</p>
</div>

  
<div style={{ textAlign: 'center' }}>
  <img src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_pt2.png&w=828&q=75" alt="React Sharing Data" width="600" />
  <p>다시 전환할 때, p가 삭제되고 Counter가 추가됩니다.</p>
</div>

또한, **동일한 위치에 다른 컴포넌트를 렌더링하면 하위 트리 전체의 상태가 리셋됩니다.** 이 작동 방식을 확인하기 위해 카운터를 증가시킨 다음 체크박스를 선택하세요:

<iframe 
  src="https://codesandbox.io/embed/dawn-grass-meowu5?fontsize=14&hidenavigation=1&theme=dark"
  style={{ width: "100%", height: "500px", border: "0", borderRadius: "4px", overflow: "hidden" }}
  title="dawn-grass-meowu5"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
/>


체크박스를 클릭하면 카운터 상태가 리셋됩니다. Counter를 렌더링하더라도, 첫 번째 자식 div가 div에서 section으로 변경되면서 하위 트리 전체(카운터 및 해당 상태 포함)가 파괴됩니다.

<div style={{ textAlign: 'center' }}>
  <img src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_same_pt1.png&w=828&q=75" alt="React Sharing Data" width="600" />
  <p>section이 div로 변경될 때, section은 삭제되고 새로운 div가 추가됩니다.</p>
</div>


<div style={{ textAlign: 'center' }}>
  <img src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_same_pt2.png&w=828&q=75" alt="React Sharing Data" width="600" />
  <p>다시 전환할 때, div는 삭제되고 새로운 section이 추가됩니다.</p>
</div>


일반적으로 **재렌더링 사이에서 상태를 보존하려면 트리의 구조가 한 렌더링에서 다른 렌더링으로 "일치"해야 합니다.** 구조가 다르면 React는 컴포넌트를 트리에서 제거할 때 상태를 파괴합니다.

<Callout type="warning">
**주의하기**

이것이 컴포넌트 함수 정의를 중첩해서 사용하지 않아야 하는 이유입니다.
</Callout>

여기에서 MyTextField 컴포넌트 함수가 MyComponent 내에서 정의되었습니다:
<iframe 
  src="https://codesandbox.io/embed/lucid-napier-0p1vil?fontsize=14&hidenavigation=1&theme=dark"
  style={{ width: "100%", height: "500px", border: "0", borderRadius: "4px", overflow: "hidden" }}
  title="lucid-napier-0p1vil"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
/>


버튼을 클릭할 때마다 입력 상태가 사라집니다! 이는 MyComponent의 각 렌더링마다 다른 MyTextField 함수가 생성되기 때문입니다. 동일한 위치에서 다른 컴포넌트를 렌더링하고 있으므로 React는 하위 모든 상태를 리셋합니다. 이는 버그와 성능 문제를 유발합니다. 이 문제를 피하기 위해 항상 컴포넌트 함수를 최상위 수준에서 선언하고 중첩하여 정의하지 않도록 해야 합니다.

### 동일한 위치에서 상태를 리셋하기

기본적으로 React는 동일한 위치에서 컴포넌트가 유지되는 동안 해당 컴포넌트의 상태를 보존합니다. 보통 이것이 원하는 동작이므로 기본 동작으로 의미가 있습니다. 그러나 때로는 컴포넌트의 상태를 리셋해야 할 수도 있습니다. 각 턴마다 두 플레이어의 점수를 기록할 수 있는 이 앱을 생각해보세요:

<iframe 
  src="https://codesandbox.io/embed/zen-sunset-fi5b4y?fontsize=14&hidenavigation=1&theme=dark"
  style={{ width: "100%", height: "500px", border: "0", borderRadius: "4px", overflow: "hidden" }}
  title="zen-sunset-fi5b4y"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
/>


현재, 플레이어를 변경하면 점수가 보존됩니다. 두 개의 Counters는 동일한 위치에 나타나므로 React는 동일한 Counter로 인식합니다.

그러나 개념적으로 이 앱에서는 두 개의 별도 카운터가 있어야 합니다. UI에서 동일한 위치에 표시될 수 있지만, 하나는 Taylor의 점수를, 다른 하나는 Sarah의 점수를 나타냅니다.

이들 간에 상태를 리셋하는 두 가지 방법이 있습니다:

1.  서로 다른 위치에 컴포넌트 렌더링하기
2.  각 컴포넌트에 key를 명시적으로 부여하기

#### 옵션 1: 서로 다른 위치에 컴포넌트 렌더링하기

이 두 Counters가 독립적이기를 원한다면, 두 개의 서로 다른 위치에 렌더링할 수 있습니다:

<iframe 
  src="https://codesandbox.io/embed/gallant-nobel-pzdeny?fontsize=14&hidenavigation=1&theme=dark"
  style={{ width: "100%", height: "500px", border: "0", borderRadius: "4px", overflow: "hidden" }}
  title="gallant-nobel-pzdeny"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
/>


-   초기에는 isPlayerA가 true이므로 첫 번째 위치에 Counter 상태가 있고 두 번째 위치는 비어 있습니다.
-   "다음 플레이어" 버튼을 클릭하면 첫 번째 위치가 지워지고 두 번째 위치에는 이제 Counter가 포함됩니다.

<center style={{ display: 'table', margin: 'auto' }}>
  <table style={{ borderCollapse: 'collapse', border: 'none' }}>
    <tr>
      <td style={{ border: 'none', padding: 20 }}>
        <img src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_position_p1.png&w=640&q=75" alt="React Sharing Data" width="320" height="auto" />
        <p style={{ margin: 0 }}><center>초기상태</center></p>
      </td>
      <td style={{ border: 'none', padding: 20 }}>
        <img src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_position_p2.png&w=640&q=75" alt="React Sharing Data" width="320" height="auto" />
        <p style={{ margin: 0 }}><center>"다음" 클릭</center></p>
      </td>
      <td style={{ border: 'none', padding: 20 }}>
        <img src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpreserving_state_diff_position_p3.png&w=640&q=75" alt="React Sharing Data" width="320" height="auto" />
        <p style={{ margin: 0 }}><center>다시, "다음" 클릭</center></p>
      </td>
    </tr>
  </table>
</center>


각 Counter의 상태는 DOM에서 제거되는 경우마다 파괴됩니다. 이것이 버튼을 클릭할 때마다 카운터가 리셋되는 이유입니다.

이 솔루션은 동일한 위치에 렌더링되는 독립적인 컴포넌트가 몇 개만 있는 경우에 편리합니다. 이 예제에서는 두 개뿐이므로 JSX에서 각각을 별도로 렌더링하는 것은 부담이 되지 않습니다.

#### 옵션 2: 키를 사용하여 상태 리셋하기

상태를 키를 사용하여 리셋하는 더 일반적인 방법도 있습니다.

리스트를 렌더링할 때 키를 사용하는 것을 본 적이 있을 것입니다. 키는 리스트에만 해당하는 것이 아닙니다! 키를 사용하여 React에게 컴포넌트 간의 구별을 알려줄 수 있습니다. 기본적으로 React는 부모 내에서 순서("첫 번째 카운터", "두 번째 카운터")를 사용하여 컴포넌트를 구별합니다. 그러나 키를 사용하면 이것이 그냥 첫 번째 카운터나 두 번째 카운터가 아니라 특정한 카운터(예: Taylor의 카운터)임을 React에게 알릴 수 있습니다. 이렇게 하면 React는 트리의 어느 위치에 나타나더라도 Taylor의 카운터로 인식합니다!

이 예제에서는 JSX에서 동일한 위치에 나타나지만 각 `<Counter />`가 상태를 공유하지 않습니다:
import React from 'react';

<iframe 
  src="https://codesandbox.io/embed/little-framework-vlg047?fontsize=14&hidenavigation=1&theme=dark"
  style={{ width: "100%", height: "500px", border: "0", borderRadius: "4px", overflow: "hidden" }}
  title="little-framework-vlg047"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


Taylor와 Sarah 사이를 전환해도 상태가 보존되지 않습니다. 이는 **서로 다른 키를 부여했기 때문입니다:**

```javascript
{isPlayerA ? (
  <Counter key="Taylor" person="Taylor" />
) : (
  <Counter key="Sarah" person="Sarah" />
)}
```

키를 명시하면 React가 순서 대신 키 자체를 위치의 일부로 사용하도록 지시합니다. 이렇게 하면 JSX에서 동일한 위치에 렌더링되지만 React는 두 개의 다른 카운터로 인식하므로 상태를 공유하지 않습니다. 카운터가 화면에 나타날 때마다 해당 상태가 생성됩니다. 제거될 때마다 해당 상태가 파괴됩니다. 상태를 반복해서 리셋합니다.

> 참고
키는 전역적으로 고유할 필요가 없습니다. 키는 부모 내에서 위치를 지정하는 데 사용됩니다.

#### 키를 사용하여 폼 리셋하기

키를 사용하여 상태를 리셋하는 것은 폼을 다룰 때 특히 유용합니다.

이 채팅 앱에서 `<Chat>` 컴포넌트는 텍스트 입력 상태를 포함합니다:
import React from 'react';

<iframe 
  src="https://codesandbox.io/embed/silent-hill-e2gbfe?fontsize=14&hidenavigation=1&theme=dark"
  style={{ width: "100%", height: "500px", border: "0", borderRadius: "4px", overflow: "hidden" }}
  title="silent-hill-e2gbfe"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


입력란에 내용을 입력한 다음 "Alice" 또는 "Bob"을 눌러 다른 수신자를 선택해보세요. 입력 상태가 보존되는 것을 알 수 있습니다. `<Chat>`이 UI 트리에서 동일한 위치에 렌더링되므로 일반적으로 이는 원하는 동작입니다.

**많은 앱에서 이것이 원하는 동작일 수 있지만 채팅 앱에서는 그렇지 않습니다!** 사용자가 실수로 클릭하여 이미 입력한 메시지를 잘못된 사람에게 보내지 않도록 해야합니다. 이를 수정하기 위해 키를 추가하세요:

```javascript
<Chat key={to.id} contact={to} />
```

이렇게하면 다른 수신자를 선택할 때마다 Chat 컴포넌트가 처음부터 다시 생성되며, 해당 트리 아래에있는 모든 상태와 함께 재생성됩니다. React는 또한 DOM 요소를 재생성하게 됩니다.

이제 수신자를 전환하면 항상 텍스트 필드가 지워집니다.

<iframe 
  src="https://codesandbox.io/embed/upbeat-joliot-s2dg76?fontsize=14&hidenavigation=1&theme=dark"
  style={{ width: "100%", height: "500px", border: "0", borderRadius: "4px", overflow: "hidden" }}
  title="upbeat-joliot-s2dg76"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

<Callout>
**제거된 컴포넌트의 상태 보존**

실제 채팅 앱에서 이전 수신자를 다시 선택할 때 입력 상태를 복구하고 싶을 것입니다. 이전 수신자가 다시 선택될 때 컴포넌트가 더 이상 표시되지 않는 상태에서 "alive"한 상태를 유지하는 몇 가지 방법이 있습니다.

- 모든 채팅을 렌더링하고 CSS로 모든 다른 채팅을 숨깁니다. 채팅은 트리에서 제거되지 않으므로 로컬 상태가 보존됩니다. 이 방법은 단순한 UI에는 잘 작동하지만, 숨겨진 트리가 크고 DOM 노드가 많은 경우에는 매우 느려질 수 있습니다.
- 상태를 상위 컴포넌트로 "올리고" 각 수신자에 대한 보류 중인 메시지를 부모 컴포넌트에 보관합니다. 이렇게하면 하위 컴포넌트가 제거되어도 상관없습니다. 중요한 정보를 유지하는 것은 부모 컴포넌트입니다. 이것이 가장 일반적인 솔루션입니다.
- React 상태 외에도 다른 소스를 사용할 수도 있습니다. 예를 들어, 사용자가 실수로 페이지를 닫아도 메시지 초안이 유지되기를 원할 것입니다. 이를 구현하기 위해 Chat 컴포넌트는 [localStorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage)에서 읽어 상태를 초기화하고 초안을 저장할 수 있습니다.

어떤 전략을 선택하든, Alice와의 대화는 Bob과의 대화와 개념적으로 다른 것이므로 현재 수신자를 기준으로 `<Chat>` 트리에 키를 부여하는 것이 합리적입니다.
</Callout>

### 요약

- React는 동일한 컴포넌트가 동일한 위치에 렌더링되는 한 상태를 유지합니다.
- 상태는 JSX 태그에 저장되는 것이 아닙니다. JSX에 배치한 위치와 관련이 있습니다.
- 다른 키를 부여하여 하위 트리를 강제로 리셋시킬 수 있습니다.
- 컴포넌트 정의를 중첩하지 마세요. 그렇게 하면 실수로 상태가 리셋됩니다.




## 상태 로직을 리듀서로 추출하기


여러 이벤트 핸들러에 걸쳐 상태 업데이트가 분산되는 컴포넌트는 복잡해질 수 있습니다. 이러한 경우 컴포넌트 외부에서 모든 상태 업데이트 로직을 단일 함수로 통합하여 리듀서라고 하는 방식으로 구현할 수 있습니다.

배울 내용

- 리듀서 함수란 무엇인가
- useState를 useReducer로 리팩터링하는 방법
- 언제 리듀서를 사용해야 하는가
- 효율적인 리듀서 작성 방법

### 리듀서로 상태 로직 통합하기

컴포넌트가 복잡해지면 한눈에 컴포넌트의 상태가 어떻게 업데이트되는지 파악하기 어려워집니다. 예를 들어, 아래의 TaskApp 컴포넌트는 상태로 작업 배열을 보유하고 작업을 추가, 제거 및 편집하는 세 가지 다른 이벤트 핸들러를 사용합니다:

<iframe 
  src="https://codesandbox.io/embed/quirky-chihiro-t7jwxq?fontsize=14&hidenavigation=1&theme=dark"
  style={{ width: "100%", height: "500px", border: "0", borderRadius: "4px", overflow: "hidden" }}
  title="quirky-chihiro-t7jwxq"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

각 이벤트 핸들러는 상태를 업데이트하기 위해 setTasks를 호출합니다. 이 컴포넌트가 커짐에 따라 상태 로직도 함께 분산되어 복잡성이 증가합니다. 이러한 복잡성을 줄이고 로직을 한 곳에 모아두기 위해, 컴포넌트 외부에 상태 로직을 담은 단일 함수인 **"리듀서"**를 만들 수 있습니다.

리듀서는 상태를 처리하는 다른 방법입니다. useState에서 useReducer로 마이그레이션하는 단계는 다음과 같습니다.

1. 상태 설정에서 액션을 디스패치하는 방식으로 전환합니다.
2. 리듀서 함수를 작성합니다.
3. 컴포넌트에서 리듀서를 사용합니다.

#### 단계 1: 상태 설정에서 액션을 디스패치하는 방식으로 전환하기

현재 이벤트 핸들러에서는 상태를 설정하여 수행할 작업을 지정합니다.

```jsx
function handleAddTask(text) {
  setTasks([
    ...tasks,
    {
      id: nextId++,
      text: text,
      done: false,
    },
  ]);
}

function handleChangeTask(task) {
  setTasks(
    tasks.map((t) => {
      if (t.id === task.id) {
        return task;
      } else {
        return t;
      }
    })
  );
}

function handleDeleteTask(taskId) {
  setTasks(tasks.filter((t) => t.id !== taskId));
}
```

상태 설정 로직을 모두 제거합니다. 남아있는 것은 세 가지 이벤트 핸들러입니다:

- 사용자가 "추가" 버튼을 누를 때 `handleAddTask(text)`가 호출됩니다.
- 사용자가 작업을 토글하거나 "저장" 버튼을 누를 때 `handleChangeTask(task)`가 호출됩니다.
- 사용자가 "삭제" 버튼을 누를 때 `handleDeleteTask(taskId)`가 호출됩니다.

리듀서를 사용하는 경우 상태를 설정하기 위한 이벤트 핸들러 대신 액션을 디스패치하여 "사용자가 방금 무엇을 했는지"를 지정합니다. (상태 업데이트 로직은 다른 곳에 있습니다!) 따라서 이벤트 핸들러를 통해 "작업 추가/변경/삭제" 액션을 디스패치하는 대신 "작업을 추가/변경/삭제했다"라고 명시합니다. 이는 사용자의 의도를 더 명확하게 나타냅니다.

```jsx
function handleAddTask(text) {
  dispatch({
    type: 'added',
    id: nextId++,
    text: text,
  });
}

function handleChangeTask(task) {
  dispatch({
    type: 'changed',
    task: task,
  });
}

function handleDeleteTask(taskId) {
  dispatch({
    type: 'deleted',
    id: taskId,
  });
}
```

dispatch에 전달하는 객체를 "액션"이라고 합니다.

```jsx
function handleDeleteTask(taskId) {
  dispatch(
    // "액션" 객체:
    {
      type: 'deleted',
      id: taskId,
    }
  );
}
```

이 객체는 일반적인 JavaScript 객체입니다. 무엇을 담을지는 사용자가 결정할 수 있지만, 일반적으로 발생한 일에 대한 최소한의 정보를 담아야 합니다. (나중에 dispatch 함수 자체를 추가할 것입니다.)

<Callout>
**액션 객체는 어떤 형태든지 가질 수 있습니다.**

관례적으로 발생한 일을 설명하는 문자열 타입(type)을 주로 사용하고 다른 필드에 추가 정보를 전달합니다. 타입은 컴포넌트에 특정한 것이므로 이 예제에서 'added' 또는 'added_task' 중 어느 것을 사용해도 괜찮습니다. 발생한 일을 나타내는 이름을 선택하세요!

```jsx
dispatch({
  // 컴포넌트에 특정한 것
  type: '무슨_일이_일어났는지',
  // 다른 필드는 여기에 넣습니다
});
```
</Callout>

#### 단계 2: 리듀서 함수 작성하기

리듀서 함수에 상태 로직을 넣을 것입니다. 현재 상태와 액션 객체 두 가지 인수를 받고 다음 상태를 반환합니다.

```jsx
function yourReducer(state, action) {
  // React에서 설정할 다음 상태를 반환
}
```

리듀서에서 반환한 값을 React가 상태로 설정합니다.

이 예제에서 상태 설정 로직을 이벤트 핸들러에서 리듀서 함수로 이동하기 위해 다음 작업을 수행합니다.

1. 첫 번째 인수로 현재 상태(tasks)를 선언합니다.
2. 두 번째 인수로 액션 객체를 선언합니다.
3. 리듀서에서 다음 상태를 반환합니다. (React가 상태를 설정할 것입니다.)

모든 상태 설정 로직을 리듀서 함수로 마이그레이션한 코드입니다.

```jsx
function tasksReducer(tasks, action) {
  if (action.type === 'added') {
    return [
      ...tasks,
      {
        id: action.id,
        text: action.text,
        done: false,
      },
    ];
  } else if (action.type === 'changed') {
    return tasks.map((t) => {
      if (t.id === action.task.id) {
        return action.task;
      } else {
        return t;
      }
    });
  } else if (action.type === 'deleted') {
    return tasks.filter((t) => t.id !== action.id);
  } else {
    throw Error('Unknown action: ' + action.type);
  }
}
```

리듀서 함수는 상태(tasks)를 인수로 받기 때문에 컴포넌트 외부에 선언할 수 있습니다. 이로 인해 들여쓰기 수준이 감소하고 코드를 읽기 쉬워집니다.

<Callout>

위 코드는 `if/else` 문을 사용하지만, 리듀서 내부에는 `switch` 문을 사용하는 것이 관례입니다. 결과는 동일하지만 `switch` 문은 한눈에 읽기 쉬울 수 있습니다.

다음 내용에 사용되는 방식처럼, `switch` 문을 사용하여 다음과 같이 작성하는 것이 좋습니다.

```jsx
function tasksReducer(tasks, action) {
  switch (action.type) {
    case 'added': {
      return [
        ...tasks,
        {
          id: action.id,
          text: action.text,
          done: false,
        },
      ];
    }
    case 'changed': {
      return tasks.map((t) => {
        if (t.id === action.task.id) {
          return action.task;
        } else {
          return t;
        }
      });
    }
    case 'deleted': {
      return tasks.filter((t) => t.id !== action.id);
    }
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}
```

중괄호로 각 case 블록을 감싸주는 것을 권장합니다. 이렇게 하면 각각의 case 내에서 선언된 변수가 서로 충돌하지 않습니다. 또한, case는 일반적으로 return으로 끝나야 합니다. return을 빼먹으면 코드가 다음 case로 "떨어지게(fall through)" 되어 오류가 발생할 수 있습니다!

`switch` 문에 익숙하지 않다면 `if/else`를 사용하는 것도 완전히 괜찮습니다.

</Callout>

<Callout>
**왜 리듀서를 이렇게 부르나요?**

리듀서는 컴포넌트 내부의 코드 양을 줄일 수 있지만, 실제로는 배열에서 수행할 수 있는 [reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce) 연산과 비슷한 작업을 수행하는 함수 이름입니다.

reduce() 연산을 사용하면 배열에서 "많은" 값 중 하나를 "누적"할 수 있습니다.

```jsx
const arr = [1, 2, 3, 4, 5];
const sum = arr.reduce(
  (result, number) => result + number
); // 1 + 2 + 3 + 4 + 5
```

reduce에 전달하는 함수는 "리듀서"라고 알려져 있습니다. 이 함수는 지금까지의 결과와 현재 항목을 받아 다음 결과를 반환합니다. React의 리듀서도 동일한 개념입니다. 현재 상태와 액션을 받아 다음 상태를 반환합니다. 이렇게 하여 액션을 시간에 따라 상태로 누적합니다.

<iframe 
  src="https://codesandbox.io/embed/zen-firefly-l4ef58?fontsize=14&hidenavigation=1&theme=dark"
  style={{ width: "100%", height: "500px", border: "0", borderRadius: "4px", overflow: "hidden" }}
  title="zen-firefly-l4ef58"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>
   
initialState와 액션 배열을 전달하여 리듀서 함수를 사용하여 최종 상태를 계산하는 reduce() 메서드를 실제로 사용할 일은 거의 없을 것입니다. 하지만 이것은 React가 하는 것과 유사합니다!
</Callout>

#### 단계 3: 컴포넌트에서 리듀서 사용하기

마지막으로, tasksReducer를 컴포넌트에 연결해야 합니다. React에서 useReducer Hook을 import합니다.

```jsx
import { useReducer } from 'react';
```

그런 다음 useState를 다음과 같이 useReducer로 대체합니다.

```jsx
const [tasks, setTasks] = useState(initialTasks);
```

다음과 같이 useReducer를 사용하여 useState를 대체합니다.

```jsx
const [tasks, dispatch] = useReducer(tasksReducer, initialTasks);
```

useReducer Hook은 useState와 유사합니다. 초기 상태를 전달하고 상태 값을 반환하며 상태를 설정하는 방법을 제공합니다. 다만 약간 다릅니다.

useReducer Hook은 두 개의 인수를 받습니다.

1. 리듀서 함수
2. 초기 상태

반환 값은 다음과 같습니다.

1. 상태 값을 가진 stateful 값
2. 리듀서에 사용자 액션을 "디스패치"하는 방법을 제공하는 dispatch 함수

이제 완전히 연결되었습니다! 리듀서는 컴포넌트 파일의 맨 아래에 선언되어 있습니다.
<iframe 
  src="https://codesandbox.io/embed/thirsty-williamson-0fv84s?fontsize=14&hidenavigation=1&theme=dark"
  style={{ width: "100%", height: "500px", border: "0", borderRadius: "4px", overflow: "hidden" }}
  title="thirsty-williamson-0fv84s"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

원한다면 리듀서를 다른 파일로 이동할 수도 있습니다.

import React from 'react';

<iframe 
  src="https://codesandbox.io/embed/gallant-dan-s6uocy?fontsize=14&hidenavigation=1&theme=dark"
  style={{ width: "100%", height: "500px", border: "0", borderRadius: "4px", overflow: "hidden" }}
  title="gallant-dan-s6uocy"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


이렇게 분리하면 컴포넌트 로직을 읽기 쉽게 만드는 등의 이점이 있습니다. 이제 이벤트 핸들러는 액션을 디스패치하여 어떤 일이 발생했는지 지정하며, 리듀서 함수는 상태가 어떻게 업데이트되는지를 결정합니다.

### useState와 useReducer 비교하기

리듀서에는 단점이 있을 수 있습니다! 다음과 같이 비교할 수 있습니다.

- **코드 크기:** 일반적으로 useState를 사용하는 경우, 처음에 작성해야 하는 코드는 더 적습니다. 하지만 많은 이벤트 핸들러에서 상태를 유사한 방식으로 수정하는 경우, useReducer를 사용하면 코드 양을 줄일 수 있습니다.
- **가독성:** 상태 업데이트가 간단한 경우에는 useState가 매우 읽기 쉽습니다. 하지만 복잡해지면 컴포넌트의 코드가 비대해지고 스캔하기 어려울 수 있습니다. 이 경우, useReducer를 사용하면 업데이트 로직의 "어떻게"와 이벤트 핸들러의 "무슨 일이 발생했는지"를 깔끔하게 분리할 수 있습니다.
- **디버깅:** useState에서 버그가 발생한 경우, 상태가 잘못 설정된 위치와 그 이유를 찾기 어려울 수 있습니다. useReducer의 경우, 리듀서에 콘솔 로그를 추가하여 모든 상태 업데이트 및 그 이유(어떤 액션 때문에 발생했는지)를 확인할 수 있습니다. 각 액션이 올바른 경우, 리듀서 로직 자체에 오류가 있음을 알 수 있습니다. 그러나 useState보다 더 많은 코드를 따라가야 합니다.
- **테스트:** 리듀서는 컴포넌트에 의존하지 않는 순수 함수입니다. 따라서 리듀서를 내보내어 독립적으로 테스트할 수 있습니다. 일반적으로 실제 환경에서 컴포넌트를 테스트하는 것이 좋지만, 복잡한 상태 업데이트 로직의 경우, 특정 초기 상태와 액션에 대해 리듀서가 특정 상태를 반환하는지 확인하는 것이 유용할 수 있습니다.
- **개인적인 선호도:** 어떤 사람들은 리듀서를 좋아하고, 다른 사람들은 그렇지 않을 수 있습니다. 이것은 선호도의 문제입니다. 언제든지 useState와 useReducer를 서로 전환할 수 있습니다. 두 가지 방식은 동등합니다!

리듀서를 사용하는 것이 좋은 이유는 컴포넌트에서 잘못된 상태 업데이트로 인해 자주 버그가 발생하는 경우이며, 코드에 더 많은 구조를 도입하고 싶을 때입니다. 모든 것을 리듀서로 처리할 필요는 없습니다. 자유롭게 혼합하여 사용할 수 있습니다. 심지어 동일한 컴포넌트에서 useState와 useReducer를 함께 사용할 수도 있습니다.

### 리듀서를 잘 작성하는 방법

리듀서를 작성할 때 다음 두 가지 팁을 기억하세요.

- **리듀서는 순수해야 합니다.** [상태 업데이터 함수](https://react.dev/learn/queueing-a-series-of-state-updates)와 마찬가지로 리듀서는 렌더링 중에 실행됩니다! (액션은 다음 렌더링까지 대기합니다.) 이것은 리듀서가 [순수](https://react.dev/learn/keeping-components-pure)해야 한다는 것을 의미합니다. 즉, 동일한 입력은 항상 동일한 출력을 생성해야 합니다. 요청을 보내거나 타임아웃을 예약하거나 컴포넌트 외부에 영향을 주는 작업(컴포넌트 외부의 것을 변경하는 작업)은 수행해서는 안 됩니다. 객체와 배열을 업데이트할 때는 변경하지 않고 업데이트해야 합니다.
- **각 액션은 사용자 상호작용 하나를 설명해야 합니다.** 예를 들어, 사용자가 폼의 다섯 개의 필드를 선택하고 "재설정"을 누르는 경우, 별도의 "필드 설정" 액션 대신 하나의 "폼 재설정" 액션을 디스패치하는 것이 더 의미가 있습니다. 리듀서에서 각 액션을 로그로 기록하면 해당 로그를 사용하여 상호작용 또는 응답이 어떤 순서로 발생했는지 재구성할 수 있어 디버깅에 도움이 됩니다!

### Immer를 사용하여 간결한 리듀서 작성하기

일반 상태 업데이트와 마찬가지로 리듀서를 더 간결하게 작성할 수 있는 Immer 라이브러리를 사용할 수 있습니다. 여기서 [useImmerReducer](https://github.com/immerjs/use-immer#useimmerreducer)를 사용하면 push 또는 `arr\[i\] =` 할당을 사용하여 상태를 직접 변경할 수 있습니다.


<iframe 
  src="https://codesandbox.io/embed/focused-mcclintock-mzl85w?fontsize=14&hidenavigation=1&theme=dark"
  style={{ width: "100%", height: "500px", border: "0", borderRadius: "4px", overflow: "hidden" }}
  title="focused-mcclintock-mzl85w"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

리듀서는 순수 함수이기 때문에 상태를 변경해서는 안 됩니다. 그러나 Immer는 변경해도 안전한 특별한 draft 객체를 제공합니다. 내부적으로 Immer는 draft에 수행한 변경 사항이 있는 상태의 사본을 만듭니다. 따라서 `useImmerReducer`로 관리되는 리듀서는 첫 번째 인수를 직접 변경할 수 있으며 상태를 반환할 필요가 없습니다.

### 요약

- useState에서 useReducer로 변환하려면 다음을 수행합니다.
  1. 이벤트 핸들러에서 액션을 디스패치합니다.
  2. 주어진 상태와 액션에 대한 다음 상태를 반환하는 리듀서 함수를 작성합니다.
  3. useState를 useReducer로 대체합니다.
- 리듀서는 더 많은 코드를 작성해야하지만 디버깅 및 테스트에 도움이 됩니다.
- 리듀서는 순수해야 합니다.
- 각 액션은 단일 사용자 상호작용을 설명해야 합니다.
- 변경 사항을 직접 반영하려는 경우 Immer를 사용할 수 있습니다.



## Context를 사용하여 데이터를 깊게 전달하기

일반적으로 부모 컴포넌트에서 자식 컴포넌트로 정보를 전달할 때는 props를 사용합니다. 그러나 많은 컴포넌트를 거쳐서 props를 전달해야 하거나 앱 내에서 많은 컴포넌트가 동일한 정보를 필요로 할 때는 props 전달이 장황하고 불편해질 수 있습니다. 컨텍스트를 사용하면 부모 컴포넌트가 아래 트리의 모든 컴포넌트에게 일부 정보를 제공할 수 있으며, 명시적으로 props를 전달하지 않아도 됩니다.

배울 내용

- "prop drilling"이란 무엇인지
- 반복되는 prop 전달을 컨텍스트로 대체하는 방법
- 컨텍스트의 일반적인 사용 사례
- 컨텍스트의 대체재

### props 전달의 문제점

[props 전달](https://react.dev/learn/passing-props-to-a-component)은 데이터를 UI 트리를 통해 명시적으로 파이프로 전달하여 해당 데이터를 사용하는 컴포넌트에 전달하는 좋은 방법입니다.

그러나 props 전달은 데이터를 트리를 따라 깊게 전달해야 하는 경우나 많은 컴포넌트가 동일한 props를 필요로 하는 경우에 장황하고 불편해질 수 있습니다. 가장 가까운 공통 조상은 데이터가 필요한 컴포넌트와 상당히 멀리 떨어져 있을 수 있으며, 해당 높이까지 상태를 "끌어올리는" 것은 "prop drilling"이라는 상황을 초래할 수 있습니다.

<div style={{ textAlign: "center" }}>
  <table style={{ borderCollapse: "collapse", border: "none" }}>
    <tr>
      <td style={{ border: "none", padding: "20px" }}>
        <img src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpassing_data_lifting_state.png&w=640&q=75" alt="React Sharing Data" width="400" height="auto" />
        <p style={{ margin: 0 }}>상태를 상위로 끌어올리기</p>
      </td>
      <td style={{ border: "none", padding: "20px" }}>
        <img src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpassing_data_prop_drilling.png&w=640&q=75" alt="React Sharing Data" width="400" height="auto" />
        <p style={{ margin: 0 }}>Prop 드릴링</p>
      </td>
    </tr>
  </table>
</div>


props를 전달하지 않고도 데이터를 필요로 하는 컴포넌트로 데이터를 "전송"할 수 있는 방법이 있으면 좋지 않을까요? React의 컨텍스트 기능을 사용하면 이를 할 수 있습니다!

### 컨텍스트: props 전달의 대체재

컨텍스트를 사용하면 부모 컴포넌트가 해당 트리 아래의 전체 트리에 데이터를 제공할 수 있습니다. 컨텍스트에는 여러 가지 사용 사례가 있습니다. 여기에 한 가지 예가 있습니다. 크기를 위한 레벨을 인수로 받는 이 Heading 컴포넌트를 고려해보세요:
<iframe src="https://codesandbox.io/embed/peaceful-newton-t1ku7s?fontsize=14&hidenavigation=1&theme=dark"
     style={{width:"100%", height:"500px", border:"0", borderRadius: "4px", overflow:"hidden"}}
     title="peaceful-newton-t1ku7s"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

동일한 Section 내에서 여러 개의 제목이 항상 동일한 크기를 가지도록 하려면:
<iframe src="https://codesandbox.io/embed/adoring-snowflake-wkp959?fontsize=14&hidenavigation=1&theme=dark"
     style={{width:"100%", height:"500px", border:"0", borderRadius: "4px", overflow:"hidden"}}
     title="adoring-snowflake-wkp959"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

현재 각 `<Heading>`에 별도로 level prop를 전달하고 있습니다:

```jsx
<Section>
  <Heading level={3}>About</Heading>
  <Heading level={3}>Photos</Heading>
  <Heading level={3}>Videos</Heading>
</Section>
```

대신, level prop를 `<Section>` 컴포넌트에 전달하고 `<Heading>`에서 제거하는 것이 좋을 것입니다. 이렇게 하면 동일한 섹션의 모든 제목이 동일한 크기를 갖도록 강제할 수 있습니다:

```jsx
<Section level={3}>
  <Heading>About</Heading>
  <Heading>Photos</Heading>
  <Heading>Videos</Heading>
</Section>
```

그러나 `<Heading>` 컴포넌트는 가장 가까운 `<Section>`의 레벨을 어떻게 알 수 있을까요? **이를 위해 자식이 트리 위쪽에서 데이터를 "요청"할 수 있는 방법이 필요합니다.**

props만으로는 할 수 없습니다. 여기서 컨텍스트가 필요해집니다. 다음 세 가지 단계를 거쳐 수행할 것입니다.

1. **컨텍스트를 생성합니다.** (Heading의 크기를 나타내는 컨텍스트이므로 LevelContext라고 부르겠습니다.)
2. **데이터를 필요로 하는 컴포넌트에서 해당 컨텍스트를 사용합니다.** (Heading은 LevelContext를 사용할 것입니다.)
3. **데이터를 지정하는 컴포넌트에서 해당 컨텍스트를 제공합니다.** (Section은 LevelContext를 제공할 것입니다.)

컨텍스트를 사용하면 부모 - 심지어 먼 곳에 위치한 부모 - 가 해당 트리 안의 모든 컴포넌트에 일부 데이터를 제공할 수 있습니다.

<div style={{ textAlign: 'center' }}>
  <table style={{ borderCollapse: 'collapse', border: 'none' }}>
    <tr>
      <td style={{ border: 'none', padding: '20px' }}>
        <img src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpassing_data_context_close.png&w=640&q=75" alt="React Sharing Data" width="400" height="auto" />
        <p style={{ margin: '0' }}>가까운 자식에서 컨텍스트 사용하기</p>
      </td>
      <td style={{ border: 'none', padding: '20px' }}>
        <img src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fpassing_data_context_far.png&w=640&q=75" alt="React Sharing Data" width="400" height="auto" />
        <p style={{ margin: '0' }}>먼 자식에서 컨텍스트 사용하기</p>
      </td>
    </tr>
  </table>
</div>

#### 단계 1: 컨텍스트 생성

먼저 컨텍스트를 생성해야 합니다. 컴포넌트에서 사용할 수 있도록 컨텍스트를 **파일에서 내보내야 합니다**:
<iframe src="https://codesandbox.io/embed/angry-thunder-x59dv2?fontsize=14&hidenavigation=1&theme=dark"
     style={{width:"100%", height:"500px", border:0, borderRadius: "4px", overflow:"hidden"}}
     title="angry-thunder-x59dv2"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

createContext의 유일한 인수는 기본 값입니다. 여기에서는 1이 가장 큰 제목 레벨을 나타내지만 어떤 종류의 값(객체조차도)을 전달할 수 있습니다. 다음 단계에서 기본 값의 의미를 알게될 것입니다.


#### 단계 2: 컨텍스트 사용

React에서 useContext Hook과 컨텍스트를 가져옵니다:

```jsx
import { useContext } from 'react';
import { LevelContext } from './LevelContext.js';
```

현재 Heading 컴포넌트는 props에서 level을 읽습니다:

```jsx
export default function Heading({ level, children }) {
  // ...
}
```

대신, level prop을 제거하고 방금 가져온 LevelContext에서 값을 읽도록 변경합니다:

```jsx
export default function Heading({ children }) {
  const level = useContext(LevelContext);
  // ...
}
```

useContext는 Hook입니다. useState와 useReducer와 마찬가지로 Hook은 React 컴포넌트 내에서만 즉시 호출할 수 있습니다(루프나 조건문 내에서는 호출할 수 없습니다). **useContext는 Heading 컴포넌트가 LevelContext를 읽고자 한다는 것을 React에 알려줍니다.**

Heading 컴포넌트에 level prop이 없으므로 다음과 같이 JSX에서 Heading에 level prop을 더 이상 전달할 필요가 없습니다:

```jsx
<Section>
  <Heading level={4}>Sub-sub-heading</Heading>
  <Heading level={4}>Sub-sub-heading</Heading>
  <Heading level={4}>Sub-sub-heading</Heading>
</Section>
```

대신, JSX를 업데이트하여 Section이 level prop을 전달받도록 변경합니다:

```jsx
<Section level={4}>
  <Heading>Sub-sub-heading</Heading>
  <Heading>Sub-sub-heading</Heading>
  <Heading>Sub-sub-heading</Heading>
</Section>
```

<iframe src="https://codesandbox.io/embed/goofy-water-28ue9u?fontsize=14&hidenavigation=1&theme=dark"
     style={{width:"100%", height:"500px", border:0, borderRadius: "4px", overflow:"hidden"}}
     title="goofy-water-28ue9u"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

알림: 이 예제는 중첩된 컴포넌트가 컨텍스트를 재정의하는 방식을 시각적으로 보여주기 위해 제목 레벨을 사용합니다. 그러나 컨텍스트는 시각적인 표시 외에도 많은 다른 사용 사례에 유용합니다. 전체 하위 트리가 필요로하는 모든 정보를 전달할 수 있습니다. 예를 들어, 현재의 색상 테마, 현재 로그인한 사용자 등을 전달할 수 있습니다.

#### 단계 3: 컨텍스트 제공

Section 컴포넌트는 현재 자식을 렌더링합니다:

```jsx
export default function Section({ children }) {
  return (
    <section className="section">
      {children}
    </section>
  );
}
```

컨텍스트 프로바이더로 자식을 감싸 컨텍스트(LevelContext)를 제공합니다:

```jsx
import { LevelContext } from './LevelContext.js';

export default function Section({ level, children }) {
  return (
    <section className="section">
      <LevelContext.Provider value={level}>
        {children}
      </LevelContext.Provider>
    </section>
  );
}
```

이렇게 하면 React에게 "이 `<Section>` 내부의 모든 컴포넌트가 LevelContext를 요청하면 해당 level을 제공하세요." 라고 알려줍니다. 컴포넌트는 UI 트리에서 가장 가까운 `<LevelContext.Provider>`의 값으로 사용합니다.

<iframe src="https://codesandbox.io/embed/vibrant-worker-pthbl3?fontsize=14&hidenavigation=1&theme=dark"
     style={{width:"100%", height:"500px", border:0, borderRadius: "4px", overflow:"hidden"}}
     title="vibrant-worker-pthbl3"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

원래 코드와 동일한 결과이지만, 각 Heading 컴포넌트에 level prop을 전달할 필요가 없었습니다! 대신, Heading은 그 위에 있는 가장 가까운 Section에게 레벨을 "알아내기" 위해 요청했습니다:

1. level prop을 `<Section>`에 전달합니다.
2. Section은 자식을 `<LevelContext.Provider value={level}>`로 감쌉니다.
3. Heading은 `useContext(LevelContext)`를 사용하여 위로부터 가장 가까운 LevelContext 값을 요청합니다.


### 동일한 컴포넌트에서 컨텍스트 사용과 제공

현재는 각 섹션의 레벨을 수동으로 지정해야 합니다:

```jsx
export default function Page() {
  return (
    <Section level={1}>
      ...
      <Section level={2}>
        ...
        <Section level={3}>
          ...
```

컨텍스트를 사용하면 각 Section이 이전 Section에서 레벨을 읽고 레벨 + 1을 자동으로 전달할 수 있습니다. 다음과 같이 수행할 수 있습니다:

```jsx
import { useContext } from 'react';
import { LevelContext } from './LevelContext.js';

export default function Section({ children }) {
  const level = useContext(LevelContext);
  return (
    <section className="section">
      <LevelContext.Provider value={level + 1}>
        {children}
      </LevelContext.Provider>
    </section>
  );
}
```

이 변경 사항으로 `<Section>` 또는 `<Heading>`에 level prop을 전달할 필요가 없어졌습니다:
```
<iframe src="https://codesandbox.io/embed/nice-albattani-j0w3hj?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="nice-albattani-j0w3hj"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>
```
이제 Heading과 Section은 자신의 주변 상황에 따라 어떻게 표시되는지 조정하기 위해 LevelContext를 읽습니다. 그리고 Section은 자식을 LevelContext로 감싸 어떤 것이 "더 깊은" 레벨인지를 지정합니다.

> 참고  
이 예제에서는 중첩된 컴포넌트가 컨텍스트를 재정의하는 방식을 시각적으로 보여주기 위해 제목 레벨을 사용합니다. 그러나 컨텍스트는 테마 지정, 현재 로그인한 사용자 등 많은 다른 사용 사례에 유용합니다. 전체 트리의 다른 부분에서 필요로 하는 정보가 있는 경우 컨텍스트가 도움이 될 것입니다.


### 컨텍스트는 중간 컴포넌트를 통과합니다

컨텍스트를 제공하는 컴포넌트와 사용하는 컴포넌트 사이에 원하는 만큼 많은 컴포넌트를 삽입할 수 있습니다. 이에는 `<div>`와 같은 내장 컴포넌트와 직접 작성한 컴포넌트 모두 포함됩니다.

이 예에서는 동일한 Post 컴포넌트(점선 테두리)가 서로 다른 중첩 레벨에서 렌더링됩니다. 그 내부의 `<Heading>`은 가장 가까운 `<Section>`에서 자동으로 레벨을 얻습니다:
```
<iframe src="https://codesandbox.io/embed/vibrant-gauss-t457ob?fontsize=14&hidenavigation=1&theme=dark"
     style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;"
     title="vibrant-gauss-t457ob"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
   ></iframe>
```
이것을 작동시키기 위해 특별히 할 것은 없습니다. Section은 내부 트리에 대한 컨텍스트를 지정하므로 `<Heading>`을 어디에든 삽입할 수 있고 올바른 크기를 가집니다. 상단의 샌드박스에서 확인해보세요!

**컨텍스트를 사용하면 컴포넌트를 "주변에 맞게 조정"하여 렌더링되는 위치(다시 말해, 어떤 컨텍스트에서 렌더링되는지)에 따라 다르게 표시할 수 있습니다.**

컨텍스트가 동작 방식이 [CSS 속성 상속](https://developer.mozilla.org/en-US/docs/Web/CSS/inheritance)을 연상시킬 수 있습니다. CSS에서는 `<div>`에 `color: blue`를 지정하면 얼마든지 깊게 위치한 DOM 노드도 다른 DOM 노드가 중간에 `color: green`으로 재정의하지 않는 한 해당 색상을 상속합니다. 마찬가지로 React에서도 위에서 내려오는 컨텍스트를 재정의하는 유일한 방법은 다른 값을 가진 컨텍스트 제공자로 자식을 감싸는 것입니다.

CSS에서 색상(color)과 배경색(background-color)과 같은 다른 속성은 서로를 덮어쓰지 않습니다. 모든 `<div>`의 색상을 red로 설정하면 배경색에는 영향을 주지 않습니다. 마찬가지로 **다른 React 컨텍스트도 서로를 덮어쓰지 않습니다.** `createContext()`로 만든 각 컨텍스트는 완전히 다른 것으로 간주되며 해당 컨텍스트를 사용하거나 제공하는 컴포넌트를 연결시킵니다. 한 컴포넌트가 문제없이 여러 다른 컨텍스트를 사용하거나 제공할 수 있습니다.



### 컨텍스트를 사용하기 전에

컨텍스트는 사용하면 매우 유혹적입니다! 그러나 이것은 동시에 너무 쉽게 과용할 수 있는 것을 의미합니다. **일부 props를 여러 수준으로 전달해야 한다고 해서 그 정보를 컨텍스트에 넣어야 하는 것은 아닙니다.**

컨텍스트를 사용하기 전에 고려해야 할 몇 가지 대안이 있습니다:

1. **우선은 [props를 전달](https://react.dev/learn/passing-props-to-a-component)해 보세요.** 컴포넌트가 간단하지 않은 경우 수십 개의 props를 수십 개의 컴포넌트를 통해 전달하는 것은 보통입니다. 번거롭게 느껴질 수 있지만, 어떤 데이터를 사용하는지를 명확히 표시하여 코드를 유지보수하는 사람에게 큰 도움이 될 것입니다.
    3. children을 `<MyContext.Provider value={...}>`로 감싸서 상위에서 제공합니다.
    3. children을 `<MyContext.Provider value={...}>`로 감싸서 상위에서 제공합니다.
2. **컴포넌트를 추출하고 [JSX를 자식으로 전달](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children)하세요.** 데이터를 사용하지 않는 중간 컴포넌트의 많은 수준을 통해 데이터를 전달하는 경우, 그 중간에 컴포넌트를 추출하는 것을 잊은 경우가 많습니다. 예를 들어, `<Layout posts={posts} />`와 같이 posts와 같은 데이터 props를 직접 사용하지 않는 시각적인 컴포넌트에 데이터 props를 전달할 수 있습니다. 대신, Layout이 children을 하나의 prop으로 받도록 만들고, `<Layout><Posts posts={posts} /></Layout>`를 렌더링합니다. 이렇게 하면 데이터를 지정하는 컴포넌트와 해당 데이터가 필요한 컴포넌트 간의 계층 수가 줄어듭니다.

위 두 가지 방법이 잘 작동하지 않는 경우 컨텍스트를 고려하세요.


### 컨텍스트의 사용 사례

- **테마 지정:** 사용자가 앱의 외관을 변경할 수 있는 경우(예: 다크 모드), 앱의 맨 위에 컨텍스트 제공자를 놓고 시각적인 모양을 조정해야 하는 컴포넌트에서 해당 컨텍스트를 사용할 수 있습니다.
- **현재 계정:** 많은 컴포넌트가 현재 로그인한 사용자를 알아야 할 수도 있습니다. 컨텍스트에 넣어 어디에서든 해당 정보를 편리하게 읽을 수 있습니다. 일부 앱은 동시에 여러 계정(예: 다른 사용자로 댓글 남기기)을 사용할 수도 있습니다. 이러한 경우 일부 UI를 다른 현재 계정 값으로 감싸는 중첩된 프로바이더를 만드는 것이 편리할 수 있습니다.
- **라우팅:** 대부분의 라우팅 솔루션은 현재 경로를 저장하기 위해 내부적으로 컨텍스트를 사용합니다. 이것은 링크가 활성화되었는지 여부를 알기 위해 필요합니다. 직접 라우터를 작성하는 경우 이와 같이 사용할 수 있습니다.
- **상태 관리:** 앱이 커지면 상태가 앱의 상위에 가까이 있게 될 수 있습니다. 그 아래에 있는 많은 먼 컴포넌트가 상태를 변경해야 할 수도 있습니다. 복잡한 상태를 관리하고 너무 많은 문제 없이 먼 컴포넌트에 전달하기 위해 일반적으로 [리듀서와 컨텍스트를 함께 사용](https://react.dev/learn/scaling-up-with-reducer-and-context)합니다.

컨텍스트는 정적인 값에만 제한되지 않습니다. 다음 렌더링에 다른 값을 전달하면 React가 아래에서 해당 값을 읽는 모든 컴포넌트를 업데이트합니다. 이러한 이유로 컨텍스트는 종종 상태와 결합하여 사용됩니다.

일반적으로 트리의 여러 부분에서 필요로 하는 정보가 있다면 컨텍스트가 도움이 될 수 있습니다.



### 요약

- 컨텍스트를 사용하면 부모 컴포넌트가 해당 트리 전체에 일부 정보를 제공할 수 있습니다.
- 컨텍스트를 전달하려면:
    1. `export const MyContext = createContext(defaultValue)`와 같이 생성하고 내보냅니다.
    2. `useContext(MyContext)` Hook을 사용하여 자식 컴포넌트에서 읽습니다(깊이에 상관없이).
    3. children을 `<MyContext.Provider value={...}>`로 감싸서 상위에서 제공합니다.
- 컨텍스트는 중간 컴포넌트를 통과합니다.
- 컨텍스트를 사용하여 "주변에 맞게 조정"되는 컴포넌트를 작성할 수 있습니다.
- 컨텍스트를 사용하기 전에 props를 전달하거나 JSX를 children으로 전달하는 것을 시도해보세요.






## 리듀서와 컨텍스트를 활용하여 확장하기




