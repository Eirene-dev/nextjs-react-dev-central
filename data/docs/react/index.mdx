---
title: React
description: React는 웹 및 네이티브 사용자 인터페이스를 위한 라이브러리입니다.
---

React는 Facebook에서 개발한 JavaScript 라이브러리로, 특히 싱글 페이지 애플리케이션을 위해 널리 사용됩니다. 애플리케이션의 각 상태에 대한 간단한 뷰를 설계하고, React는 데이터 변경 시 효율적으로 업데이트하고 적절한 컴포넌트를 렌더링합니다.

React의 주요 특징을 간단히 살펴보겠습니다:

1. **컴포넌트 기반:** React 코드는 컴포넌트라는 개체로 구성됩니다. 컴포넌트는 JavaScript 클래스나 함수로 이루어져 있으며, 속성(props)을 입력으로 받고 UI의 어느 부분이 나타나야 하는지를 설명하는 React 요소를 반환합니다.

2. **선언적:** React는 개발자가 데이터 변경에 자동으로 맞춰지는 뷰를 작성할 수 있게 합니다. 애플리케이션의 각 상태에 대해 간단한 뷰를 설계하면, 데이터가 변경될 때 React 프레임워크가 적절한 컴포넌트를 업데이트하고 렌더링합니다. 이 접근 방식은 코드를 더 가독성 있게 만들어 디버깅이 쉬워집니다.

3. **가상 DOM:** React는 실제 DOM의 가벼운 복사본인 가상 DOM을 생성합니다. 객체의 상태가 변경되면 React는 가상 DOM에 작업을 수행합니다. 그런 다음 이전 가상 DOM과 새로운 가상 DOM의 차이를 비교하고(차이 비교라는 과정), 실제 DOM에서 실제로 변경된 부분만 업데이트합니다. 이 과정을 조정(reconciliation)이라고 합니다.

4. **단방향 데이터 바인딩과 Flux:** React는 단방향 데이터 흐름을 구현하여 애플리케이션을 이해하기 쉽게 만듭니다. Flux는 데이터의 단방향 유지를 돕는 패턴입니다. 이는 React 앱을 설계할 때 종종 부모 컴포넌트 내에 자식 컴포넌트를 중첩시킴으로써 구현됩니다.

React 자체는 라우팅이나 전역 상태 관리와 같은 기능을 포함하지 않는 컴포저블한 사용자 인터페이스를 구축하기 위한 라이브러리입니다. 그러나 React는 Redux와 같은 추가적인 라이브러리를 사용하여 상태 관리 또는 React-Router를 사용하여 라우팅과 함께 자주 사용됩니다. 
 
 React는 성능, 컴포넌트의 재사용성 및 넓은 생태계로 인해 개발자들 사이에서 매우 인기가 있습니다. 이는 Facebook과 개인 개발자, 기업의 커뮤니티에 의해 유지되고 있습니다.


## React 특징

### 컴포넌트로부터 사용자 인터페이스 생성하기

React는 Thumbnail, LikeButton, Video와 같은 개별적인 조각들을 컴포넌트라고 부르며, 이들을 조합하여 전체 화면, 페이지, 앱을 만들 수 있도록 해줍니다. 자신만의 React 컴포넌트를 생성하고 이들을 결합하여 사용자 인터페이스를 구성할 수 있습니다.

![](https://wikidocs.net/images/page/203295/0_1_1.png)

혼자 작업하든 수천 명의 다른 개발자와 함께 작업하든, React를 사용하면 동일한 느낌을 받을 수 있습니다. React는 독립된 사람들, 팀 및 조직이 작성한 컴포넌트를 원활하게 결합할 수 있도록 설계되었습니다. 이를 통해 다른 사람들이 작성한 컴포넌트를 자유롭게 조합할 수 있습니다.

### 코드와 마크업을 사용하여 컴포넌트 작성하기

React 컴포넌트는 JavaScript 함수입니다. 어떤 내용을 조건부로 표시하고 싶을 때는 if 문을 사용하세요. 목록을 표시하고 싶을 때는 array map()을 사용해보세요. React를 배우는 것은 프로그래밍을 배우는 것과 동일합니다.
![](https://wikidocs.net/images/page/203295/0_1_2.png)

이 마크업 구문은 JSX라고 불립니다. 이는 React에 의해 인기를 얻은 JavaScript 구문 확장입니다. JSX 마크업을 관련 렌더링 로직 근처에 배치하는 것은 React 컴포넌트를 쉽게 생성, 유지 및 삭제할 수 있도록 해줍니다.

### 필요한 곳마다 상호작용성(interactivity)을 추가하세요.

React 컴포넌트는 데이터를 받아들이고 화면에 표시해야 할 내용을 반환합니다. 사용자가 입력란에 입력하는 등의 상호작용에 대응하여 새로운 데이터를 컴포넌트에 전달할 수 있습니다. 그러면 React는 화면을 새로운 데이터와 일치하도록 업데이트합니다.
![](https://wikidocs.net/images/page/203295/0_1_3.png)

페이지 전체를 React로 구축할 필요는 없습니다. 기존의 HTML 페이지에 React를 추가하고, 인터랙티브한 React 컴포넌트를 어디에서든 렌더링할 수 있습니다.

## 빠르게 시작해 보기

이 페이지에서는 매일 사용할 80%의 React 개념에 대해 소개해 드립니다.


### 주요 내용 소개
이 페이지는 React 시작을 위한 깊이 있는 안내서를 찾을 수 있으며, 일상적으로 마주치게 되는 모든 기본 개념을 다룹니다. 몇 가지 주요한 포인트를 요약해 보겠습니다:

1. **컴포넌트 생성 및 중첩**: React 앱은 컴포넌트로 구성되며, 버튼처럼 작을 수도 있고 전체 페이지와 같이 큰 컴포넌트일 수도 있습니다. 컴포넌트는 JSX 문법을 사용하여 마크업을 반환하는 JavaScript 함수입니다.
2. **JSX와 스타일링**: React의 마크업 구문은 JSX라고 합니다. JSX는 HTML보다 엄격하며, 모든 태그를 닫아야 합니다. 스타일링을 위해 `className` 속성을 사용하여 CSS 클래스를 지정할 수 있습니다.
3. **데이터 표시**: React는 JSX 코드 내에서 중괄호를 사용하여 JavaScript 표현식을 삽입할 수 있습니다. 이를 통해 JavaScript 코드의 변수를 기반으로 동적으로 데이터를 표시할 수 있습니다.
4. **조건부 렌더링**: React는 조건부 렌더링을 위한 특별한 구문이 없습니다. 대신, 일반적인 JavaScript if-else 문이나 삼항 연산자를 사용하여 특정 조건에 따라 어떤 컴포넌트나 요소를 렌더링할지 결정합니다.
5. **리스트 렌더링**: React는 데이터 배열을 매핑하여 JSX 요소의 배열을 생성하여 컴포넌트의 목록을 렌더링할 수 있습니다. 이때 `key` 속성을 사용하여 목록의 각 요소를 고유하게 식별합니다.
6. **이벤트 처리**: React는 클릭, 입력 변경, 폼 제출 등 사용자 이벤트에 응답할 수 있습니다. 이를 위해 컴포넌트 내에서 이벤트 핸들러 함수를 정의합니다.
7. **상태 관리**: React는 `useState` 훅을 사용하여 컴포넌트 내에서 로컬 상태를 관리합니다. 상태는 시간이 지남에 따라 변경될 수 있는 데이터 조각이며, 변경되면 컴포넌트가 업데이트된 상태로 다시 렌더링됩니다.
8. **상태 끌어올리기**: 여러 컴포넌트가 동일한 데이터를 공유하고 조작해야 할 때는 상태를 가장 가까운 공통 조상으로 끌어올립니다. 그런 다음 이 상태를 자식 컴포넌트에 props로 전달할 수 있습니다.

이것은 시작에 불과하며, React에는 컨텍스트, 레퍼런스, 라이프사이클 메서드, 고차 컴포넌트, 렌더 프롭스 등의 고급 기능과 개념이 더 있으며, 이러한 내용을 공식 문서에서 자세히 알아볼 수 있습니다.


### 컴포넌트 생성 및 중첩

React 앱은 컴포넌트로 구성됩니다. 컴포넌트는 자체적인 로직과 외관을 가진 UI(사용자 인터페이스)의 한 부분입니다. 컴포넌트는 버튼과 같이 작을 수도 있고 전체 페이지와 같이 클 수도 있습니다.

React 컴포넌트는 마크업을 반환하는 JavaScript 함수입니다:

```javascript
function MyButton() {
  return (
    <button>I'm a button</button>
  );
}
```

이제 MyButton을 다른 컴포넌트에 중첩할 수 있습니다:

```javascript
export default function MyApp() {
  return (
    <div>
      <h1>내 앱에 오신 것을 환영합니다</h1>
      <MyButton />
    </div>
  );
}
```

`<MyButton />`이 대문자로 시작함에 유의하세요. 이렇게 하면 React 컴포넌트라는 것을 알 수 있습니다. React 컴포넌트 이름은 항상 대문자로 시작해야 하며, HTML 태그는 소문자여야 합니다.

결과를 확인해보세요:

<iframe 
  src="https://codesandbox.io/embed/upbeat-violet-fxbh5x?autoresize=1&fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%', 
    height: '500px', 
    border: '0', 
    borderRadius: '4px', 
    overflow: 'hidden'
  }}
  title="upbeat-violet-fxbh5x"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

 
 
 `export default` 키워드는 파일에서 주요 컴포넌트를 지정합니다. JavaScript 구문에 익숙하지 않은 경우, MDN과 javascript.info에서 훌륭한 참조 자료를 제공합니다.
 



<Callout>
**`export default`**

`export default`는 JavaScript에서 사용되는 키워드로, JavaScript 모듈에서 단일 클래스, 함수 또는 기본 타입(primitive)을 내보낼 때 사용됩니다. 이는 ES6 모듈 시스템의 일부입니다.

이 키워드는 내보낸 값을 모듈의 기본 내보내기(default export)로 만듭니다. 이는 이 모듈이 다른 파일에서 가져올 때, 특정한 가져오기(import)가 요청되지 않은 경우에 자동으로 가져오는 기본 내보낸 값이 됩니다.

JavaScript의 `export default` 키워드는 모듈에 "별명"을 부여하여 해당 모듈을 다른 코드에서 가져오고 사용하기 쉽게 만듭니다. `export default`를 사용하면 다음과 같이 말하는 것입니다: "이것은 이 모듈에서 내보내려는 주요 항목이며, 가져오기가 간편해야 합니다."

일반적인 영어로 비유해 보겠습니다. 책을 쓰는 작가라고 상상해보세요. 일반적으로 책에는 여러 장(chapter)이 있을 수 있지만, 보통 한 가지 주요 제목이 있습니다("전쟁과 평화"나 "위대한 개츠비"와 같이). 이 주요 제목은 JavaScript에서의 `export default`와 유사합니다. 즉, 사람들이 책을 언급할 때 주로 사용하는 방식입니다.

이제 여러 권의 책으로 이루어진 도서관을 생각해보세요. 특정한 책을 찾을 때, 당신은 개별 장의 제목이 아닌 주요 제목으로 요청합니다. 마찬가지로 JavaScript에서 `export default`를 사용하면, 다른 모듈로 가져올 때 해당 모듈을 기본 이름으로 쉽게 요청할 수 있습니다.

예를 들어, `myFunction.js`라는 모듈에서 다음과 같은 코드가 있다고 가정해봅시다:

```javascript
export default function myFunction() {
  return "Hello, world!";
}
```

다른 파일에서는 다음과 같이 이 함수를 쉽게 가져와 사용할 수 있습니다:

```javascript
import greet from './myFunction';

console.log(greet());  // 출력: Hello, world!
```

`greet`는 이제 `myFunction.js`에서 내보낸 기본 함수의 "별명"입니다. `export default` 키워드를 사용하면 코드의 다른 위치에서 이 함수를 가져와 사용하기가 매우 편리해집니다.

이는 명명된 내보내기와 다릅니다. 명명된 내보내기에서는 모듈에서 가져올 내용을 정확히 지정해야 합니다. `export default`에서는 모듈의 주요 내보내기에 대한 편리한 "별명"을 제공합니다.

`export default`와 명명된 내보내기(named export)를 동일한 모듈에서 함께 사용할 수 있으며, 이를 통해 기본 내보내기와 명명된 내보내기 모두를 제공할 수 있습니다.
</Callout>

### JSX를 사용한 마크업 작성

위에서 보았던 마크업 구문을 JSX라고 합니다. 이는 선택적이지만, 대부분의 React 프로젝트는 편의성을 위해 JSX를 사용합니다. 로컬 개발을 위해 권장하는 모든 도구는 JSX를 기본적으로 지원합니다.

JSX는 HTML보다 엄격합니다. `<br />`과 같이 태그를 닫아야 합니다. 컴포넌트는 또한 여러 개의 JSX 태그를 반환할 수 없습니다. 이를 공유 부모(`<div>`...`</div> `또는 빈 `< >`...`< / >` 래퍼)로 묶어야 합니다:

```javascript
function AboutPage() {
  return (
    <>
      <h1>About</h1>
      <p>Hello there.<br />How do you do?</p>
    </>
  );
}
```

JSX로 변환할 HTML이 많은 경우 온라인 변환 도구 를 사용할 수 있습니다.


#### HTML to JSX 변환 도구
> https://transform.tools/html-to-jsx
<iframe src="https://transform.tools/html-to-jsx" width="100%" height="500px"></iframe>


### 스타일 추가

React에서는 className으로 CSS 클래스를 지정합니다. 이는 HTML의 [class](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/class) 속성과 동일한 방식으로 작동합니다:

```html
<img className="avatar" />
```

그런 다음 별도의 CSS 파일에서 해당 클래스에 대한 CSS 규칙을 작성합니다:

```css
/* CSS 파일에 작성 */
.avatar {
  border-radius: 50%;
}
```

React는 CSS 파일을 추가하는 방법을 명시하지 않습니다. 가장 간단한 경우, HTML에 [`<link>` 태그](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/link)를 추가합니다. 빌드 도구나 프레임워크를 사용하는 경우, 해당 문서를 참조하여 프로젝트에 CSS 파일을 추가하는 방법을 알아보세요.

#### React 프로젝트에 CSS 파일을 추가하는 방법
React 프로젝트에 CSS 파일을 추가하는 방법은 몇 가지 단계로 수행할 수 있습니다:

1. 먼저, 스타일을 적용하려는 React 컴포넌트와 동일한 디렉토리에 CSS 파일을 생성합니다. 컴포넌트 파일의 이름이 `MyComponent.js`라면, CSS 파일의 이름을 `MyComponent.css`로 지정할 수 있습니다.

2. 다음으로, React 컴포넌트 파일(`MyComponent.js`)에서 파일 상단에 CSS 파일을 import합니다. 이는 `import` 키워드와 CSS 파일의 경로를 사용하여 수행됩니다.

다음은 예시입니다:

다음과 같은 프로젝트 구조를 가정해 봅시다:

```bash
/my-app
  /src
    /components
      MyComponent.js
      MyComponent.css
```

그리고 `MyComponent.css` 파일에 몇 가지 스타일이 포함되어 있다고 가정해 봅시다:

```css
.container {
  margin: auto;
  width: 50%;
  border: 3px solid green;
  padding: 10px;
}
```

그럼, `MyComponent.js` 파일에서 이 CSS 파일을 다음과 같이 import합니다:

```jsx
import React from 'react';
import './MyComponent.css';  // CSS를 import합니다.

function MyComponent() {
  return (
    <div className="container">
      <h1>Hello, World!</h1>
    </div>
  );
}

export default MyComponent;
```

이렇게 하면 `MyComponent` 컴포넌트의 div에 있는 `.container` 클래스 스타일이 `MyComponent.css`에서 적용됩니다.

참고로, 이 방법은 Create-React-App, Next.js 등과 같은 프레임워크에서 기본적으로 작동합니다. 이러한 프레임워크는 CSS를 처리하는 webpack 로더가 이미 구성되어 있습니다. 하지만 프로젝트를 처음부터 설정하거나 다른 환경에서 작업하는 경우에는 `css-loader`와 `style-loader`와 같은 로더를 구성해야 할 수도 있습니다. 또는 styled-components와 같은 CSS-in-JS 라이브러리를 사용할 수도 있습니다.

## 데이터 표시

JSX를 사용하면 JavaScript 내에 마크업을 넣을 수 있습니다. 중괄호를 사용하여 코드의 변수를 포함하여 사용자에게 표시할 수 있습니다. 예를 들어, 다음은 `user.name`을 표시합니다:

```javascript
return (
  <h1>
    {user.name}
  </h1>
);
```

JSX 속성에서도 중괄호를 사용하여 JavaScript로 "이스케이프"할 수 있지만, 따옴표 대신 중괄호를 사용해야 합니다. 예를 들어, `className="avatar"`는 `"avatar"` 문자열을 CSS 클래스로 전달하지만, `src={user.imageUrl}`은 JavaScript의 `user.imageUrl` 변수 값을 읽고 해당 값을 `src` 속성으로 전달합니다:

```javascript
return (
  <img
    className="avatar"
    src={user.imageUrl}
  />
);
```

JSX 중괄호 안에는 [문자열 연결](https://javascript.info/operators#string-concatenation-with-binary)과 같은 복잡한 표현식도 넣을 수 있습니다.

<iframe 
  src="https://codesandbox.io/embed/dazzling-kalam-6qm5em?autoresize=1&fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%', 
    height: '500px', 
    border: '0', 
    borderRadius: '4px', 
    overflow: 'hidden'
  }}
  title="dazzling-kalam-6qm5em"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

  위의 예제에서 `style={{}}`는 특별한 구문이 아니라, `style={ }` JSX 중괄호 내부의 일반 `{}` 객체입니다. 스타일이 JavaScript 변수에 따라 달라지는 경우 `style` 속성을 사용할 수 있습니다.

### 조건부 렌더링

React에서 조건을 작성하는 특별한 구문은 없습니다. 대신 일반적인 JavaScript 코드를 작성할 때 사용하는 기술을 사용합니다. 예를 들어, JSX를 조건부로 포함시키려면 [`if` 문](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else)을 사용할 수 있습니다:

```javascript
let content;
if (isLoggedIn) {
  content = <AdminPanel />;
} else {
  content = <LoginForm />;
}
return (
  <div>
    {content}
  </div>
);
```

더 간결한 코드를 선호하는 경우, [조건부 `?` 연산자](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Conditional_Operator)를 사용할 수 있습니다. `if`와 달리 JSX 내부에서 작동합니다:

```javascript
<div>
  {isLoggedIn ? (
    <AdminPanel />
  ) : (
    <LoginForm />
  )}
</div>
```

`else` 분기가 필요하지 않은 경우, 더 짧은 논리 [`&&` 구문](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Logical_AND#short-circuit_evaluation)을 사용할 수도 있습니다:

```javascript
<div>
  {isLoggedIn && <AdminPanel />}
</div>
```

이러한 접근 방식은 속성을 조건부로 지정하는 데에도 동일하게 적용됩니다. JavaScript 구문에 익숙하지 않은 경우, 항상 `if...else`를 사용하는 것으로 시작할 수 있습니다.

### 목록 렌더링

구성 요소의 목록을 렌더링하기 위해 [`for` 루프](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for)와 배열의 [`map()` 함수](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)와 같은 JavaScript 기능을 활용할 것입니다.

예를 들어, 제품의 배열이 있다고 가정해봅시다:

```javascript
const products = [
  { title: '배추', id: 1 },
  { title: '마늘', id: 2 },
  { title: '사과', id: 3 },
];
```

컴포넌트 내부에서 `map()` 함수를 사용하여 제품 배열을 `<li>` 항목의 배열로 변환합니다:

```javascript
const listItems = products.map(product =>
  <li key={product.id}>
    {product.title}
  </li>
);

return (
  <ul>{listItems}</ul>
);
```

`<li>`에는 key 속성이 있음에 유의하세요. 목록의 각 항목마다 형제들 중에서 해당 항목을 고유하게 식별하는 문자열 또는 숫자를 전달해야 합니다. 일반적으로 키는 데이터로부터 가져온 데이터베이스 ID와 같은 값이어야 합니다. React는 키를 사용하여 항목을 나중에 삽입, 삭제 또는 재정렬할 때 어떤 일이 발생했는지 알 수 있습니다.

<iframe 
  src="https://codesandbox.io/embed/dazzling-kalam-6qm5em?autoresize=1&fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%', 
    height: '500px', 
    border: '0', 
    borderRadius: '4px', 
    overflow: 'hidden'
  }}
  title="dazzling-kalam-6qm5em"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


## 이벤트에 응답하기  
컴포넌트 내부에서 이벤트 핸들러 함수를 선언함으로써 이벤트에 응답할 수 있습니다:

```javascript
function MyButton() {
  function handleClick() {
    alert('You clicked me!');
  }

  return (
    <button onClick={handleClick}>
      Click me
    </button>
  );
}
```

`onClick={handleClick}`에서 마지막에 괄호가 없음에 주목하세요! 이벤트 핸들러 함수를 호출하지 마세요. 함수를 전달하기만 하면 됩니다. React는 사용자가 버튼을 클릭할 때 이벤트 핸들러를 호출합니다.

<Callout>
**React 이벤트**

React에서 이벤트는 사용자 상호작용, 시스템 업데이트 및 브라우저 트리거와 같은 다양한 동작에 의해 트리거됩니다. React 요소에서 이벤트를 처리하는 방법은 DOM 요소에서 이벤트를 처리하는 방법과 매우 유사하지만 구문과 동작에는 몇 가지 차이가 있습니다:

- **대소문자 구분**: React 이벤트는 소문자 대신 camelCase로 작성됩니다.

```javascript
<button onClick={myFunction}>Click me</button>
```

- **이벤트 핸들러는 함수**: JSX에서 이벤트 핸들러는 문자열 대신 함수를 전달합니다.

```javascript
function myFunction() {
    alert('Button clicked!');
}
```

- **이벤트 객체**: 이벤트를 처리하는 함수를 정의할 때, React는 해당 함수에 이벤트 객체를 전달합니다. 이 이벤트 객체는 네이티브 HTML 이벤트 객체와 동일한 속성과 메서드를 갖지만, 모든 브라우저에서 동일하게 작동합니다 (React는 브라우저의 네이티브 이벤트를 SyntheticEvent로 감싸서 사용합니다).

```javascript
function handleClick(e) {
    e.preventDefault();
    console.log('The link was clicked.');
}
```

- **`this`에 대한 접근**: JavaScript 클래스에서는 기본적으로 메서드가 바인딩되지 않습니다. `this.handleClick`을 바인딩하지 않고 `onClick`에 전달하면 함수가 호출될 때 `this`는 `undefined`가 됩니다. 이는 React에 특정한 동작이 아니라 JavaScript에서 함수가 작동하는 방식의 일부입니다.

```javascript
class Toggle extends React.Component {
    constructor(props) {
        super(props);
        this.state = {isToggleOn: true};

        // 이 바인딩은 콜백에서 `this`가 작동하도록 필요합니다.
        this.handleClick = this.handleClick.bind(this);
    }

    handleClick() {
        this.setState(state => ({
            isToggleOn: !state.isToggleOn
        }));
    }

    render() {
        return (
            <button onClick={this.handleClick}>
                {this.state.isToggleOn ? 'ON' : 'OFF'}
            </button>
        );
    }
}
```

React의 합성 이벤트 시스템은 이벤트 속성과 동작이 모든 브라우저에서 동일하게 작동하도록 보장하기 위해 사용됩니다. 합성 이벤트는 브라우저의 네이티브 이벤트를 감싸는 크로스 브라우저 래퍼이므로 호환되지 않는 이벤트 이름과 필드를 걱정할 필요가 없습니다.
</Callout>

## 화면 업데이트

컴포넌트에서 정보를 "기억"하고 표시하려는 경우가 자주 있습니다. 예를 들어, 버튼이 클릭된 횟수를 세고 싶을 수 있습니다. 이를 위해 컴포넌트에 상태(state)를 추가하세요.

먼저, React에서 `useState`를 import하세요:

```javascript
import { useState } from 'react';
```

이제 컴포넌트 내부에 상태 변수를 선언할 수 있습니다:

```javascript
function MyButton() {
  const [count, setCount] = useState(0);
  // ...
```

`useState`에서 두 가지를 얻게 됩니다: 현재 상태(`count`)와 상태를 업데이트할 수 있는 함수(`setCount`). 이들에게 아무 이름이나 지정할 수 있지만, `[something, setSomething]` 형식으로 작성하는 것이 관례입니다.

버튼이 처음 표시될 때 `count`는 0이 됩니다. 왜냐하면 `useState()`에 0을 전달했기 때문입니다. 상태를 변경하려면 `setCount()`를 호출하고 새 값을 전달하면 됩니다. 이 버튼을 클릭하면 카운터가 증가합니다:

```javascript
function MyButton() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return (
    <button onClick={handleClick}>
      Clicked {count} times
    </button>
  );
}
```

React는 컴포넌트 함수를 다시 호출합니다. 이번에는 `count`가 1이 될 것입니다. 그 다음에는 2가 될 것입니다. 그리고 이런 식으로 계속됩니다.

동일한 컴포넌트를 여러 번 렌더링하면 각각 자체 상태를 가지게 됩니다. 각 버튼을 개별적으로 클릭해보세요.


<iframe 
  src="https://codesandbox.io/embed/confident-frog-v56qeb?autoresize=1&fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%', 
    height: '500px', 
    border: '0', 
    borderRadius: '4px', 
    overflow: 'hidden'
  }}
  title="confident-frog-v56qeb"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

 각 버튼이 자체적인 `count` 상태를 "기억"하고 다른 버튼에 영향을 주지 않는 것을 알아차리세요.


## Hooks 사용

`use`로 시작하는 함수를 `Hooks`라고 합니다. `useState`는 React에서 제공하는 내장 Hook입니다. [API 참조](https://react.dev/reference/react)에서 다른 내장 Hooks도 찾을 수 있습니다. 또한 기존 Hooks를 조합하여 직접 Hooks를 작성할 수도 있습니다.

Hooks는 다른 함수보다 더 제한적입니다. 컴포넌트의 상단(또는 다른 Hooks)에서만 Hooks를 호출할 수 있습니다. 조건문이나 반복문에서 `useState`를 사용하려면 새로운 컴포넌트를 추출하고 그곳에 두세요.

<Callout>
**유용한 React 훅**

많이 사용되는 몇 가지 React 훅은 다음과 같습니다:

| 훅 이름 | 설명 |
| ------- | ---- |
| `useState` | 이 훅은 함수 컴포넌트에 React 상태를 추가할 수 있게 해줍니다. |
| `useEffect` | 이 훅은 함수 컴포넌트에서 사이드 이펙트를 수행할 수 있게 해줍니다. 이 훅은 React 클래스의 `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`와 같은 목적으로 사용됩니다. |
| `useContext` | 이 훅은 중첩을 추가하지 않고도 React 컨텍스트에 구독할 수 있게 해줍니다. |
| `useReducer` | 이 훅은 복잡한 상태 로직에서 `useState`보다 선호되는 경우가 많습니다. 여러 하위 값이 관련되거나 다음 상태가 이전 상태에 의존하는 복잡한 상태 로직에 사용됩니다. |
| `useCallback` | 이 훅은 의존성 중 하나가 변경될 때에만 변경되는 메모이즈된 콜백 버전을 반환합니다. 이는 불필요한 렌더링을 방지하기 위해 참조 동등성을 기반으로 최적화된 자식 컴포넌트에 콜백을 전달할 때 유용합니다. |
| `useMemo` | 이 훅은 메모이즈된 값을 반환합니다. "생성" 함수와 의존성 배열을 전달합니다. `useMemo`는 의존성 중 하나가 변경될 때에만 메모이즈된 값을 다시 계산합니다. |
| `useRef` | 이 훅은 전달된 인수(`initialValue`)로 초기화된 `.current` 속성을 갖는 가변적인 ref 객체를 생성하는 데 사용될 수 있습니다. 반환된 객체는 컴포넌트의 전체 수명 동안 유지됩니다. |
| `useImperativeHandle` | 이 훅은 `ref`를 사용할 때 부모 컴포넌트에 노출되는 인스턴스 값을 사용자 정의로 설정하는 데 사용됩니다. |
| `useLayoutEffect` | 이 훅은 `useEffect`와 동일한 형태로 동작하지만 DOM 변경 후 동기적으로 발생합니다. 이를 사용하여 DOM에서 레이아웃을 읽고 동기적으로 다시 렌더링할 수 있습니다. `useLayoutEffect` 내에서 예약된 업데이트는 브라우저가 그려지기 전에 동기적으로 플러시됩니다. |
| `useDebugValue` | 이 훅은 React DevTools에서 사용자 정의 훅의 레이블을 표시하는 데 사용될 수 있습니다. |

기본적인 `useState`와 `useEffect`를 제외하고 다른 훅은 복잡한 시나리오에서 특정 문제를 해결해야 할 때 자주 사용하지는 않을 수 있습니다. 그러나 복잡한 상황에서 특정 문제를 해결해야 할 때 강력한 도구입니다.
</Callout>



## 컴포넌트 간 데이터 공유

이전 예제에서 각 `MyButton`은 독립적인 `count`를 가지고 있으며 각 버튼이 클릭될 때 클릭한 버튼의 `count`만 변경됩니다.

<div style={{ display: 'flex', justifyContent: 'center' }}>
  <table style={{ borderCollapse: 'collapse', border: 'none' }}>
    <tr>
      <td style={{ border: 'none', padding: 20 }}>
        <img src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fsharing_data_child.png&w=640&q=75" alt="React Sharing Data" style={{ width: '320px', height: 'auto' }} />
        <p style={{ margin: 0 }}>처음에는 각 MyButton의 count 상태가 0입니다.</p>
      </td>
      <td style={{ border: 'none', padding: 20 }}>
        <img src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fsharing_data_child_clicked.png&w=640&q=75" alt="React Sharing Data" style={{ width: '320px', height: 'auto' }} />
        <p style={{ margin: 0 }}>첫 번째 MyButton은 count를 1로 업데이트합니다.</p>
      </td>
    </tr>
  </table>
</div>


그러나 종종 컴포넌트들이 데이터를 공유하고 항상 함께 업데이트해야 할 필요가 있습니다.

두 개의 `MyButton` 컴포넌트가 동일한 `count`를 표시하고 함께 업데이트하려면, 개별 버튼에서 상태를 "상위로" 이동하여 모두를 포함하는 가장 가까운 컴포넌트인 `MyApp`으로 이동해야 합니다.

이 예시에서는 MyApp입니다:
<div style={{ display: 'flex', justifyContent: 'center' }}>
  <table style={{ borderCollapse: 'collapse', border: 'none' }}>
    <tbody>
      <tr>
        <td style={{ border: 'none', padding: 20 }}>
          <img src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fsharing_data_parent.png&w=640&q=75" alt="React Sharing Data" style={{ width: 320, height: 'auto' }} />
          <p style={{ margin: 0 }}>처음에는 <code>MyApp</code>의 <code>count</code> 상태는 0이며, 이는 두 개의 자식 컴포넌트에 전달됩니다.</p>
        </td>
        <td style={{ border: 'none', padding: 20 }}>
          <img src="https://react.dev/_next/image?url=%2Fimages%2Fdocs%2Fdiagrams%2Fsharing_data_parent_clicked.png&w=640&q=75" alt="React Sharing Data" style={{ width: 320, height: 'auto' }} />
          <p style={{ margin: 0 }}>클릭 이벤트 발생 시, <code>MyApp</code>은 자체적인 <code>count</code> 상태를 1로 업데이트하고 이를 두 개의 자식 컴포넌트에 전달합니다.</p>
        </td>
      </tr>
    </tbody>
  </table>
</div>


이제 버튼 중 하나를 클릭하면 `MyApp`의 `count`가 변경되고, 이는 `MyButton`의 두 개의 `count`도 변경시킵니다. 아래는 이를 코드로 표현한 방법입니다.

먼저, `MyButton`에서 상태를 `MyApp`으로 이동합니다:

```javascript
export default function MyApp() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return (
    <div>
      <h1>개별적으로 업데이트되는 카운터</h1>
      <MyButton />
      <MyButton />
    </div>
  );
}

function MyButton() {
  // ... 여기서 코드를 이동합니다 ...
}
```

그런 다음, `MyApp`에서 상태를 각 `MyButton`으로 전달하고 공유된 클릭 핸들러와 함께 전달합니다. JSX 중괄호를 사용하여 `MyButton`으로 정보를 전달할 수 있습니다. 이전에 `<img>`와 같은 내장 태그에 사용한 것과 같은 방식입니다:

```javascript
export default function MyApp() {
  const [count, setCount] = useState(0);

  function handleClick() {
    setCount(count + 1);
  }

  return (
    <div>
      <h1>함께 업데이트되는 카운터</h1>
      <MyButton count={count} onClick={handleClick} />
      <MyButton count={count} onClick={handleClick} />
    </div>
  );
}
```

이렇게 전달하는 정보를 `props`라고 합니다. 이제 `MyApp` 컴포넌트에는 `count` 상태와 `handleClick` 이벤트 핸들러가 포함되어 있으며, 두 가지 모두를 각 버튼으로 `props`로 전달합니다.

마지막으로, `MyButton`을 수정하여 부모 컴포넌트에서 전달된 `props`를 읽도록 변경합니다:

```javascript
function MyButton({ count, onClick }) {
  return (
    <button onClick={onClick}>
      {count}번 클릭됨
    </button>
  );
}
```

버튼을 클릭하면 `onClick` 핸들러가 실행됩니다. 각 버튼의 `onClick` `prop`은 `MyApp` 내부에서 `handleClick` 함수로 설정되었으므로 해당 함수 내의 코드가 실행됩니다. 해당 코드는 `setCount(count + 1)`을 호출하여 `count` 상태 변수를 증가시킵니다. 새로운 `count` 값은 각 버튼에 `prop`로 전달되므로 새로운 값이 모두 표시됩니다. 이를 "상태를 위로 끌어올리기(lifting state up)"라고 합니다. 상태를 위로 이동함으로써 여러 컴포넌트 간에 상태를 공유할 수 있게 되었습니다.


<iframe 
  src="https://codesandbox.io/embed/determined-wave-us42os?autoresize=1&fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%', 
    height: '500px', 
    border: '0', 
    borderRadius: '4px', 
    overflow: 'hidden'
  }}
  title="determined-wave-us42os"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>



## React로 생각하기

리액트로 인해 당신이 바라보는 디자인과 빌드하는 앱에 대한 생각이 변경될 수 있습니다. 리액트로 사용자 인터페이스를 구축할 때, 먼저 컴포넌트라고 하는 조각들로 나누게 됩니다. 그런 다음, 각 컴포넌트의 다른 시각적 상태를 설명합니다. 마지막으로, 데이터가 컴포넌트를 통해 흐르도록 컴포넌트를 연결합니다. 이 튜토리얼에서는 리액트를 사용하여 검색 가능한 제품 데이터 테이블을 구축하는 과정을 안내해 드리겠습니다.

### Mockup으로 시작하기

JSON API와 디자이너로부터의 Mockup이 이미 있다고 가정해 보겠습니다.

JSON API는 다음과 같은 데이터를 반환합니다:
```json
[
  { category: "과일", price: "$1", stocked: true, name: "사과" },
  { category: "과일", price: "$1", stocked: true, name: "드래곤프루트" },
  { category: "과일", price: "$2", stocked: false, name: "패션프루트" },
  { category: "채소", price: "$2", stocked: true, name: "시금치" },
  { category: "채소", price: "$4", stocked: false, name: "호박" },
  { category: "채소", price: "$1", stocked: true, name: "콩나물" }
]
```
Mockup은 다음과 같습니다:

![](https://react.dev/images/docs/s_thinking-in-react_ui.png)

리액트로 UI를 구현하기 위해 일반적으로 다음 다섯 가지 단계를 따릅니다.

### 1단계: 컴포넌트 계층으로 UI 분할하기

먼저 모형에서 모든 컴포넌트와 하위 컴포넌트 주위에 상자를 그리고 이름을 지정하는 것부터 시작하세요. 디자이너와 함께 작업한다면, 그들은 이미 디자인 도구에서 이러한 컴포넌트에 이름을 지정했을 수 있습니다. 그들에게 물어보세요!

배경에 따라 디자인을 컴포넌트로 분할하는 방법을 다르게 생각할 수 있습니다:

* **프로그래밍** - 새로운 함수 또는 객체를 생성해야 할지를 결정하는 데 사용하는 동일한 기법을 사용합니다. 그 중 하나는 단일 책임 원칙으로, 이는 컴포넌트가 이상적으로는 한 가지 일만 해야 한다는 것입니다. 컴포넌트가 점점 커지면 작은 하위 컴포넌트로 분해해야 합니다.
* **CSS** - 클래스 선택자를 만들어야 할 대상을 고려합니다. (하지만 컴포넌트는 약간 덜 상세합니다.)
* **디자인** - 디자인의 레이어를 어떻게 구성할지 고려합니다.

JSON이 잘 구조화되어 있다면, UI의 컴포넌트 구조와 자연스럽게 매핑되는 경우가 많습니다. 이는 UI와 데이터 모델이 종종 동일한 정보 아키텍처를 가지기 때문입니다. UI를 컴포넌트로 분리하고, 각 컴포넌트가 데이터 모델의 한 부분과 일치하도록 분리하세요.

이 화면에는 다음과 같은 다섯 개의 컴포넌트가 있습니다:  
![](https://react.dev/images/docs/s_thinking-in-react_ui_outline.png)

- `FilterableProductTable` (회색)은 전체 앱을 포함합니다.
- `SearchBar` (파랑)은 사용자 입력을 받습니다.
- `ProductTable` (라벤더)은 사용자 입력에 따라 목록을 표시하고 필터링합니다.
- `ProductCategoryRow` (녹색)은 각 카테고리에 대한 제목을 표시합니다.
- `ProductRow` (노랑)은 각 제품에 대한 행을 표시합니다.

ProductTable (라벤더)을 살펴보면, 테이블 헤더 ("Name"과 "Price" 라벨 포함)가 별도의 컴포넌트가 아닙니다. 이는 개인의 취향에 따라 다를 수 있으며, 둘 중 어느 방식으로 해도 상관 없습니다. 이 예제에서는 Product

Table의 일부로 처리되며, ProductTable의 목록 내에 나타나기 때문입니다. 그러나 이 헤더가 복잡해진다면 (예: 정렬 기능 추가), 이를 자체적인 ProductTableHeader 컴포넌트로 이동할 수 있습니다.

이제 모형에서 컴포넌트를 식별했으므로, 계층 구조로 정렬하세요. 모형에서 다른 컴포넌트 내에 나타나는 컴포넌트는 계층 구조에서 자식으로 나타나야 합니다:

- `FilterableProductTable`
    - `SearchBar`
    - `ProductTable`
          - `ProductCategoryRow`
          - `ProductRow`

### 2단계: React로 정적 버전 구축하기

이제 컴포넌트 계층 구조가 준비되었으므로 앱을 구현할 차례입니다. 가장 직관적인 접근 방식은 아직 상호작용을 추가하지 않고 데이터 모델로부터 UI를 렌더링하는 버전을 먼저 구축하는 것입니다! 정적 버전을 먼저 구축하고 나중에 상호작용을 추가하는 것이 종종 더 쉽습니다. 정적 버전을 구축하기 위해서는 많은 타이핑이 필요하지만 생각은 필요하지 않지만, 상호작용을 추가하기 위해서는 생각이 많이 필요하지만 타이핑은 그렇게 많이 필요하지 않습니다.

데이터 모델을 렌더링하는 정적 버전의 앱을 구축하기 위해, 다른 컴포넌트를 재사용하고 props를 사용하여 데이터를 전달하는 컴포넌트를 구축해야 합니다. Props는 부모에서 자식으로 데이터를 전달하는 방법입니다. (상태(state) 개념에 익숙하다면, 이 정적 버전을 구축하는 데 상태를 전혀 사용하지 마세요. 상태는 상호작용(즉, 시간이 지남에 따라 변하는 데이터)에만 사용됩니다. 이것은 앱의 정적 버전이기 때문에 필요하지 않습니다.)

상향식(top-down)으로 구축하는 방법은 계층 구조 상단부터 컴포넌트를 구축하는 것입니다(예: FilterableProductTable). 하향식(bottom-up)으로 작업하는 방법은 하위 컴포넌트부터 작업하는 것입니다(예: ProductRow). 더 단순한 예제에서는 일반적으로 상향식으로 작업하는 것이 더 쉽지만, 큰 프로젝트에서는 하향식으로 작업하는 것이 더 쉽습니다.

<iframe 
  src="https://codesandbox.io/embed/weathered-breeze-18nfmd?autoresize=1&fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="weathered-breeze-18nfmd"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


(만약 이 코드가 어렵게 보인다면, 먼저 빠른 시작(Quick Start)을 따라해보세요!)

컴포넌트를 구축한 후에는 데이터 모델을 렌더링하는 재사용 가능한 컴포넌트 라이브러리가 생깁니다. 이는 정적인 앱이기 때문에 컴포넌트는 JSX만 반환합니다. 계층 구조의 맨 위에 있는 컴포넌트(FilterableProductTable)는 데이터 모델을 props로 받습니다. 이것은 일방향 데이터 흐름이라고 불리며, 데이터는 트리의 하단에 있는 컴포넌트로부터 맨 위의 컴포넌트로 흐릅니다.

> 주의사항
현재 단계에서는 어떤 상태 값도 사용하면 안됩니다. 그건 다음 단계에서 사용합니다!


### 3단계: UI 상태의 최소한이지만 완전한 표현 찾기

UI를 대화식으로 만들려면 사용자가 기반이 되는 데이터 모델을 변경할 수 있어야 합니다. 이를 위해 상태(state)를 사용할 것입니다.

상태(state)는 앱이 기억해야 하는 최소한의 변경 데이터 집합으로 생각할 수 있습니다. 상태를 구조화하는 가장 중요한 원칙은 DRY(Don't Repeat Yourself)를 유지하는 것입니다. 앱이 필요로 하는 상태의 절대 최소한의 표현을 찾고, 나머지는 필요할 때 계산하도록 합니다. 예를 들어, 쇼핑 목록을 만드는 경우, 항목들을 배열로 상태에 저장할 수 있습니다. 목록에 있는 항목의 수를 표시하려면 항목 수를 또 다른 상태 값으로 저장하지 말고, 대신 배열의 길이를 읽어와서 사용하세요.

이 예제 애플리케이션의 모든 데이터 조각들을 생각해 봅시다:

- 원래의 제품 목록
- 사용자가 입력한 검색 텍스트
- 체크박스의 값
- 필터링된 제품 목록

이 중 어느 것들이 상태일까요? 상태가 아닌 것을 식별해 봅시다:

- 시간이 지나도 값이 변경되지 않나요? 그렇다면, 그것은 상태가 아닙니다.
- 부모로부터 props를 통해 전달받나요? 그렇다면, 그것은 상태가 아닙니다.
- 컴포넌트 내에서 기존의 상태나 props를 기반으로 계산할 수 있나요? 그렇다면, 그것은 분명히 상태가 아닙니다!

남은 것들은 아마도 상태일 것입니다.

한 번 더 하나씩 살펴봅시다:

- 원래의 제품 목록은 props로 전달되기 때문에 상태가 아닙니다.
- 검색 텍스트는 시간이 지나면서 변경되고 어떤 것에서도 계산될 수 없기 때문에 상태인 것 같습니다.
- 체크박스의 값은 시간이 지나면서 변경되고 어떤 것에서도 계산될 수 없기 때문에 상태인 것 같습니다.
- 필터링된 제품 목록은 원래의 제품 목록을 가져와서 검색 텍스트와 체크박스의 값에 따라 필터링하여 계산될 수 있기 때문에 상태가 아닙니다.

이렇게 하면 검색 텍스트와 체크박스의 값만 이 상태입니다! 잘했어요!

<Callout>
**Props vs State**

React에서 "모델" 데이터는 두 가지 유형이 있습니다: props와 state. 이 두 가지는 매우 다릅니다:

- Props는 함수에 전달되는 인수와 같습니다. 부모 컴포넌트가 자식 컴포넌트에 데이터를 전달하고 외관을 사용자 정의할 수 있게 합니다. 예를 들어, Form 컴포넌트가 Button 컴포넌트에 color props를 전달할 수 있습니다.
- State는 컴포넌트의 메모리와 같습니다. 컴포넌트가 일부 정보를 추적하고 상호작용에 대한 응답으로 정보를 변경할 수 있게 합니다. 예를 들어, Button 컴포넌트가 isHovered라는 상태를 추적할 수 있습니다.
Props와 state는 다르지만 함께 작동합니다. 부모 컴포넌트는 종종 일부 정보를 상태로 유지하고, 이를 하위 컴포넌트에 props로 전달합니다. 처음에는 아직도 둘 사이의 차이가 모호하게 느껴질 수 있습니다. 그러나 실제로 확실하게 이해하려면 약간의 연습이 필요합니다!
</Callout>

### 4단계: 상태(state)가 어디에 위치해야 할지 식별하기

앱의 최소한의 상태 데이터를 식별한 후, 이 상태를 변경하거나 소유하는 책임이 있는 컴포넌트를 식별해야 합니다. 기억하세요: React는 부모 컴포넌트에서 자식 컴포넌트로 데이터를 내려보내는 단방향 데이터 흐름을 사용합니다. 어떤 컴포넌트가 어떤 상태를 소유해야 하는지 바로 알기는 어려울 수 있습니다. 이 개념이 처음이라면 이 단계를 따라가면서 찾아낼 수 있습니다!

앱의 각 상태 조각에 대해 다음을 수행합니다:

1. 해당 상태를 기반으로 렌더링하는 모든 컴포넌트를 식별합니다.
1. 최상위 부모 컴포넌트를 찾아봅니다. 이는 계층 구조 상에서 그들 모두의 상위에 위치한 컴포넌트입니다.
1. 상태가 위치해야 할 곳을 결정합니다:
1. 일반적으로 상태를 공통 부모 컴포넌트에 직접 넣을 수 있습니다.
1. 또는 공통 부모 컴포넌트 위의 어떤 컴포넌트에도 상태를 넣을 수 있습니다.
1. 상태를 소유할 만한 컴포넌트를 찾을 수 없다면, 상태를 유지하기 위해 새로운 컴포넌트를 만들고 공통 부모 컴포넌트 위의 어느 곳이든 추가합니다.
1. 이전 단계에서 이 애플리케이션에서 두 가지 상태를 찾았습니다: 검색 입력 텍스트와 체크박스의 값입니다. 이 예제에서는 항상 함께 표시되므로 동일한 위치에 넣는 것이 타당합니다.

이제 다음 전략을 따라 진행해 봅시다:

1. 상태를 사용하는 컴포넌트를 식별합니다:
1. ProductTable은 그 상태(검색 텍스트와 체크박스 값)에 따라 제품 목록을 필터링해야 합니다.
1. SearchBar는 그 상태(검색 텍스트와 체크박스 값)를 표시해야 합니다.
1. 공통 부모를 찾습니다: 두 컴포넌트가 공유하는 첫 번째 부모 컴포넌트는 FilterableProductTable입니다.
1. 상태가 위치해야 할 곳을 결정합니다: 필터 텍스트와 체크박스의 상태 값은 FilterableProductTable에 유지합니다.
1. 그래서 상태 값은 FilterableProductTable에 위치합니다.

useState() Hook을 사용하여 컴포넌트에 상태를 추가하세요. Hook은 React에 "hook into" 할 수 있는 특별한 함수입니다. FilterableProductTable의 상단에 두 개의 상태 변수를 추가하고 초기 상태를 지정하세요:
```javascript
function FilterableProductTable({ products }) {
  const [filterText, setFilterText] = useState('');
  const [inStockOnly, setInStockOnly] = useState(false);
```
그런 다음 filterText와 inStockOnly를 props로 ProductTable 및 SearchBar에 전달하세요:

```javascript
<div>
  <SearchBar 
    filterText={filterText} 
    inStockOnly={inStockOnly} />
  <ProductTable 
    products={products}
    filterText={filterText}
    inStockOnly={inStockOnly} />
</div>
```
이제 애플리케이션이 어떻게 작동하는지 확인할 수 있습니다. 코드 상에서 filterText 초기 값을 useState('')에서 useState('fruit')로 변경해보세요. 검색 입력 텍스트와 테이블이 업데이트되는 것을 확인할 수 있습니다.

<iframe 
  src="https://codesandbox.io/embed/gallant-bassi-4p46zu?autoresize=1&fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="gallant-bassi-4p46zu"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>




주목하세요. 현재 양식을 편집해도 작동하지 않습니다. 위의 샌드박스에는 다음과 같은 콘솔 오류가 있습니다.

```bash
You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field.
```
위의 샌드박스에서 ProductTable과 SearchBar는 filterText와 inStockOnly props를 읽어서 테이블, 입력 필드 및 체크박스를 렌더링합니다. 예를 들어, SearchBar가 입력 필드의 값을 채우는 방법은 다음과 같습니다.
```javascript
function SearchBar({ filterText, inStockOnly }) {
  return (
    <form>
      <input 
        type="text" 
        value={filterText} 
        placeholder="Search..."/>
```
그러나 아직 사용자의 입력과 같은 작업에 대응하는 코드를 추가하지 않았습니다. 이것이 마지막 단계가 될 것입니다.

### 5단계: 역 데이터 흐름 추가

현재 앱은 계층 구조를 따라 props와 state가 올바르게 전달되어 렌더링됩니다. 그러나 사용자 입력에 따라 상태를 변경하기 위해 데이터가 반대로 흐를 수 있어야 합니다. 계층 구조의 깊은 곳에 있는 양식 컴포넌트는 FilterableProductTable에서 상태를 업데이트해야 합니다.

React는 이러한 데이터 흐름을 명시적으로 지원하지만, 양방향 데이터 바인딩보다 조금 더 많은 타이핑이 필요합니다. 위의 예시에서 입력란을 입력하거나 체크박스를 선택하려고 하면 React가 입력을 무시하는 것을 볼 수 있습니다. 이는 의도적입니다. `<input value={filterText} />`와 같이 작성하면, 입력의 값 속성을 항상 FilterableProductTable에서 전달된 filterText 상태와 동일하게 설정한 것입니다. filterText 상태가 변경되지 않으므로 입력이 변경되지 않습니다.

사용자가 양식 입력을 변경할 때마다 상태가 해당 변경을 반영하도록 만들고 싶습니다. 상태는 FilterableProductTable이 소유하므로 setFilterText와 setInStockOnly를 호출할 수 있는 것은 FilterableProductTable뿐입니다. SearchBar가 FilterableProductTable의 상태를 업데이트할 수 있도록 하려면 이러한 함수를 SearchBar로 전달해야 합니다.

```javascript
function FilterableProductTable({ products }) {
  const [filterText, setFilterText] = useState('');
  const [inStockOnly, setInStockOnly] = useState(false);

  return (
    <div>
      <SearchBar 
        filterText={filterText} 
        inStockOnly={inStockOnly}
        onFilterTextChange={setFilterText}
        onInStockOnlyChange={setInStockOnly} />
```

SearchBar 내부에서 onChange 이벤트 핸들러를 추가하고 부모 상태를 업데이트합니다.

```javascript
<input 
  type="text" 
  value={filterText} 
  placeholder="Search..." 
  onChange={(e) => onFilterTextChange(e.target.value)} />
```

이제 앱이 완벽하게 작동합니다!

<iframe 
  src="https://codesandbox.io/embed/cranky-allen-w337n9?fontsize=14&hidenavigation=1&theme=dark"
  style={{
    width: '100%',
    height: '500px',
    border: '0',
    borderRadius: '4px',
    overflow: 'hidden'
  }}
  title="cranky-allen-w337n9"
  allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
  sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>


Adding Interactivity 섹션에서 이벤트 처리와 상태 업데이트에 대해 모두 배울 수 있습니다.




##  다음 단계로 어디로 가야 할까요?

이 문서는 React를 사용하여 컴포넌트와 애플리케이션을 구축하는 방법에 대해 간략하게 소개했습니다. 지금 바로 React 프로젝트를 시작하거나 이 튜토리얼에서 사용된 모든 구문에 대해 자세히 알아보세요. 이벤트 처리 및 상태 업데이트에 대해 자세히 알아볼 수 있는 "상호작용성 추가" 섹션으로 이동할 수 있습니다.

<div className="grid gap-8 mt-7">

<Card href="/docs/react/tic-tac-toe">

### 튜토리얼: 틱택토 게임

틱택토 게임을 만들면서 필수적인 React 기초를 깊게 배울 것입니다.

</Card>

<Card href="/docs/react/installation">

### 설치 및 환경 설정

Using React components in Mardown.

</Card>

<Card href="/docs/react/describing-the-ui">

### UI 구축하기

Beautiful code blocks with syntax highlighting.

</Card>

<Card href="/docs/react/adding-interactivity">

### 상호작용성 추가하기

View a sample page with all the styles.

</Card>

<Card href="/docs/react/managing-state">

### 상태 관리

View a sample page with all the styles.

</Card>

<Card href="/docs/react/escape-hatches">

### 고급 기법

View a sample page with all the styles.

</Card>

<Card href="/docs/react/server-client-components">

### 서버/클라이언트 컴포넌트

View a sample page with all the styles.

</Card>

</div>
