---
title: "프로젝트 구성 요소 하나씩 살펴보기"
summary: "Next.js Boilerplate - 프로젝트 구성"
date: "2023-09-22 00:02"
images: ['/static/images/example/LightMode_CreateNextApp.png']
authors: ['boilerplate']
tags: ['TypeScript', 'Tailwind CSS', 'App Router']
---

<ol class="flex items-center w-full p-0 space-x-2 text-sm font-medium text-center text-gray-500 bg-white border border-gray-200 rounded-lg shadow-sm dark:text-gray-400 sm:text-base dark:bg-gray-800 dark:border-gray-700 sm:space-x-4">
    <li class="flex items-center py-0 my-0">
        <span class="flex items-center justify-center w-5 h-5 py-0 my-0 mr-2 text-xs border border-gray-500 rounded-full shrink-0 dark:border-gray-400">
            1
        </span>
        <Link href="/example/boilerplate"><span class="inline-flex">소개</span></Link>
        <svg class="w-3 h-3 mt-4 ml-2 sm:ml-4" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 12 10">
            <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m7 9 4-4-4-4M1 9l4-4-4-4"/>
        </svg>
    </li>
    <li class="flex items-center py-0 my-0">
        <span class="flex items-center justify-center w-5 h-5 py-0 my-0 mr-2 text-xs border border-gray-500 rounded-full shrink-0 dark:border-gray-400">
            2
        </span>
        <Link href="/example/boilerplate/installation"><span class="inline-flex">설치</span><span class="inline-flex hidden sm:ml-2">및 설정</span></Link>
        <svg class="w-3 h-3 mt-4 ml-2 sm:ml-4" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 12 10">
            <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m7 9 4-4-4-4M1 9l4-4-4-4"/>
        </svg>
    </li>
    <li class="flex items-center py-0 my-0 bg-gray-100">
        <span class="flex items-center justify-center w-5 h-5 py-0 my-0 mr-2 text-xs border border-gray-500 rounded-full shrink-0 dark:border-gray-400">
            3
        </span>
        <Link href="/example/boilerplate/project-structure"><span class="inline-flex hidden sm:ml-2">디렉터리</span> <span class="inline-flex">구조</span></Link>
        <svg class="w-3 h-3 mt-4 ml-2 sm:ml-4" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 12 10">
            <path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="m7 9 4-4-4-4M1 9l4-4-4-4"/>
        </svg>
    </li>
    <li class="flex items-center py-0 my-0">
        <span class="flex items-center justify-center w-5 h-5 py-0 my-0 mr-2 text-xs border border-gray-500 rounded-full shrink-0 dark:border-gray-400">
            4
        </span>
        <Link href="/example/boilerplate/app-source"><span class="inline-flex">코드 분석</span></Link>
        <svg class="w-3 h-3 mt-4 ml-2 sm:ml-4" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 12 10">
        </svg>
    </li>
</ol>

<TOCInline toc={props.toc} asDisclosure toHeading={3} />

---

이제 생성 된 디렉터리와 파일 하나씩 살펴 보도록 하겠습니다.

## Visual Studio Code에서 살펴 보기
아래 명령어를 통해 [Visual Studio Code](https://code.visualstudio.com/) 에디터를 실행 합니다.

```bash
code .
```
<ToggleContent title="Visual Studio Code (VS Code)">
Visual Studio Code (VS Code)는 Next.js 프로젝트를 개발하기에 매우 적합한 코드 에디터입니다. Next.js 프로젝트를 VS Code에서 사용하는 방법에 대해 안내해 드리겠습니다.

1. **VS Code 설치**: 아직 설치하지 않았다면, [Visual Studio Code 공식 웹사이트](https://code.visualstudio.com/)에서 다운로드 및 설치를 진행하세요.

2. **프로젝트 폴더 열기**: 
   - VS Code를 실행합니다.
   - `파일` > `폴더 열기` (또는 `File` > `Open Folder` 영어 버전의 경우)를 선택하여 Next.js 프로젝트 폴더를 선택합니다.

3. **필요한 확장 프로그램 설치**: VS Code는 다양한 확장 프로그램을 지원하는데, Next.js와 관련하여 유용한 확장 프로그램은 다음과 같습니다:
   - **ESLint**: 코드 스타일과 잠재적 오류를 검사합니다.
   - **Prettier**: 코드 포맷팅 도구입니다.
   - **Next.js**: Next.js를 위한 구문 강조 및 자동 완성을 제공합니다.

   위 확장 프로그램들은 VS Code의 확장 탭에서 검색하여 설치할 수 있습니다.

4. **개발 서버 시작**:
   - 터미널을 열기 위해 `터미널` > `새 터미널`을 선택합니다.
   - 다음 명령어를 실행하여 개발 서버를 시작합니다:
     ```
     npm run dev
     ```

5. **디버깅**:
   - VS Code는 Next.js 애플리케이션을 디버깅하는 기능을 제공합니다.
   - `.vscode` 디렉터리 내에 `launch.json` 파일을 생성하고 다음 설정을 추가합니다:
     ```json
     {
       "type": "node",
       "request": "launch",
       "name": "Launch Next.js",
       "runtimeExecutable": "${workspaceRoot}/node_modules/.bin/next",
       "env": {
         "NODE_ENV": "development"
       },
       "runtimeArgs": ["--inspect", "dev"],
       "port": 9229
     }
     ```
   - 이제 `F5` 키를 눌러 디버깅 세션을 시작할 수 있습니다.

6. **코드 작성 및 수정**:
   - VS Code는 IntelliSense, 코드 리팩토링 도구, 코드 탐색 기능 등 다양한 기능을 제공하므로, 효과적으로 코드 작성 및 수정 작업을 할 수 있습니다.

이로써, VS Code에서 Next.js 프로젝트를 시작하고, 개발하며, 디버깅하는 기본적인 방법을 알게 되었습니다. VS Code는 다양한 기능과 확장 프로그램을 제공하므로, 프로젝트의 필요에 따라 추가적인 설정 및 환경 구축을 진행할 수 있습니다.
</ToggleContent>

## 최상위 디렉터리와 파일
```ruby
.
├── .next/
│   └── ...         # Next.js가 빌드 과정에서 생성하는 일시적인 파일들이 위치합니다.
├── app/
│   └── ...         # 애플리케이션의 주요 소스 코드와 관련 파일들이 위치합니다.
├── node_modules/
│   └── ...         # npm 또는 yarn을 통해 설치한 모든 종속성 모듈들이 위치합니다.
├── public/
│   └── ...         # 정적 파일들 (예: 이미지) 이 위치하며, 브라우저에서 직접 접근 가능합니다.
├── .eslintrc.json   # ESLint 구성 파일로, 코드 스타일 및 오류를 확인하는 데 사용합니다.
├── .gitignore       # Git 버전 관리에서 추적하지 않을 파일 및 디렉터리 목록입니다.
├── next-env.d.ts    # Next.js에서 사용하는 TypeScript 정의가 포함된 파일입니다.
├── next.config.js   # Next.js의 사용자 정의 설정을 하는 파일입니다.
├── package-lock.json # npm 패키지의 정확한 버전 정보를 포함합니다.
├── package.json      # 프로젝트 메타데이터와 종속성 목록이 포함된 파일입니다.
├── postcss.config.js # PostCSS 설정 파일입니다. CSS 전처리기에 대한 설정을 포함합니다.
├── README.md         # 프로젝트에 대한 설명 및 사용 방법을 설명하는 문서입니다.
├── tailwind.config.ts # Tailwind CSS의 사용자 정의 설정을 위한 파일입니다.
└── tsconfig.json      # TypeScript 프로젝트 설정 파일입니다.
```

---

## 프로젝트의 구조와 설정 파악

프로젝트의 구조와 설정을 처음으로 파악하려면 다음 파일들을 먼저 확인하는 것이 좋습니다:

1. **`README.md`**: 대부분의 프로젝트에는 `README.md` 파일이 포함되어 있습니다. 이 파일은 프로젝트의 개요, 설치 및 실행 방법, 기여 방법 등 필요한 주요 정보를 제공하는 경우가 많습니다. 따라서 프로젝트를 처음 접할 때 이 파일을 먼저 읽는 것이 좋습니다.

2. **`package.json`**: 이 파일은 프로젝트의 메타데이터와 종속성 목록을 포함하고 있습니다. 스크립트 섹션은 프로젝트를 실행, 빌드, 테스트하는 데 사용되는 명령어를 제공할 수 있으므로 중요합니다.

3. **`next.config.js`**: 이 파일은 Next.js의 사용자 정의 설정을 포함하고 있습니다. 프로젝트의 특별한 설정이나 플러그인, 경로 별칭 등이 정의되어 있을 수 있으므로, Next.js 프로젝트의 동작 방식을 이해하는 데 중요합니다.

4. **`.gitignore`**: 이 파일은 Git 버전 관리에서 추적하지 않을 파일 및 디렉터리 목록을 포함하고 있습니다. 어떤 파일이나 폴더가 버전 관리에서 제외되었는지 파악하는 데 도움이 됩니다.

이 외에도 프로젝트의 세부 사항과 관련된 다른 설정 파일들 (예: `.eslintrc.json`, `postcss.config.js`, `tailwind.config.ts`, `tsconfig.json`)은 필요에 따라 참고할 수 있습니다. 그러나 초기에 프로젝트의 전반적인 구조와 설정을 이해하는 데는 위에서 언급한 파일들을 먼저 확인하는 것이 좋습니다.

### `README.md` 파일 살펴 보기
이 프로젝트는 [`create-next-app`](https://github.com/vercel/next.js/tree/canary/packages/create-next-app)을 사용하여 시작된 [Next.js](https://nextjs.org/) 프로젝트입니다. 개발 서버를 실행하기 위해 여러 패키지 매니저 명령어(`npm`, `yarn`, `pnpm`, `bun`)가 제시되어 있으며, 서버가 실행되면 [http://localhost:3000](http://localhost:3000)에서 결과를 확인할 수 있습니다. 주요 페이지는 `app/page.tsx`에서 편집할 수 있으며, 이 프로젝트는 Google Font 중 하나인 Inter를 최적화하여 로드하기 위해 `next/font`를 사용합니다. 추가로, Next.js에 대한 학습 자료와 Vercel 플랫폼을 사용한 배포 방법에 대한 정보가 제공됩니다.

<Callout type="warning" icon="초보 개발자가 알아야 할 항목">
1. **개발 서버 실행**: 프로젝트를 시작하려면 개발 서버를 실행해야 합니다. 사용하는 패키지 매니저에 따라(`npm`, `yarn`, `pnpm`, `bun`) 적절한 명령어를 사용해 서버를 시작하세요.
2. **페이지 편집**: `app/page.tsx` 파일을 편집하여 페이지의 내용을 변경할 수 있습니다. 편집 후 저장하면 페이지가 자동으로 업데이트됩니다.
3. **폰트 최적화**: 이 프로젝트는 특정 Google Font(Inter[^1])를 최적화하여 사용하므로, 다른 폰트를 사용하려면 설정을 변경해야 할 수도 있습니다.
    > 폰트 관련 자세한 내용은 [가이드 문서](/docs/nextjs/optimizing/fonts)를 참조해주세요.
4. **Next.js 학습**: 프로젝트에 익숙해지려면 [Next.js Documentation](https://nextjs.org/docs) 및 [Learn Next.js](https://nextjs.org/learn)를 참고하여 Next.js에 대한 기본적인 지식을 습득하는 것이 좋습니다.
5. **배포**: 프로젝트를 완료하고 배포할 준비가 되면 [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme)을 통해 배포하는 방법을 고려해보세요.

[^1]: Inter는 Rasmus Andersson이 디자인한 상업적으로 사용할 수 있는 무료 폰트입니다. 원래는 디지털 화면 및 사용자 인터페이스를 위해 디자인되었기 때문에 웹과 앱에서 주로 사용됩니다. Inter는 많은 기능과 넓은 글자 가지량을 포함하며, 다양한 스타일 및 가중치를 제공하여 디자인에 유연성을 제공합니다.
</Callout>


### `package.json` 파일 살펴 보기
```json:"package.json"
{
  "name": "boilerplate",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@types/node": "20.6.3",
    "@types/react": "18.2.22",
    "@types/react-dom": "18.2.7",
    "autoprefixer": "10.4.16",
    "eslint": "8.49.0",
    "eslint-config-next": "13.5.2",
    "next": "13.5.2",
    "postcss": "8.4.30",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "tailwindcss": "3.3.3",
    "typescript": "5.2.2"
  }
}
```

이 `package.json` 파일은 Next.js 프로젝트를 위한 기본 설정을 담고 있습니다. 아래는 각 항목에 대한 설명입니다:

1. **name**: 프로젝트의 이름입니다. 여기서는 "boilerplate"로 설정되어 있습니다.
2. **version**: 프로젝트의 현재 버전입니다. 초기 버전으로 "0.1.0"로 설정되어 있습니다.
3. **private**: 이 항목이 `true`로 설정되면, 이 프로젝트는 npm 레지스트리에 publish되지 않습니다. 대부분의 개인 프로젝트나 내부 프로젝트에서 사용됩니다.
4. **scripts**:
   - `dev`: 개발 모드로 Next.js 앱을 실행합니다.
   - `build`: 프로덕션 용 코드를 빌드합니다.
   - `start`: 빌드된 코드를 실행하여 프로덕션 서버를 시작합니다.
   - `lint`: 코드의 스타일 및 문제점을 검사하기 위해 eslint를 사용합니다.
5. **dependencies**:
   - `@types/*`: TypeScript 타입 정의 파일입니다. React, Node.js와 같은 라이브러리들의 TypeScript 타입을 제공합니다.
   - `autoprefixer`: CSS에 자동으로 vendor prefixes를 추가해줍니다.
   - `eslint` & `eslint-config-next`: 코드 품질을 유지하기 위한 linting 도구입니다.
   - `next`: Next.js 프레임워크의 핵심 패키지입니다.
   - `postcss`: CSS 전처리기입니다.
   - `react` & `react-dom`: React 라이브러리와 DOM을 위한 React 함수.
   - `tailwindcss`: 유틸리티 기반의 CSS 프레임워크입니다.
   - `typescript`: TypeScript 언어 및 컴파일러입니다.


<ToggleContent title="package.json vs. package-lock.json">

`package.json`과 `package-lock.json`은 Node.js 및 npm eco-system의 중요한 부분입니다. 둘 다 프로젝트의 의존성(dependencies)와 관련된 정보를 저장하고 있지만, 사용 목적과 내용이 약간 다릅니다.

**package.json**

1. **정의**: 프로젝트의 메타데이터와 의존성(dependencies) 정보를 담고 있는 JSON 파일입니다.
2. **주요 항목**:
   - `name`: 프로젝트의 이름.
   - `version`: 프로젝트의 버전.
   - `scripts`: 명령어 스크립트. 예: `npm start`나 `npm test`를 실행할 때 해당 명령어에 대응되는 스크립트.
   - `dependencies`: 프로젝트가 실행될 때 필요한 패키지의 목록.
   - `devDependencies`: 개발 중에만 필요한 패키지의 목록. 예: linting, testing 등.
   - `peerDependencies`: 호환되는 패키지의 버전을 나타냅니다.
   - `private`: 이 항목이 `true`로 설정되면, 이 프로젝트는 npm 레지스트리에 publish되지 않습니다.

**package-lock.json**

1. **정의**: 설치된 모든 패키지의 정확한 버전 정보와 그것들의 종속성 트리(dependency tree)를 포함하는 자동 생성된 파일입니다.
2. **용도**:
   - 프로젝트의 의존성 트리를 일관성 있게 유지하는 것입니다.
   - 같은 `package.json` 파일을 가진 두 개의 프로젝트에서도 `npm install`을 실행하면 다른 버전의 패키지가 설치될 수 있는데, `package-lock.json`을 사용하면 동일한 의존성 트리가 보장됩니다.
   - 이는 배포와 협업 시 버전 충돌이나 예기치 않은 버그를 방지하는 데 중요합니다.


이러한 정보를 바탕으로, 프로젝트의 동작 방식, 의존성 및 주요 명령어에 대한 기본적인 이해를 얻을 수 있습니다.

요약하면, `package.json`은 프로젝트의 설정과 의존성에 대한 정보를 담고 있으며, `package-lock.json`은 의존성의 정확한 버전 정보를 담고 있어 프로젝트의 안정성을 보장하는 데 중요합니다.

</ToggleContent>


<Callout type="warning" icon="초보 개발자가 알아야 할 항목">
- **scripts**: 여기에 정의된 스크립트는 프로젝트의 주요 동작을 담당하므로, 이 명령어들을 통해 어떤 동작을 수행하는지 알아야 합니다.
- **dependencies**: 이 섹션은 프로젝트가 의존하는 라이브러리와 패키지를 나열합니다. 패키지를 추가하거나 제거할 때 이 섹션이 변경됩니다. 패키지의 이름 옆에 있는 버전 번호는 해당 패키지의 버전을 지정합니다. 
- `private`: 이 항목이 `true`로 설정되면 이 프로젝트를 외부에 공개하지 않는다는 것을 의미합니다.
- **의존성 추가/제거**: 패키지를 설치하거나 제거할 때 (`npm install [package-name]`, `npm uninstall [package-name]`) `package.json`과 `package-lock.json` 둘 다 업데이트됩니다.
- **스크립트**: `package.json`의 `scripts` 섹션에서는 자주 사용하는 작업을 자동화하기 위한 명령어 스크립트를 정의할 수 있습니다.
- **버전 관리**: `package-lock.json`은 git과 같은 버전 관리 시스템에 포함되어야 합니다. 이를 통해 팀원 간에 동일한 의존성을 공유할 수 있습니다.
- **의존성 확인**: `package.json`에서 `dependencies`와 `devDependencies`를 주기적으로 확인하여 사용하지 않는 패키지나 오래된 패키지를 업데이트하거나 제거하는 것이 좋습니다.
</Callout>

### `next.config.js` 파일 살펴 보기

이것은 매우 기본적인 `next.config.js` 파일의 형태입니다. `next.config.js` 파일은 Next.js 프로젝트의 설정을 사용자 정의하기 위한 파일입니다.


1. ```/** @type {import('next').NextConfig} */```: 
   - 이 주석은 TypeScript 타입 주석입니다. `nextConfig` 객체가 `NextConfig` 타입을 가지도록 지정합니다. 이렇게 하면, `nextConfig` 객체에 Next.js 설정과 관련된 속성만 추가할 수 있도록 도와주며, 오타나 잘못된 속성을 추가할 경우 오류를 발생시킵니다. (주의: 이 주석은 실제로 TypeScript의 타입 체크 기능을 활성화하지 않습니다. TypeScript 환경에서만 작동합니다.)
2. `const nextConfig = {}`: 
   - `nextConfig`라는 빈 객체를 선언합니다. 이 객체 내부에 Next.js의 설정을 추가할 수 있습니다. 현재는 어떠한 사용자 정의 설정도 포함되어 있지 않습니다.
3. `module.exports = nextConfig`:
   - `nextConfig` 객체를 내보냅니다. 이렇게 함으로써 Next.js는 이 파일을 통해 프로젝트 설정을 가져올 수 있습니다.

현재 이 `next.config.js` 파일은 기본 상태이며, 특별한 사용자 정의 설정이 포함되어 있지 않습니다. 필요에 따라 여기에 다양한 설정을 추가하여 Next.js 프로젝트의 동작을 사용자 정의 할 수 있습니다.

---

## TypeScript 설정

`tsconfig.json` 파일은 TypeScript 프로젝트의 컴파일러 옵션과 포함/제외할 파일들을 설정하는 파일입니다. 
```json:"tsconfig.json"
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
```

1. **`compilerOptions`**: TypeScript 컴파일러의 동작을 설정하는 주요 옵션들입니다.
    - **`target`**: TypeScript가 JavaScript로 변환될 때, 어떤 ECMAScript 버전으로 컴파일될지 설정합니다. 여기서는 "es5"로 설정되어 있으므로 ES5 버전으로 컴파일됩니다.
    - **`lib`**: 컴파일에 포함할 라이브러리 파일들을 지정합니다. 기본적인 DOM, ESNext 기능들이 포함되어 있습니다.
    - **`allowJs`**: JavaScript 파일(`.js`)을 TypeScript로 컴파일 할 수 있게 합니다.
    - **`skipLibCheck`**: 선언 파일(`.d.ts`)의 타입 검사를 건너뛰게 합니다. 일부 라이브러리의 타입 정의와의 문제를 피하려고 사용합니다.
    - **`strict`**: 모든 엄격한 타입 검사 옵션을 활성화합니다. 코드의 타입 안정성을 향상시키기 위해 권장됩니다.
    - **`noEmit`**: 출력 파일을 생성하지 않게 합니다. Next.js는 TypeScript 코드를 직접 처리하므로 필요하지 않습니다.
    - **`esModuleInterop`**: ES 모듈과 CommonJS 모듈 간의 상호 운용성을 위한 코드를 생성합니다.
    - **`module` & `moduleResolution`**: 모듈 시스템과 해석 방식을 설정합니다.
    - **`jsx`**: JSX 코드의 처리 방식을 설정합니다. "preserve"는 JSX를 그대로 유지하라는 의미입니다. Next.js가 이를 처리합니다.
    - **`incremental`**: 증분 컴파일을 사용하여 빌드 시간을 단축합니다.
    - **`plugins`**: TypeScript 플러그인을 지정합니다. 여기서는 Next.js 관련 플러그인이 사용됩니다.
    - **`paths`**: 모듈 별칭을 설정합니다. `@/*` 별칭을 사용하여 프로젝트의 루트에서 모듈을 가져올 수 있습니다.
2. **`include`**: 컴파일에 포함될 파일 또는 디렉토리의 목록입니다. `.ts`, `.tsx` 파일과 특정 디렉토리가 포함됩니다.
3. **`exclude`**: 컴파일에서 제외될 파일 또는 디렉토리의 목록입니다. 일반적으로 `node_modules`는 제외됩니다.

초보 개발자는 이러한 옵션들을 이해하고, 필요에 따라 프로젝트의 요구 사항에 맞게 조정할 수 있어야 합니다. 
하지만, Next.js 같은 프레임워크에서는 대부분의 설정이 이미 최적화되어 제공되므로, <StyleImportant>처음에는 기본 설정을 그대로 사용</StyleImportant>하는 것이 좋습니다.

<ToggleContent title="TypeScript 설정 조정 필요 경우">
TypeScript 설정을 조정해야 하는 경우는 여러 상황에 따라 다르지만, 아래는 몇 가지 일반적인 상황입니다:

1. **새로운 라이브러리/프레임워크 사용**: 새로운 라이브러리나 프레임워크를 사용하면서 해당 라이브러리의 타입 정의가 필요하거나 특별한 컴파일러 옵션이 필요할 때 설정을 변경해야 할 수 있습니다.
2. **타입 검사 엄격도 조절**: 프로젝트의 성장과 함께 타입 검사의 엄격도를 높이거나 낮추고 싶을 때 (`strict`, `strictNullChecks`, `noImplicitAny` 등의 옵션 변경).
3. **모듈 별칭 및 경로 설정**: 프로젝트의 구조나 디렉토리 변경으로 인해 모듈의 경로나 별칭을 다시 설정해야 할 때 (`paths`와 `baseUrl` 옵션 변경).
4. **JSX 처리 방식 변경**: 리액트 외의 다른 라이브러리 (예: Preact)를 사용하면서 JSX 처리 방식을 변경해야 할 때 (`jsx` 옵션 변경).
5. **다른 ECMAScript 버전 대상**: 다른 버전의 ECMAScript를 대상으로 컴파일하고 싶을 때 (`target` 옵션 변경).
6. **포함/제외 파일 변경**: 컴파일에 포함하거나 제외할 특정 파일이나 디렉토리가 변경되었을 때 (`include` 및 `exclude` 옵션 변경).
7. **프로젝트 최적화**: 프로젝트의 빌드 성능을 개선하거나, 특정 최적화 기법을 적용하고 싶을 때 (예: `incremental` 옵션 활성화).
8. **TypeScript 플러그인 사용**: 특정 TypeScript 플러그인을 사용하려고 할 때 (`plugins` 옵션 추가).

이 외에도 다양한 이유로 TypeScript 설정을 조정할 수 있습니다. 중요한 점은 변경 전후로 프로젝트가 올바르게 동작하는지 테스트하고, 설정의 변경 사유와 그에 따른 결과를 잘 문서화해두는 것이 좋습니다.
</ToggleContent>

---

## Tailwind 설정

```tsx:tailwind.config.ts
import type { Config } from 'tailwindcss'

const config: Config = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      backgroundImage: {
        'gradient-radial': 'radial-gradient(var(--tw-gradient-stops))',
        'gradient-conic':
          'conic-gradient(from 180deg at 50% 50%, var(--tw-gradient-stops))',
      },
    },
  },
  plugins: [],
}
export default config
```

`tailwind.config.ts` 파일은 Tailwind CSS 프레임워크의 구성을 정의하는 파일입니다. 이 파일을 통해 Tailwind의 기본 설정을 확장하거나 수정할 수 있습니다. 제시된 내용을 기반으로 주요 항목을 설명하겠습니다.

1. **content**:
    - Tailwind CSS는 유틸리티 클래스를 자동으로 생성해주는 특징이 있습니다. `content` 배열은 Tailwind CSS가 유틸리티 클래스를 생성할 때, 어떤 파일들을 대상으로 할지를 지정합니다.
    - 여기서는 프로젝트 내의 `./pages`, `./components`, `./app` 디렉터리에 있는 `.js`, `.ts`, `.jsx`, `.tsx`, `.mdx` 확장자를 가진 파일들을 대상으로 합니다.
2. **theme**:
    - Tailwind의 디자인 테마를 정의하거나 확장하는 부분입니다.
    - `extend` 내부에서 기존의 Tailwind 테마에 새로운 스타일이나 변수를 추가할 수 있습니다.
    - 여기서는 `backgroundImage`에 `gradient-radial`과 `gradient-conic`라는 두 가지 새로운 스타일을 추가하고 있습니다. 이 스타일들은 웹 페이지의 배경 이미지로서의 그라데이션을 제공합니다.
3. **plugins**:
    - Tailwind를 확장하기 위해 사용할 외부 플러그인을 추가하는 배열입니다. 현재는 추가된 플러그인이 없습니다.

<Callout type="warning" icon="초보 개발자가 알아야 할 항목">
- Tailwind CSS는 많은 유틸리티 클래스를 제공합니다. `tailwind.config.ts` 파일을 사용하면 프로젝트의 필요에 맞게 이러한 설정을 조정하거나 추가할 수 있습니다.
- `content` 부분은 프로젝트 구조가 변경될 때마다 업데이트해야 할 수도 있습니다. 즉, 새로운 디렉터리나 파일 확장자가 추가되면 해당 경로나 확장자를 `content` 배열에 추가해야 합니다.
- `theme`의 `extend` 부분은 기존 Tailwind 스타일에 새로운 스타일을 추가하거나 기존 스타일을 재정의할 때 사용됩니다. 
</Callout>

이 파일은 Tailwind CSS의 동작을 결정하기 때문에, 디자인이나 스타일링과 관련된 문제가 발생하면 이 파일을 검토하는 것이 좋습니다.

### [실습1] 다른 배경 스타일 적용 해 보기
backgroundImage에서 CSS 기반의 스타일을 사용하는 예제에 대해 설명 드립니다.

예를 들어, 단순한 선형 그라데이션 또는 반복되는 패턴을 추가하려면 다음과 같이 설정할 수 있습니다:

```typescript
theme: {
    extend: {
        backgroundImage: {
            'gradient-blue-red': 'linear-gradient(45deg, #3498db, #e74c3c)',
            'dots-pattern': 'repeating-radial-gradient(circle, #333, #333 1px, transparent 1px, transparent 50%)',
            'stripes-pattern': 'repeating-linear-gradient(45deg, #f0f0f0, #f0f0f0 25%, #e0e0e0 25%, #e0e0e0 50%)'
        }
    }
}
```

이 설정에 따르면:
- `gradient-blue-red`: 파란색에서 빨간색으로 45도 각도의 선형 그라데이션을 제공합니다.
- `dots-pattern`: 반복되는 원형 그라데이션을 사용하여 점 패턴을 제공합니다.
- `stripes-pattern`: 반복되는 선형 그라데이션을 사용하여 줄무늬 패턴을 제공합니다.

이제 HTML에서 해당 스타일을 적용하려면 다음과 같이 Tailwind CSS 클래스를 사용합니다:

```html
<div class="bg-gradient-blue-red"></div>
<div class="bg-dots-pattern"></div>
<div class="bg-stripes-pattern"></div>
```

이렇게 하면 각각의 `div` 요소에 위에서 정의한 선형 그라데이션, 점 패턴, 줄무늬 패턴이 적용됩니다.

### [실습2] 이미지 기반 다른 배경 스타일 적용 해 보기

예를 들어, `backgroundImage`에 특정한 패턴 또는 이미지를 사용하려면 다음과 같이 설정할 수 있습니다:

```typescript
theme: {
    extend: {
        backgroundImage: {
            'checkerboard': 'url("/path/to/checkerboard.png")',
            'dots-pattern': 'url("/path/to/dots-pattern.png")',
            'stripes-pattern': 'url("/path/to/stripes-pattern.png")'
        }
    }
}
```

위 예제에서는:
- `checkerboard`: 체커보드 패턴의 이미지를 배경으로 사용합니다.
- `dots-pattern`: 점 패턴의 이미지를 배경으로 사용합니다.
- `stripes-pattern`: 줄무늬 패턴의 이미지를 배경으로 사용합니다.

이렇게 설정한 후, 해당 스타일을 HTML 요소에 적용하려면 다음과 같이 Tailwind CSS 클래스를 사용합니다:

```html
<div class="bg-checkerboard"></div>
<div class="bg-dots-pattern"></div>
<div class="bg-stripes-pattern"></div>
```

이렇게 하면 각각의 `div` 요소에 체커보드, 점 패턴, 줄무늬 패턴의 배경 이미지가 적용됩니다. 

주의할 점은, 이미지 경로(`/path/to/...`)는 실제 프로젝트의 이미지 위치(`public/` 하위)에 따라 변경되어야 합니다.

---

## `public/` 디렉터리 알아 보기

`public/` 디렉터리는 Next.js 프로젝트에서 특별한 의미를 가지는 디렉터리입니다. 

1. **정적 파일 호스팅**: 
   - `public/` 디렉터리 내의 모든 파일은 프로젝트의 루트 URL에서 직접 접근할 수 있습니다. 
   - 예를 들어, `public/next.svg` 파일은 웹 브라우저에서 `http://your-domain.com/next.svg`로 접근할 수 있습니다.
2. **최적화 없음**:
   - `public/`에 저장된 파일은 webpack 또는 Next.js에 의해 변환되거나 최적화되지 않습니다. 그대로 제공됩니다.
   - 따라서 이미지 최적화, CSS 및 JS 번들링 등의 작업은 이 디렉터리에 있는 파일에 적용되지 않습니다.
3. **파비콘 및 웹 매니페스트**: 
   - 웹사이트의 파비콘, `robots.txt`, `sitemap.xml`, 웹 앱 매니페스트 등과 같은 특별한 파일들을 `public/` 디렉터리에 위치시킬 수 있습니다. 이렇게 하면 해당 파일들을 웹사이트의 루트 경로에서 쉽게 참조할 수 있습니다.
4. **명심할 점**: 
   - `public/` 디렉터리는 프로젝트의 루트에 직접 매핑되므로 디렉터리 내에 민감한 정보나 파일을 저장하지 않아야 합니다. 그렇게 하면 그러한 파일이 공개적으로 접근 가능해질 수 있습니다.
5. **이미지 최적화**:
   - Next.js는 `public/` 디렉터리의 이미지에 대한 자동 최적화를 제공하지 않습니다. 그러나 `Image` 컴포넌트를 사용하여 이러한 이미지를 로드하면 `Image` 컴포넌트의 기능을 활용하여 성능을 개선할 수 있습니다.

결론적으로, `public/` 디렉터리는 프로젝트에서 공개적으로 접근 가능한 정적 파일들을 저장하는 곳입니다. 따라서, 이 디렉터리 내에 저장되는 파일들은 프로젝트의 루트 URL에서 바로 접근하고 사용할 수 있어야 합니다.

<ToggleContent title="SVG (Scalable Vector Graphics) 파일">
SVG (Scalable Vector Graphics)는 XML 기반의 벡터 이미지 형식입니다. SVG는 다양한 웹 및 그래픽 디자인에서 널리 사용되며, 특히 웹에서 중요한 이유와 개발자가 알아야 할 주요 항목에 대해 설명하겠습니다.

**SVG의 주요 특징**

1. **벡터 기반**: SVG는 비트맵이 아닌 벡터 기반으로 되어 있어, 확대 및 축소에도 화질이 떨어지지 않습니다.
2. **파일 크기**: 벡터 데이터는 비교적 작은 파일 크기로 복잡한 디자인을 표현할 수 있습니다. 그 결과 네트워크 대역폭을 절약할 수 있습니다.
3. **조작 가능성**: SVG는 XML 기반으로 되어 있기 때문에 JavaScript와 CSS를 사용하여 동적으로 조작하거나 스타일링할 수 있습니다.
4. **애니메이션**: SVG는 SMIL (Synchronized Multimedia Integration Language)을 사용하여 원래 애니메이션을 지원합니다. 그러나 웹에서는 주로 CSS와 JavaScript를 사용하여 SVG 애니메이션을 구현합니다.
5. **해상도 독립성**: 다양한 디스플레이 및 기기 해상도에 적응하며, 그림이 흐릿해지거나 품질이 떨어지지 않습니다.

**웹에서 SVG의 중요성**

1. **반응형 디자인**: 다양한 디바이스 크기 및 해상도에 대응하는 웹 디자인에서 SVG는 이미지의 품질 손실 없이 크기를 조절할 수 있어 중요합니다.
2. **성능 최적화**: SVG는 종종 PNG나 JPG보다 작은 파일 크기를 가질 수 있으며, 웹 성능을 개선하는 데 도움을 줍니다.
3. **접근성**: SVG의 XML 기반 특성으로 인해 스크린 리더기와 같은 보조 기술에서 내용을 읽을 수 있습니다.

**개발자가 알아야 할 항목**

1. **인라인 SVG**: SVG를 HTML 문서에 직접 포함시킬 수 있습니다. 이를 통해 JavaScript 및 CSS로 쉽게 조작하고 스타일링할 수 있습니다.
2. **SVG 최적화**: 불필요한 메타데이터나 코멘트 등을 제거하여 SVG 파일 크기를 줄이는 도구와 방법이 있습니다. 예로 `SVGO`와 같은 도구를 사용할 수 있습니다.
3. **크로스 브라우징**: 대부분의 현대 브라우저는 SVG를 지원하지만, 구형 브라우저나 특정 기능의 지원 상황을 확인해야 할 수도 있습니다.
4. **보안 고려**: SVG에는 JavaScript 코드를 포함할 수 있는데, 이를 악용한 보안 위협이 될 수 있으므로 주의가 필요합니다.

결론적으로, SVG는 웹에서 고해상도 및 반응형 디자인을 지원하기 위한 중요한 도구입니다. 개발자는 SVG의 특징과 사용 방법, 그리고 주의점을 잘 이해하고 활용해야 합니다.

</ToggleContent>

---

## `app/` 디렉터리 알아 보기

`app/` 디렉터리는 주어진 프로젝트 구조에서 중요한 요소들을 포함합니다. 

1. **favicon.ico**:
    - **설명**: 웹사이트의 아이콘 파일입니다. 브라우저 탭, 북마크, 모바일 홈 화면 아이콘 등에서 사용됩니다.
    - **중요성**: 웹사이트의 브랜드 아이덴티티를 나타냅니다. 사용자가 웹사이트를 쉽게 인식할 수 있게 해주는 요소 중 하나입니다.

2. **globals.css**:
    - **설명**: 전역 스타일을 정의하는 CSS 파일입니다. 이 파일에는 전체 웹 애플리케이션에 적용되는 스타일이 포함됩니다.
    - **중요성**: 웹사이트의 전반적인 디자인과 일관성을 유지하기 위한 중요한 파일입니다. 특히 디자인의 기본 요소나, 전체적인 레이아웃, 폰트 스타일 등을 설정할 때 사용됩니다.

3. **layout.tsx**:
    - **설명**: 공통적인 웹 페이지의 구조나 레이아웃을 정의하는 React 컴포넌트입니다. 대부분의 페이지에서 재사용되는 헤더, 푸터, 사이드바 등의 요소를 포함할 수 있습니다.
    - **중요성**: 웹사이트의 모든 페이지에 일관된 레이아웃과 구조를 제공하려면 이 파일을 수정하면 됩니다. 유저 경험(UX)의 일관성을 제공하는 데 중요한 역할을 합니다.

4. **page.tsx**:
    - **설명**: 주 페이지의 React 컴포넌트입니다. 이 파일은 웹사이트의 주요 내용을 포함하며, 다른 페이지 컴포넌트로 확장될 수도 있습니다.
    - **중요성**: 웹사이트의 주요 내용과 기능을 제공합니다. 이 파일을 기반으로 다양한 페이지를 만들거나 주요 컴포넌트를 구성할 수 있습니다.

<Callout type="warning" icon="초보 개발자가 알아야 할 항목">
- 이 디렉터리는 웹 애플리케이션의 핵심적인 부분을 담당합니다.
- 각 파일은 웹사이트의 디자인, 레이아웃 및 주요 내용을 관리하는 데 사용됩니다.
- 수정이 필요할 때는 각 파일의 역할과 중요성을 이해하고, 적절하게 변경하면 됩니다.
</Callout>

결론적으로, `app/` 디렉터리는 웹 애플리케이션의 주요 디자인과 구조를 관리하는 핵심 디렉터리입니다. 각 파일의 역할과 중요성을 파악하면 웹 애플리케이션의 전반적인 흐름과 구조를 이해하는 데 도움이 됩니다.