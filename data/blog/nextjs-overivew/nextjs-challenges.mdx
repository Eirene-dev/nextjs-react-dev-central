---
title: "Next.js 사용 시 직면할 수 있는 함정, 그리고 이를 극복하는 전략"
summary: "Next.js의 실제 사용 시 마주칠 수 있는 여러 단점들과 함께, 실제 프로젝트에서의 구체적인 예시와 그 문제점을 해결하는 방안을 함께 고민해봅니다."
tags: ['Nextjs', 'Coding-Issues', 'Challenges']
images: ['/static/images/blog/nextjs-overivew/nextjs-challenges-1.jpg']
date: "2023-10-02 09:01"
---

<TOCInline toc={props.toc} asDisclosure />

Next.js는 현대의 웹 앱 개발에서 선호되는 React 프레임워크 중 하나입니다. 그러나 모든 도구와 마찬가지로, 사용 중에는 예상치 못한 함정에 빠질 수 있습니다. 이 글에서는 Next.js를 사용하면서 마주칠 수 있는 어려운 점, 실제 프로젝트에서 발생할 수 있는 문제 예시 및 그에 대한 대책을 알아보겠습니다.

## 1. 내장된 상태 관리 기능이 없다
    - **문제**: Next.js는 내장된 상태 관리 솔루션을 제공하지 않습니다.
    - **실제 예**: 페이지 간에 공유되는 사용자의 로그인 상태나 테마 설정 등의 전역 상태를 관리하기 위해 따로 구현이 필요합니다.
    - **대책**: 필요에 따라 상태 관리 라이브러리를 선택하고, 프로젝트 초기 단계에서 이를 결정하여 통일성을 유지하는 것이 중요합니다.

<Callout type="warning" icon="대책">
"**필요에 따라 상태 관리 라이브러리를 선택하고, 프로젝트 초기 단계에서 이를 결정하여 통일성을 유지하는 것이 중요합니다.**"

1. **상태 관리 라이브러리 조사**
   - **Redux**: 중앙 집중식 상태 관리를 제공하며, 큰 프로젝트에 적합합니다. 미들웨어를 활용하여 비동기 작업을 관리할 수 있습니다.
   - **MobX**: 반응형 프로그래밍 모델을 제공하며, 간결한 코드로 상태 관리를 할 수 있습니다.
   - **Recoil**: React의 원칙을 기반으로 하는 상태 관리 라이브러리로, 간단하면서도 유연한 상태 관리가 가능합니다.
   - **Zustand, Jotai** 등: 가벼운 상태 관리 라이브러리로, 간단한 프로젝트나 특정 요구 사항에 맞춰 사용할 수 있습니다.

2. **프로젝트 요구 사항 분석**
   - 프로젝트의 규모, 비동기 작업의 복잡도, 팀원들의 기술적 경험 및 선호도 등을 분석합니다.
   - 상태 관리의 복잡도와 필요성을 파악하여, 상태 관리 라이브러리의 도입 여부를 결정합니다.

3. **라이브러리 선택 및 도입**
   - 프로젝트 요구 사항과 조사 결과를 바탕으로 가장 적합한 상태 관리 라이브러리를 선택합니다.
   - 선택된 라이브러리의 공식 문서나 관련 자료를 통해 기본적인 사용법을 익힙니다.

4. **코드베이스 통일성 유지**
   - 팀원들과 함께 코드 컨벤션, 상태 구조, 액션 디스패치 방식 등을 논의하여 통일된 코드베이스를 유지합니다.
   - 필요에 따라 프로젝트의 문서화를 진행하여, 새로운 팀원이 참여했을 때도 손쉽게 코드베이스를 이해할 수 있게 합니다.

이렇게 선택한 상태 관리 라이브러리를 효과적으로 도입하고 사용함으로써, 프로젝트의 유지보수성과 확장성을 높일 수 있습니다.
</Callout>

## 2. 학습 곡선이 높을 수 있다
    - **문제**: Next.js는 강력한 프레임워크지만, React에 익숙하지 않다면 학습이 어려울 수 있습니다.
    - **실제 예**: Next.js 13버전에서의 새로운 개념인 App 라우터와 웹 스트리밍이나 Next.js 13 이전 버전에서 API 라우트, `getStaticProps`, `getServerSideProps`와 같은 Next.js만의 독특한 기능을 처음 접할 때 혼란을 느낄 수 있습니다.
    - **대책**: 기본적인 React의 지식을 확립한 후 Next.js나 본 사이트의 공식 문서나 튜토리얼을 통해 차근차근 학습하는 것이 바람직합니다.

## 3. 모든 프로젝트에 적합하지 않다
    - **문제**: 작은 프로젝트나 단순한 요구사항의 프로젝트에는 Next.js의 기능이 과도할 수 있습니다.
    - **실제 예**: 간단한 포트폴리오 웹사이트나 랜딩 페이지를 구축하는데 Next.js의 모든 기능이 필요하지 않을 수 있습니다.
    - **대책**: 프로젝트의 규모와 목표를 명확히 파악한 후, 적절한 도구를 선택하는 것이 필요합니다. Next.js에서 제공하는 [템플릿](https://vercel.com/templates/next.js?utm_source=next-site&utm_medium=navbar&utm_campaign=nextjs-templates)을 확인 후 Next.js에서 쉽게 구축 가능한 리스트를 봅니다.

## 4. 동적 라우팅에 대한 성능 문제
    - **문제**: Next.js는 정적 라우팅에 최적화되어 있어, 동적 라우팅을 사용할 때 성능 저하를 경험할 수 있습니다.
    - **실제 예**: 사용자마다 개인화된 URL을 제공하는 웹 애플리케이션에서 동적 라우팅을 사용하면, 초기 페이지 로딩 시간이 증가할 수 있습니다.
    - **대책**: 동적 라우팅이 필요한 경우 성능 최적화 방안을 검토하거나 필요한 부분만 동적 라우팅을 사용하는 것이 좋습니다.

<Callout type="warning" icon="대책">
"**동적 라우팅이 필요한 경우 성능 최적화 방안을 검토하거나 필요한 부분만 동적 라우팅을 사용하는 것이 좋습니다.**"

이 대책에 대한 구체적인 기술적인 방법은 다음과 같습니다.

1. **선로딩(Preloading)**:
   - 사용자가 페이지에 접근하기 전에 해당 페이지와 관련된 자바스크립트 및 데이터를 미리 로드하는 기술입니다. 
   - Next.js는 `Link` 컴포넌트에 `prefetch` 옵션을 제공하여 이를 지원합니다.
     ```jsx
     import Link from 'next/link';

     <Link href="/dynamic-route" prefetch>
       <a>Dynamic Route</a>
     </Link>
     ```

2. **데이터 페칭 최적화**:
   - `getStaticPaths`와 `getStaticProps`를 사용하여 빌드 시점에 필요한 동적 경로를 생성하고, 해당 경로에 필요한 데이터도 미리 가져옵니다.
   - 이 방법은 크게 변경되지 않는 데이터에 효과적입니다.

3. **서버사이드 렌더링(SSR) 사용**:
   - `getServerSideProps`를 사용하여 서버에서 페이지를 렌더링합니다.
   - 이를 통해 클라이언트 측에서 추가적인 데이터 페칭 없이 페이지를 빠르게 로드할 수 있습니다.

4. **클라이언트 사이드 캐싱**:
   - SWR나 React Query와 같은 도구를 사용하여 클라이언트에서 데이터를 캐싱합니다.
   - 이를 통해 동일한 요청을 여러 번 하지 않아도 되며, 사용자의 경험을 개선할 수 있습니다.

5. **동적 import**:
   - 필요한 컴포넌트나 라이브러리만을 동적으로 임포트하여 번들 크기를 최적화합니다.
   ```jsx
   import dynamic from 'next/dynamic';

   const DynamicComponent = dynamic(() => import('../components/DynamicComponent'));
   ```

6. **필요한 동적 라우팅 최소화**:
   - 가능한 한 정적 생성(Static Generation)을 사용하고, 동적 라우팅은 반드시 필요한 경우에만 사용합니다.
   
7. **코드 분할(Code Splitting)**:
   - Next.js는 자동으로 코드 분할을 지원합니다. 이를 활용하여 각 페이지의 번들 크기를 줄이고, 필요한 부분만 로드하여 성능을 향상시킵니다.

이러한 기술적인 대책들을 적절히 혼합하여 사용함으로써, 동적 라우팅의 성능 이슈를 최소화할 수 있습니다.
</Callout>

## 5.디버깅의 어려움
    - **문제**: 전통적인 React 어플리케이션과 다른 스택을 사용하는 Next.js는 디버깅이 어려울 수 있습니다.
    - **실제 예**: 서버 사이드 렌더링 오류 발생 시, 원인을 찾기 위해 서버 로그와 클라이언트 로그 모두를 확인해야 할 수 있습니다.
    - **대책**: Next.js 커뮤니티에서 제공하는 디버깅 가이드를 활용하거나, 에러 트래킹 툴을 활용하여 문제를 해결합니다.

<Callout type="warning" icon="대책">
"**Next.js 커뮤니티에서 제공하는 디버깅 가이드를 활용하거나, 에러 트래킹 툴을 활용하여 문제를 해결합니다.**"

이 대책에 대한 구체적인 기술적인 방법은 다음과 같습니다:

1. **Next.js 공식 문서와 디버깅 가이드 활용**:
   - Next.js의 [공식 문서](https://nextjs.org/docs)는 상세하고 종합적입니다. 특히, 문제 해결 방법에 관한 섹션에서 일반적인 문제들에 대한 해결책을 찾을 수 있습니다.
   - 또한, 커뮤니티 포럼이나 GitHub 이슈 트래커에서 다른 사용자들의 문제와 해결 방법을 검색할 수 있습니다.

2. **개발 모드에서 디버깅**:
   - `next dev` 명령을 사용하여 개발 모드를 시작합니다. 이 모드에서는 추가적인 디버깅 정보와 에러 스택 트레이스를 확인할 수 있습니다.

3. **VSCode와 같은 IDE를 활용한 디버깅**:
   - 많은 IDE와 텍스트 에디터들은 디버깅 기능을 제공합니다. 이를 통해 코드 내에서 브레이크 포인트를 설정하고, 변수의 상태를 실시간으로 확인하며 문제의 원인을 찾을 수 있습니다.

4. **에러 트래킹 툴 사용**:
   - Sentry, LogRocket, New Relic과 같은 에러 트래킹 및 모니터링 툴을 프로젝트에 통합합니다. 이러한 툴들은 실시간으로 에러를 감지하고, 에러의 원인과 컨텍스트에 대한 정보를 제공합니다.
   
5. **커스텀 에러 페이지 생성**:
   - Next.js는 사용자 정의 에러 페이지를 제공합니다. `_error.js` 페이지를 통해 에러를 핸들링하고, 추가적인 로깅 또는 사용자에게 유용한 피드백을 제공할 수 있습니다.
       > [링크: Next.js 문서 - 에러 처리](/docs/nextjs/routing/error-handling)

6. **환경 변수 및 설정 확인**:
   - `next.config.js`와 관련된 환경 변수 설정이 올바른지 확인하십시오. 잘못된 설정은 예기치 않은 동작의 원인이 될 수 있습니다.
       > [링크: Next.js 문서 - 환경 변수](/docs/nextjs/configuring/environment-variables)

이러한 방법들을 통합적으로 활용하면 Next.js에서 발생하는 대부분의 문제를 효과적으로 진단하고 해결할 수 있습니다.
</Callout>

결론적으로, Next.js는 강력한 도구임에는 분명하지만, 그만큼의 주의와 전략이 필요합니다. 이를 이해하고, 적절한 대책을 마련한다면 효과적인 웹 앱을 구축할 수 있을 것입니다.