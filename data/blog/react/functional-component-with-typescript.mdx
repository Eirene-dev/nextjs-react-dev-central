---
title: "Next.js에서 타입스크립트와 함께하는 함수형 컴포넌트의 모든 것"
summary: "함수형 컴포넌트는 리액트 개발에서 가독성 높고 간결한 코드 구조를 제공합니다. 이 글에서는 Next.js 환경에서 자바스크립트와 ES6 화살표 함수를 사용한 함수형 컴포넌트의 구조, 타입스크립트를 활용한 속성 정의 방법, 그리고 함수형 컴포넌트의 여러 구성 요소 및 방식에 대해 알아봅니다."
tags: ['React', 'Functional', 'TypeScript']
images: ['/static/images/blog/react/functional-component-with-typescript.jpg']
date: "2024-03-19 7:00"
---

<TOCInline toc={props.toc} asDisclosure />


## 서론
### 함수형 컴포넌트의 등장 배경과 리액트에서의 중요성

리액트 개발에서 함수형 컴포넌트의 사용은 코드의 가독성과 재사용성을 향상시키는 중요한 전환점이 되었습니다. 초기 리액트에서는 주로 클래스 기반 컴포넌트가 사용되었지만, 함수형 컴포넌트와 훅(Hook)의 도입으로 개발자는 보다 간결하고 직관적인 코드 작성이 가능해졌습니다. 이러한 변화는 애플리케이션의 상태 관리와 사이드 이펙트(Side-effect) 처리를 함수형 패러다임 내에서 해결할 수 있게 하며 리액트의 선언적 UI 철학을 더욱 효율적으로 구현할 수 있도록 돕습니다.

함수형 컴포넌트는 리액트의 핵심 개념인 재사용 가능한 UI 조각을 만드는 데 있어서 더 단순하고 덜 복잡한 방식을 제공합니다. 이는 개발자가 애플리케이션의 상태와 생명주기에 더 집중할 수 있게 하여 최종적으로 사용자 경험을 향상시키는 효과적인 UI를 만들 수 있습니다.

### Next.js와 리액트의 조화

Next.js는 리액트의 함수형 컴포넌트와 훅을 기반으로 합니다. 예를 들어, Next.js의 페이지 레벨 컴포넌트는 간단한 함수형 컴포넌트로 선언되어 애플리케이션의 각 페이지를 효율적으로 구성할 수 있습니다.

```javascript
import React from 'react';

const HomePage = () => {
  return (
    <div>
      <h1>홈페이지 환영합니다!</h1>
      <p>Next.js와 리액트로 만들어진 홈페이지입니다.</p>
    </div>
  );
}

export default HomePage;
```

위 예제처럼 Next.js를 사용하면 각 페이지를 함수형 컴포넌트로 구현하여 프로젝트의 구조를 간결하게 유지할 수 있습니다. 또한, Next.js의 데이터 가져오기 기능과 같은 고급 기능을 통해 서버 사이드 렌더링이나 정적 생성을 위한 데이터를 효율적으로 처리할 수 있습니다.

함수형 컴포넌트와 Next.js의 조합은 현대적인 웹 개발에 있어 필수입니다.


## 함수형 컴포넌트의 기본 구조와 속성

### 함수형 컴포넌트의 기본 구조와 속성

리액트에서 함수형 컴포넌트는 UI를 구성하는 가장 기본적인 단위입니다. 이들은 자바스크립트 함수나 ES6 화살표 함수를 사용하여 정의될 수 있으며 컴포넌트로서 작동하기 위해 JSX를 반환합니다.

#### 자바스크립트 함수와 ES6 화살표 함수의 기본 구조 비교

함수형 컴포넌트를 정의할 때 전통적인 자바스크립트 함수 형태와 ES6 화살표 함수 형태 중에서 선택할 수 있습니다. 두 형태 모두 유효하지만 각각의 특징이 있습니다.

전통적인 함수의 예시:

```javascript
function Welcome(props) {
  return <h1>안녕하세요, {props.name}</h1>;
}
```

ES6 화살표 함수의 예시:

```javascript
const Welcome = (props) => <h1>안녕하세요, {props.name}</h1>;
```

두 형태 모두 `props`를 매개변수로 받아 JSX를 반환합니다. 화살표 함수는 보다 간결한 문법을 제공하며 `this` 바인딩에 있어서도 다르게 작동합니다. 함수형 컴포넌트에서는 일반적으로 `this` 바인딩이 중요하지 않기 때문에 많은 개발자가 보다 간결한 화살표 함수를 선호합니다.

#### 함수형 컴포넌트에서의 속성(Props) 이해

함수형 컴포넌트에서 속성은 컴포넌트에 데이터를 전달하는 방법입니다. 속성을 통해 부모 컴포넌트로부터 데이터를 받아 자식 컴포넌트에서 사용할 수 있습니다. 속성은 함수의 매개변수로 전달되며 컴포넌트 내부에서는 `props` 객체를 통해 접근할 수 있습니다.

```javascript
const Welcome = (props) => <h1>안녕하세요, {props.name}</h1>;
```

#### 속성을 활용한 컴포넌트 간 데이터 전달

리액트에서 컴포넌트 간의 데이터 전달은 속성을 통해 이루어집니다. 부모 컴포넌트에서 자식 컴포넌트로 속성을 전달하여 자식 컴포넌트가 필요한 데이터를 사용할 수 있게 합니다.

예를 들어, `User` 컴포넌트가 `Welcome` 컴포넌트를 사용하여 사용자 이름을 표시하려는 경우 다음과 같이 작성할 수 있습니다.

```javascript
const User = () => {
  return <Welcome name="제인" />;
}
```

이 예시에서 `User` 컴포넌트는 `Welcome` 컴포넌트에 `name` 속성을 전달합니다. `Welcome` 컴포넌트는 이 속성을 사용하여 환영 메시지에 사용자 이름을 포함시킵니다. 이처럼 속성을 통해 컴포넌트 간 데이터를 전달하고 리액트 애플리케이션에서 다양한 데이터 흐름을 구성할 수 있습니다.

함수형 컴포넌트와 속성을 이해하고 활용하는 것은 리액트 개발의 핵심적인 부분입니다. 이를 통해 더 유연하고 재사용 가능한 컴포넌트를 만들어 효율적이고 유지 보수가 용이한 애플리케이션을 구축할 수 있습니다.


## 타입스크립트와 함수형 컴포넌트

### 타입스크립트 기반 함수형 컴포넌트의 구조 변화

타입스크립트를 도입하면 함수형 컴포넌트의 구조에 몇 가지 중요한 변화가 생깁니다. 가장 두드러진 변화는 속성(props)과 내부 상태(state)에 타입을 지정할 수 있다는 것입니다. 이를 통해 개발 과정에서 보다 엄격한 타입 검사를 할 수 있으며 이는 오류를 줄이고 코드의 안정성을 높이는 데 도움을 줍니다.

```typescript
type WelcomeProps = {
  name: string;
};

const Welcome = ({ name }: WelcomeProps) => <h1>안녕하세요, {name}</h1>;
```

위 코드는 `Welcome` 컴포넌트에 `name` 속성을 문자열로 지정하는 간단한 예시입니다. 이처럼 타입스크립트를 사용하면 속성의 타입을 명시적으로 선언하여 컴포넌트의 예상 동작을 더 명확히 할 수 있습니다.

### 타입스크립트를 사용한 속성 정의의 이점

타입스크립트를 사용해 속성을 정의하는 것은 개발자에게 여러 이점을 제공합니다. 첫째, 컴포넌트에 전달되는 데이터의 타입을 미리 정의함으로써 잘못된 타입의 데이터가 전달되었을 때 컴파일 타임에 바로 오류를 발견할 수 있습니다. 둘째 코드를 읽는 사람에게 해당 컴포넌트가 어떤 속성을 필요로 하는지 그리고 각 속성의 타입이 무엇인지 명확하게 알려줍니다. 이는 코드의 가독성과 유지 보수성을 크게 향상시킵니다.

### 자바스크립트 함수 대비 ES6 화살표 함수의 장단점 분석

리액트와 타입스크립트 환경에서 자바스크립트 함수와 ES6 화살표 함수는 각각의 장단점을 가집니다.

**자바스크립트 함수의 장점**:
- 전통적인 함수 선언은 `this` 바인딩이 명확합니다. 클래스 컴포넌트에서 메소드를 정의할 때 유리할 수 있습니다.

**자바스크립트 함수의 단점**:
- 비교적 더 많은 코드를 작성해야 합니다. 함수 키워드와 return 문을 명시적으로 써야 하기 때문입니다.

**ES6 화살표 함수의 장점**:
- 간결한 문법으로 인해 코드를 더 간단하고 읽기 쉽게 만듭니다.
- `this` 바인딩이 주변 컨텍스트에 자동으로 바인딩되어 특히 함수형 컴포넌트에서 유용합니다.

**ES6 화살표 함수의 단점**:
- `this` 바인딩이 자동으로 이루어지기 때문에 함수가 자신의 `this`를 가지고 있지 않습니다. 때문에 특정 상황에서 `this`를 제어할 필요가 있을 때는 주의가 필요합니다.

함수형 컴포넌트에서 `this`의 바인딩이 중요한 역할을 하지 않기 때문에 ES6의 화살표 함수 사용이 선호됩니다. 이 방식은 코드를 간결하고 읽기 쉽게 만들어 주며, 타입스크립트와 함께 사용할 때도 같은 장점을 제공합니다.

```typescript
const Welcome = ({ name }: WelcomeProps) => <h1>안녕하세요, {name}</h1>;
```

<Callout type="warning" icon="">
과거에는 `React.FC<>` 또는 `FunctionComponent<>`를 사용하여 컴포넌트를 정의하는 방식이 일반적이었습니다. 하지만 최근에는 `FunctionComponent` 또는 `FC` 타입 사용에 대한 관점이 변화하고 있습니다. 과거에 널리 사용되었음에도 불구하고 현재는 다음과 같은 몇 가지 단점 때문에 권장되지 않습니다:
1. `FunctionComponent` 타입은 `children` 속성을 자동으로 포함하는데, 이는 컴포넌트가 `children`을 사용하지 않을 때에도 `children`을 받을 수 있다는 의미이므로 타입의 명확성을 해칩니다.
2. 이 타입은 제네릭을 사용한 복잡한 속성 타입 정의를 충분히 지원하지 않아 유연한 속성 타입 정의에 제약을 줍니다.
3. `FunctionComponent`를 사용하는 클래스 컴포넌트에서 `defaultProps`가 예상대로 작동하지 않을 수 있는 문제가 있습니다.

이러한 이유로, 최근 리액트 개발에서는 `FunctionComponent` 타입 대신 더 명확한 타입 정의나 다른 타입 헬퍼를 사용하는 것이 권장됩니다. 이는 컴포넌트의 속성 타입을 더 명확하게 하고 개발자의 의도를 정확하게 전달하는 데 도움을 줍니다.

예를 들어, 명확한 타입 정의를 사용하는 방법은 다음과 같습니다:

```typescript
type WelcomeProps = {
  name: string;
};

const Welcome = ({ name }: WelcomeProps) => <h1>안녕하세요, {name}</h1>;
```

또는 속성 타입을 더 명확하게 지정하기 위해 인터페이스를 사용하는 방법도 있습니다:

```typescript
interface WelcomeProps {
  name: string;
}

const Welcome = ({ name }: WelcomeProps) => <h1>안녕하세요, {name}</h1>;
```

이처럼 타입스크립트와 함수형 컴포넌트를 사용하는 방식은 리액트 애플리케이션 개발에 있어 보다 엄격한 타입 체킹과 함께 명확하고 안정적인 코드 작성을 가능하게 합니다. 이를 통해 개발자는 애플리케이션의 안정성을 높이고 유지 보수를 용이하게 할 수 있습니다.
</Callout>



### 타입스크립트 기반 속성 정의 방법

### 기본 속성 타입 정의: 문자열, 숫자, 불리언, 배열

타입스크립트를 사용하면 리액트 컴포넌트의 속성에 구체적인 타입을 지정할 수 있습니다. 이는 컴포넌트가 예상대로 사용되고 있음을 보장하며 잘못된 속성 타입의 전달로 인한 오류를 방지합니다.

```typescript
type UserProps = {
  name: string;
  age: number;
  isActive: boolean;
  hobbies: string[];
};

const User = ({ name, age, isActive, hobbies }: UserProps) => {
  return (
    <div>
      <h2>{name}</h2>
      <p>나이: {age}</p>
      <p>{isActive ? "활성 상태" : "비활성 상태"}</p>
      <ul>
        {hobbies.map(hobby => <li key={hobby}>{hobby}</li>)}
      </ul>
    </div>
  );
};
```

위 예제에서는 `User` 컴포넌트에 네 가지 속성을 정의했습니다: 문자열, 숫자, 불리언, 문자열 배열입니다. 각 속성 타입은 컴포넌트가 받아들일 수 있는 데이터 타입을 명확히 합니다.

### 유니온 타입과 옵셔널 속성을 활용한 유연한 속성 정의

유니온 타입과 옵셔널 속성은 타입스크립트에서 속성의 타입을 유연하게 정의하는 데 사용됩니다. 유니온 타입은 여러 타입 중 하나일 수 있는 속성에 사용되며 옵셔널 속성은 필수가 아닌 속성을 나타냅니다.

```typescript
type ButtonProps = {
  label: string;
  size?: "small" | "medium" | "large";
};

const Button = ({ label, size = "medium" }: ButtonProps) => {
  return <button className={`button ${size}`}>{label}</button>;
};
```

위 예제에서 `size` 속성은 "small", "medium", "large" 중 하나를 가질 수 있는 유니온 타입을 가지며, 옵셔널 속성으로 선언되어 필수가 아닙니다. 기본값으로 "medium"이 설정되어 있어 `size`가 제공되지 않을 경우 "medium"이 사용됩니다.

### 속성의 기본값 설정과 타입 안정성

타입스크립트에서 속성의 기본값을 설정하면 속성이 제공되지 않았을 때 사용할 기본 값을 지정할 수 있습니다. 이는 속성의 타입 안정성을 유지하면서도 유연한 컴포넌트 생성을 가능하게 합니다.

```typescript
type GreetingProps = {
  name?: string;
};

const Greeting = ({ name = "손님" }: GreetingProps) => {
  return <div>안녕하세요, {name}</div>;
};
```

이 예제에서 `name` 속성은 옵셔널하며 기본값으로 "손님"이 설정되어 있습니다. 이렇게 속성에 기본값을 설정하면, 해당 속성이 제공되지 않을 경우에도 컴포넌트가 안정적으로 동작할 수 있습니다.

타입스크립트를 사용한 속성 정의 방법은 리액트 개발 과정에서 타입의 안정성을 보장하고 오류를 줄이며 코드의 가독성과 유지 보수성을 향상시키는 중요한 역할을 합니다. 이러한 방법은 개발자가 더 안전하고 효율적으로 리액트 컴포넌트를 설계하고 구현할 수 있게 돕습니다.


## 함수형 컴포넌트의 반환형 처리

### JSX와 컴포넌트 반환의 중요성

함수형 컴포넌트에서는 JSX 혹은 다른 컴포넌트를 반환하는 것이 핵심적인 역할을 합니다. 이 반환값은 브라우저에서 사용자 인터페이스를 구성하는 데 사용되며 리액트의 선언적 UI 구축 방식을 가능하게 합니다. 함수형 컴포넌트의 반환값을 통해 개발자는 애플리케이션의 구조와 내용과 스타일을 정의할 수 있습니다.

예를 들어, 간단한 인사말을 표시하는 컴포넌트는 다음과 같이 구현할 수 있습니다:

```javascript
const Greeting = ({ name }) => <h1>안녕하세요, {name}님</h1>;
```

이 예시에서 `Greeting` 컴포넌트는 `name` 속성을 받아 JSX 형태로 인사말을 반환합니다. 이러한 방식은 리액트에서 컴포넌트 기반 개발을 수행하는 데 있어 핵심적인 원칙입니다.

### 타입스크립트 환경에서 반환형 명시의 이점

타입스크립트를 사용할 때 컴포넌트의 반환형을 명시적으로 선언하는 것은 여러 이점을 제공합니다. 가장 눈에 띄는 이점은 코드의 가독성과 안정성을 높일 수 있다는 점입니다. 반환형을 명시함으로써 개발자는 해당 컴포넌트가 어떤 종류의 값을 반환하는지 명확히 알 수 있으며 이는 코드의 이해를 돕고 오류를 줄입니다.

예를 들어, 반환형을 명시한 `Greeting` 컴포넌트는 다음과 같이 작성할 수 있습니다:

```typescript
const Greeting = ({ name }: { name: string }): JSX.Element => <h1>안녕하세요, {name}님</h1>;
```

이 코드에서 `Greeting` 컴포넌트는 `name` 속성을 문자열로 받고, `JSX.Element` 타입의 값을 반환한다는 것을 명확하게 알 수 있습니다. 이러한 명시적인 타입 선언은 컴포넌트의 예상 동작을 이해하고 타입 오류를 사전에 방지하는 데 도움을 줍니다.

타입스크립트에서 반환형을 명시하는 것은 특히 복잡한 컴포넌트나 라이브러리를 작성할 때 유용합니다. 이는 개발자가 의도치 않은 반환값을 제공하는 실수를 방지하고 컴포넌트의 사용자에게 명확한 가이드를 제공합니다.

결론적으로, 함수형 컴포넌트의 반환형 처리는 리액트 애플리케이션의 구성요소를 정의하는 데 중심적인 역할을 합니다. 타입스크립트를 사용하여 이러한 반환형을 명시함으로써 개발자는 보다 명확하고 안정적인 코드를 작성할 수 있으며 리액트 애플리케이션의 품질을 향상시킬 수 있습니다.


## 함수형 컴포넌트 내부 로직과 구성 요소

### 상태(State)와 효과(Effects)의 관리

함수형 컴포넌트에서 상태와 효과를 관리하는 것은 리액트 애플리케이션의 핵심적인 부분입니다. `useState`와 `useEffect` 훅을 사용하여 이를 효율적으로 관리할 수 있습니다.

`useState`는 컴포넌트의 상태를 관리하는 데 사용됩니다. 예를 들어, 사용자 입력을 관리하는 간단한 예시는 다음과 같습니다:

```javascript
import React, { useState } from 'react';

const TextInput = () => {
  const [inputValue, setInputValue] = useState('');

  return (
    <input
      type="text"
      value={inputValue}
      onChange={(e) => setInputValue(e.target.value)}
    />
  );
};
```

`useEffect`는 부수 효과를 실행하는 데 사용되며 데이터 로딩, 이벤트 리스너 등록 및 해제 등의 작업을 수행할 때 유용합니다.

```javascript
import React, { useState, useEffect } from 'react';

const UserData = ({ userId }) => {
  const [userData, setUserData] = useState(null);

  useEffect(() => {
    fetch(`https://example.com/api/user/${userId}`)
      .then(response => response.json())
      .then(data => setUserData(data));
  }, [userId]);

  if (!userData) return <div>로딩 중...</div>;
  return <div>안녕하세요, {userData.name}님</div>;
};
```

### 커스텀 훅(Custom Hooks)의 생성과 사용

커스텀 훅을 생성하여 반복되는 로직을 재사용할 수 있습니다. 예를 들어, 여러 컴포넌트에서 사용될 수 있는 데이터 로딩 로직은 다음과 같이 커스텀 훅으로 만들 수 있습니다:

```javascript
import { useState, useEffect } from 'react';

function useFetchData(url) {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch(url)
      .then(response => response.json())
      .then(data => setData(data));
  }, [url]);

  return data;
}
```

이 커스텀 훅은 다른 컴포넌트에서 재사용할 수 있어 코드의 중복을 줄이고 가독성을 높일 수 있습니다.

### 이벤트 핸들러와 조건부 렌더링의 구현

이벤트 핸들러를 통해 사용자 입력과 상호작용을 처리할 수 있으며 조건부 렌더링을 사용하여 특정 조건에 따라 다른 컴포넌트를 렌더링할 수 있습니다.

```javascript
const LoginButton = () => {
  const [isLoggedIn, setIsLoggedIn] = useState(false);

  return (
    <button onClick={() => setIsLoggedIn(!isLoggedIn)}>
      {isLoggedIn ? '로그아웃' : '로그인'}
    </button>
  );
};
```

### 리스트와 키를 활용한 동적 컨텐츠 렌더링

리스트와 키를 사용하면 동적 데이터를 기반으로 컴포넌트 목록을 렌더링할 수 있습니다. 키는 각 목록 항목의 고유성을 보장하는 데 사용됩니다.

```javascript
const UserList = ({ users }) => {
  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
};
```

함수형 컴포넌트 내부에서 상태 관리, 효과 처리, 커스텀 훅의 사용, 이벤트 처리, 그리고 조건부 렌더링과 리스트 렌더링은 리액트 애플리케이션을 효율적으로 구성하는 데 필수적인 요소입니다. 이러한 기법을 활용함으로써 개발자는 사용자에게 동적이고 반응적인 웹 경험을 제공할 수 있습니다.


## 결론

### 함수형 컴포넌트와 타입스크립트의 조합이 Next.js 프로젝트에 미치는 긍정적 영향

함수형 컴포넌트와 타입스크립트의 조합은 Next.js 프로젝트에 혁신적인 변화를 가져옵니다. 이러한 기술 스택은 코드의 가독성과 재사용성을 높이며 개발 과정에서의 오류를 크게 줄여줍니다. 타입스크립트의 엄격한 타입 체킹 기능은 런타임 오류의 가능성을 최소화하고 개발자가 보다 안정적인 애플리케이션을 구축할 수 있도록 돕습니다. 또한, 함수형 컴포넌트의 간결성과 훅을 사용한 상태 관리는 애플리케이션의 유지 보수를 간소화하며 개발 프로세스를 효율적으로 만듭니다. 이는 최종적으로 더 빠른 개발 속도와 높은 품질의 제품으로 이어집니다.

### 지속적인 학습을 통한 최신 웹 개발 기술 적용의 중요성

웹 개발 분야는 빠르게 변화하고 있으며 새로운 기술과 도구가 지속적으로 등장합니다. 따라서 최신 기술 동향에 대한 지속적인 학습과 적용은 개발자에게 매우 중요합니다. 새로운 기술을 배우고 적용함으로써 개발자는 현대적인 웹 개발 요구 사항을 충족시키고 사용자에게 더 나은 경험을 제공할 수 있습니다. 또한, 지속적인 학습은 개발자의 경력 성장에도 긍정적인 영향을 미칩니다.

### 더 나은 코드 품질과 효율적인 개발 프로세스 달성을 위한 전략

최적의 코드 품질과 개발 프로세스의 효율성을 달성하기 위해서는 몇 가지 전략을 따를 수 있습니다. 첫째, 코드 리뷰와 페어 프로그래밍과 같은 협업 기법을 활용하여 코드의 품질을 개선하고 지식을 공유할 수 있습니다. 둘째, 자동화된 테스트와 지속적 통합(CI) 및 배포(CD) 파이프라인을 구축하여 오류를 조기에 발견하고 배포 과정을 자동화함으로써 개발 효율성을 높일 수 있습니다. 셋째, 프로젝트 초기 단계부터 타입스크립트와 같은 타입 시스템을 적극적으로 활용하여 코드의 안정성을 높이는 것이 좋습니다.

함수형 컴포넌트와 타입스크립트를 활용한 Next.js 프로젝트 개발은 훌륭한 코드 품질과 개발 프로세스의 효율성을 보장합니다. 이를 통해 개발자는 사용자의 요구 사항을 충족시키는 동시에, 유지 보수가 용이하고 확장 가능한 애플리케이션을 구축할 수 있습니다. 따라서 지속적인 학습과 최신 기술의 적용, 그리고 협업과 자동화의 중요성을 인식하는 것이 더 나은 웹 개발을 위한 핵심입니다.