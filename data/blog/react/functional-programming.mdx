---
title: "React에서의 함수형 프로그래밍: 원칙, 도구, 그리고 장점"
summary: "React에서의 함수형 프로그래밍을 탐험해보세요: 코드의 예측 가능성, 유지 관리 용이성 및 효율성을 극대화하는 방법을 알아보는 여정입니다. 이 블로그에서는 함수형 컴포넌트, 훅, 불변성, 그리고 React와 함께 사용할 수 있는 다양한 함수형 프로그래밍 라이브러리들을 소개합니다."
tags: ['Functional', 'React']
images: ['/static/images/blog/react/functional-programming-1.jpg']
date: "2023-10-18 20:00"
---

<TOCInline toc={props.toc} asDisclosure />
함수형 프로그래밍(FP)은 계산을 수학 함수의 평가로 취급하고 상태 변경 및 변경 가능한 데이터를 피하는 프로그래밍 패러다임입니다. React와 결합할 때, FP는 예측 가능하고, 모듈식이며, 유지 보수가 가능한 코드로 이어집니다. 여기 React 컨텍스트에서의 함수형 프로그래밍 개요가 있습니다:

## 함수형 프로그래밍이란 무엇인가?
함수형 프로그래밍은 프로그래밍 패러다임의 한 종류로, 계산을 수학적 함수의 평가로 취급하고 상태 변경과 가변 데이터를 피하는 것을 중점으로 둡니다. 이 패러다임은 순수 함수를 사용하여 부작용(side effects)을 최소화하며, 데이터 처리를 위해 함수의 조합과 함수 간의 관계를 강조합니다. 결과적으로, 함수형 프로그래밍은 예측 가능하고, 재사용 가능하며, 테스트하기 쉬운 코드를 작성하도록 돕습니다.

<ToggleContent title="계산을 수학적 함수의 평가로 취급한다">
"계산을 수학적 함수의 평가로 취급한다"는 표현은 함수형 프로그래밍의 핵심 원리 중 하나로, 이것이 의미하는 바는 프로그램의 작동 방식이 수학적 함수처럼 이해될 수 있고, 이러한 함수의 사용 방식이 프로그램의 구조와 동작을 정의하는데 중점을 두고 있다는 것입니다.

수학에서, 함수는 하나 이상의 입력을 받아 결과를 생성합니다. 이 과정은 외부 상태에 영향을 받지 않으며, 동일한 입력에 대해서는 항상 동일한 출력을 제공합니다. 이러한 특징은 "순수성"으로 알려져 있으며, 순수 함수는 부작용이 없는 함수를 말합니다.

함수형 프로그래밍에서 "계산을 수학적 함수의 평가로 취급한다"는 것은 다음과 같은 이점을 가지고 있습니다:

1. **예측 가능성**: 함수가 외부 상태에 의존하지 않고 동일한 입력에 대해 항상 동일한 출력을 제공하기 때문에, 프로그램의 동작이 예측 가능합니다.

2. **모듈성**: 각 함수는 독립적인 단위로 작동하므로, 코드의 각 부분을 별도로 이해하고 테스트하며 재사용할 수 있습니다.

3. **버그 감소**: 부작용이 없으므로, 시스템에서 버그가 발생할 가능성이 줄어들며, 디버깅이 더 간편해집니다.

4. **병행성 처리**: 순수 함수는 스레드에 안전하므로 병행 및 병렬 프로그래밍이 용이해집니다.

요약하자면, 함수형 프로그래밍은 수학적 함수의 특성을 활용하여 코드의 안정성, 클린함, 그리고 관리 용이성을 증진시키는 프로그래밍 패러다임입니다.
</ToggleContent>

### 핵심 개념

- **불변 데이터(Immutable Data)**: 데이터가 한 번 생성되면 변경할 수 없습니다.
- **일급 및 고차 함수(First-Class and Higher-Order Functions)**: 함수는 인수로 전달되거나, 값으로 반환되거나, 변수에 저장될 수 있습니다.
- **순수 함수(Pure Functions)**: 함수의 출력은 입력 값에만 의해 결정되며 부작용이 없습니다.

Next.js를 사용하는 개발자분들께서는 React의 함수형 프로그래밍 방식이 어떻게 코드의 예측 가능성, 모듈성 및 유지 보수성을 향상시키는지에 대한 통찰을 얻을 수 있을 것입니다. 이러한 원칙들은 애플리케이션의 성능 향상과 코드베이스의 관리를 더욱 쉽게 만들어 줍니다.

### 함수형 프로그래밍의 역사

"함수형 프로그래밍의 역사"는 컴퓨터 과학과 프로그래밍 언어의 발전과 밀접하게 연결되어 있으며, 수학적 이론과 실제 컴퓨팅의 필요 사이의 간극을 메우는 데 중요한 역할을 해왔습니다.

1. **람다 대수**: 함수형 프로그래밍의 근간은 1930년대 알론조 처치에 의해 개발된 람다 대수에 있습니다. 람다 대수는 모든 계산을 수학적 함수의 평가로 분석하는 방법을 제공하며, 이는 후에 함수형 프로그래밍 언어의 핵심 개념이 되었습니다.

2. **LISP**: 1958년, 존 매카시는 LISP를 개발했는데, 이것은 함수형 프로그래밍 언어의 선구자 중 하나로 널리 알려져 있습니다. LISP는 계산을 함수와 그 평가로 간주하는 람다 대수의 개념을 구체화한 최초의 프로그래밍 언어 중 하나였습니다.

3. **ML과 Haskell**: 1970년대와 80년대에, 더 진보한 함수형 언어들이 등장했습니다. ML은 정적 타입 시스템을 도입했고, Haskell은 1990년에 발표되어 순수 함수형 프로그래밍 언어로 널리 인정받았습니다.

4. **Erlang**: 1980년대 말, Ericsson에서 Erlang이 개발되었으며, 이것은 분산, 내결함성, 실시간 시스템에 적합한 함수형 언어로 자리 잡았습니다.

5. **현대의 발전**: 21세기에 들어서며, 함수형 프로그래밍은 스칼라, 클로저, F# 등의 새로운 언어들과 함께 주류로 자리 잡기 시작했습니다. 또한, 기존의 객체 지향 언어들도, 예를 들어, 자바와 C#에서 람다 함수의 도입과 같은 함수형 기능을 통합하기 시작했습니다.

함수형 프로그래밍은 그 이론적 기초와 람다 대수의 원리 덕분에 병렬 처리와 동시성, 그리고 소프트웨어 설계의 다양한 측면에서 이점을 제공하는 견고한 프로그래밍 패러다임으로 자리 잡았습니다. 이러한 이유로, 현대의 복잡한 컴퓨팅 환경, 특히 클라우드 컴퓨팅, 분산 시스템, 대용량 데이터 처리 등의 분야에서 함수형 프로그래밍의 중요성이 더욱 부각되고 있습니다.

<ToggleContent title="각 프로그래밍 언어의 예제 코드">
각 프로그래밍 언어와 패러다임에 대한 기본적인 예제 코드를 제공하겠습니다. 이 코드들은 각 언어의 특성을 보여주는 간단한 예제일 뿐, 해당 언어의 전체 기능성을 대변하지는 않습니다.

1. **LISP**:
   LISP는 리스트 처리와 재귀에 강점을 가지고 있습니다. 아래는 간단한 팩토리얼 함수의 예입니다.
   ```lisp
   (defun factorial (n)
     (if (<= n 1)
         1
         (* n (factorial (- n 1)))))
   ```

2. **ML**:
   ML은 정적 타입 언어로, 타입 추론이 가능합니다. 아래는 팩토리얼 함수의 예입니다.
   ```ml
   fun factorial n =
     if n = 0 then 1 else n * factorial (n - 1);
   ```

3. **Haskell**:
   Haskell은 순수 함수형 언어로, 게으른 평가를 사용합니다. 아래는 팩토리얼 함수의 예입니다.
   ```haskell
   factorial :: Integer -> Integer
   factorial 0 = 1
   factorial n = n * factorial (n - 1)
   ```

4. **Erlang**:
   Erlang은 병행성과 분산 컴퓨팅에 적합합니다. 아래는 메시지 패싱을 사용한 간단한 예제입니다.
   ```erlang
   -module(hello).
   -export([start/0, print_hello/0]).

   start() -> 
       Pid = spawn(hello, print_hello, []),
       Pid ! hello.

   print_hello() -> 
       receive
           hello -> io:format("Hello, Erlang!~n")
       end.
   ```

5. **Scala**:
   Scala는 객체 지향과 함수형 프로그래밍을 결합합니다. 아래는 팩토리얼 함수의 예입니다.
   ```scala
   def factorial(n: Int): Int = {
     if (n <= 1) 1
     else n * factorial(n - 1)
   }
   ```

6. **Clojure**:
   Clojure는 LISP의 방언이며, JVM 위에서 실행됩니다. 아래는 팩토리얼 함수의 예입니다.
   ```clojure
   (defn factorial [n]
     (if (<= n 1)
       1
       (* n (factorial (dec n)))))
   ```

7. **F#**:
   F#은 .NET 프레임워크에서 실행되는 함수형 언어입니다. 아래는 팩토리얼 함수의 예입니다.
   ```fsharp
   let rec factorial n =
       if n = 0 then 1 else n * factorial (n - 1)
   ```

각 예제는 해당 언어의 기본적인 문법과 함수형 프로그래밍의 특성을 보여주는 것에 초점을 맞추고 있습니다. 실제 프로젝트에서는 이러한 언어의 더 많은 기능과 라이브러리를 사용하여 더 복잡한 작업을 수행하게 됩니다.
</ToggleContent>


## 객체지향(OOP)에서 함수형 프로그래밍으로: 왜?

### 객체지향의 문제점과 함수형 프로그래밍의 장점
함수형 프로그래밍과 객체 지향 프로그래밍은 각기 다른 문제 해결 방식과 프로그래밍 접근 방식을 제공합니다. 객체 지향 프로그래밍(OOP)이 널리 사용되기 시작한 것은 1970년대부터이며, 데이터와 데이터를 조작하는 방법을 하나의 '객체'에 캡슐화하는 것에 중점을 두었습니다. 이 접근 방식은 소프트웨어 엔지니어링, 특히 대규모 시스템에서 코드의 재사용성, 확장성 및 관리 용이성을 향상시키는 데 큰 도움이 되었습니다.

그러나 객체 지향 프로그래밍이 일부 문제를 해결하는데 탁월했음에도 불구하고, 다음과 같은 여러 문제를 완전히 해결하지 못했습니다:

1. **부작용**: OOP에서 메서드는 그들의 상태를 변경시킬 수 있는데, 이는 예측 불가능한 부작용을 초래할 수 있습니다.
2. **동시성 제어**: 멀티 스레드 환경에서 여러 객체의 상태를 관리하고 동기화하는 것은 매우 복잡합니다.
3. **불변성**: 객체의 상태가 시간이 지남에 따라 변경될 수 있으므로, 코드의 복잡성이 증가하고 오류가 발생할 가능성이 높아집니다.

이러한 문제를 해결하고자, 함수형 프로그래밍이 주목받기 시작했습니다. 함수형 프로그래밍은 다음과 같은 이점을 제공합니다:

1. **불변성**: 데이터는 생성 후 변경되지 않으므로, 여러 스레드에서 안전하게 접근할 수 있습니다.
2. **함수의 일급 시민**: 함수는 다른 함수에 인수로 전달되거나 결과로 반환될 수 있으므로, 더 유연하고 재사용 가능한 코드를 작성할 수 있습니다.
3. **부작용의 최소화**: 순수 함수는 동일한 입력에 대해 항상 동일한 출력을 생성하므로, 시스템의 전반적인 예측 가능성이 향상됩니다.

또한, 오늘날의 애플리케이션은 높은 수준의 병행성과 비동기 처리를 요구하는데, 함수형 프로그래밍은 이러한 복잡성을 추상화하고 코드의 안정성을 향상시키는 데 도움을 줍니다.

요약하자면, 객체 지향 프로그래밍과 함수형 프로그래밍은 서로 다른 접근 방식과 장단점을 가지고 있습니다. 많은 현대적인 언어는 이 두 패러다임을 결합하여, 개발자가 상황에 가장 적합한 도구를 선택할 수 있도록 합니다.



<ToggleContent title="FP vs. OOP 차이점">
아래는 함수형 프로그래밍(FP)과 객체 지향 프로그래밍(OOP)의 주요 차이점을 비교하는 표입니다.

| 구분 | 함수형 프로그래밍 (FP) | 객체 지향 프로그래밍 (OOP) |
|------|-----------------------|--------------------------|
| **기본 단위** | 함수와 데이터는 분리되어 있으며, 계산은 순수 함수를 통해 이루어집니다. | 프로그램은 객체들의 집합으로 구성되며, 이 객체들은 데이터와 메소드를 포함합니다. |
| **상태 관리** | 불변성을 지향하며 상태 변경을 피합니다. 데이터는 한 번 생성되면 변경되지 않습니다. | 객체의 상태는 시간이 지남에 따라 변경될 수 있으며, 이는 메소드를 통해 관리됩니다. |
| **병행성** | 불변 데이터로 인해 병행성이 자연스럽게 관리됩니다. 복수의 프로세스/스레드가 데이터에 접근해도 안전합니다. | 병행성 제어는 더 복잡하며, 스레드 안전성을 보장하기 위해 동기화 메커니즘을 사용해야 합니다. |
| **함수의 역할** | 함수는 일급 시민으로, 다른 함수의 인자로 전달하거나 반환값으로 사용할 수 있습니다. | 메소드는 객체에 속하며, 대부분의 경우 해당 객체의 상태를 변경하는 데 사용됩니다. |
| **코드 구조** | 선언적 프로그래밍: "무엇을 할 것인가"에 중점을 둡니다. | 명령형 프로그래밍: "어떻게 할 것인가"에 중점을 둡니다. |
| **사이드 이펙트** | 사이드 이펙트를 최소화하는 것이 목표입니다. 순수 함수는 외부 상태에 영향을 미치지 않으며, 동일 입력에 대해 동일 출력을 항상 보장합니다. | 사이드 이펙트는 객체의 상태 변경을 통해 발생할 수 있으며, 이는 때로 예측하기 어려운 결과를 초래할 수 있습니다. |
| **테스트와 디버깅** | 순수 함수의 특성으로 인해 테스트와 디버깅이 비교적 간단할 수 있습니다. | 상태 변화와 시간 의존성으로 인해 테스트와 디버깅이 더 복잡하고 어려울 수 있습니다. |
| **사용 사례** | 복잡한 함수 처리, 병렬 처리 및 동시성, 대규모 데이터 처리 등에 적합합니다. | 시스템의 상호 작용하는 컴포넌트를 모델링하는데 적합하며, 사용자 인터페이스, 게임, 대규모 소프트웨어 설계 등에 널리 사용됩니다. |

두 패러다임 모두 각기 장단점을 가지고 있으며, 프로젝트의 요구 사항, 팀의 전문성, 프로젝트의 복잡성 등에 따라 선택이 달라질 수 있습니다. 많은 현대 프로그래밍 언어는 두 패러다임을 혼합하여 사용할 수 있는 유연성을 제공합니다.
</ToggleContent>



### React에서 함수형 프로그래밍이 각광받게 된 이유
웹 개발, 특히 React에서 함수형 프로그래밍이 각광받게 된 이유는 여러 가지가 있습니다. React의 주요 개념과 함수형 프로그래밍의 원칙 사이에는 많은 연관성이 있기 때문에, 이 두 방식이 자연스럽게 어우러지는 경향이 있습니다.

1. **컴포넌트 기반 접근**: React는 UI를 독립적이고 재사용 가능한 컴포넌트로 구성하는 방식을 채택합니다. 함수형 프로그래밍 또한 작고 독립적인 단위로 분해하여 문제를 해결하는 것을 선호합니다. 이러한 공통점으로 인해, 함수형 프로그래밍은 컴포넌트 기반 아키텍처를 구축하는데 매우 적합합니다.

2. **불변성**: 함수형 프로그래밍에서는 데이터의 불변성이 중요한 원칙 중 하나입니다. React에서도 불변성은 중요한 개념으로, 상태를 직접 변경하는 것이 아니라 새 상태 객체를 생성하여 성능을 최적화하고 예측 가능한 상태 관리를 할 수 있게 합니다.

3. **순수 함수**: 함수형 프로그래밍의 순수 함수는 동일한 입력에 대해 항상 동일한 출력을 반환하며 부작용이 없습니다. React의 함수형 컴포넌트도 비슷한 개념을 따르며, 주어진 props에 대해 예측 가능한 방식으로 UI를 렌더링합니다.

4. **선언적 프로그래밍**: 함수형 프로그래밍은 '어떻게'가 아닌 '무엇을' 하는지에 중점을 둡니다. React도 선언적 접근 방식을 취하며, 개발자가 UI가 어떤 식으로 구성되어야 하는지 선언하고, React가 '어떻게' 그것을 달성할지 결정하도록 합니다.

5. **효율적인 상태 관리**: React의 Hooks 기능은 함수형 컴포넌트에서 상태와 생명주기 기능을 사용할 수 있게 해줍니다. 이는 함수형 프로그래밍의 개념과 잘 어울리며, 상태 관리를 더욱 간결하고 이해하기 쉽게 만들어 줍니다.

6. **테스트와 유지 보수의 용이성**: 순수 함수와 불변 데이터 구조를 사용하면 테스트가 더 쉬워지고, 코드가 더 예측 가능하며, 디버깅이 더 쉬워집니다. 이는 크고 복잡한 웹 애플리케이션의 유지 보수를 훨씬 간편하게 만들어 줍니다.

이러한 이유로, 함수형 프로그래밍 패러다임은 React와 같은 웹 개발 환경에서 빠르게 인기를 얻고 있으며, 효율적이고 유지 보수가 용이한 애플리케이션을 만드는 데 도움이 됩니다.


## React에서의 함수형 컴포넌트

훅(Hooks) 도입 전, React의 함수형 컴포넌트는 상태가 없었습니다. 그들은 오직 props만을 받아들이고 JSX만을 반환했습니다. 하지만 훅의 도입으로 함수형 컴포넌트는 여전히 함수형 원리를 고수하면서 상태와 사이드 이펙트를 가질 수 있는 능력을 얻었습니다.

**예시**:
```javascript
import React from 'react';

const Greeting = props => <h1>안녕하세요, {props.name}님!</h1>;

export default Greeting;
```

### useState 훅

생성자와 `this.setState`를 가진 클래스 컴포넌트를 사용하는 대신에, 함수형 컴포넌트에서 `useState` 훅을 사용할 수 있습니다.

**예시**:
```javascript
import React, { useState } from 'react';

const Counter = () => {
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>카운트: {count}</p>
      <button onClick={() => setCount(count + 1)}>증가</button>
    </div>
  );
}
```

### useEffect 훅

`componentDidMount`, `componentDidUpdate`, `componentWillUnmount` 같은 생명주기 메서드를 대체합니다.

**예시**:
```javascript
import React, { useState, useEffect } from 'react';

const Timer = () => {
  const [seconds, setSeconds] = useState(0);

  useEffect(() => {
    const interval = setInterval(() => {
      setSeconds(prev => prev + 1);
    }, 1000);

    return () => clearInterval(interval);  // 정리 함수
  }, []);  // 의존성 배열이 비어 있으면 초기 렌더링 후 한 번 실행됩니다

  return <div>경과 시간: {seconds}초</div>;
}
```


### React와 불변성

React의 재렌더링 과정은 불변 데이터 구조의 사용으로 이점을 얻습니다. Immutable.js와 같은 라이브러리나 스프레드 연산자 (`...`)와 같은 유틸리티를 활용함으로써 데이터가 불변하게 유지되는 것을 보장할 수 있습니다.

### 고차 컴포넌트(HOCs)

이것들은 컴포넌트를 취하고 추가 props 또는 변경된 행동을 가진 새로운 컴포넌트를 반환하는 함수들입니다.

**예시**:
```javascript
function withLogger(WrappedComponent) {
  return function LoggerComponent(props) {
    console.log('Props:', props);
    return <WrappedComponent {...props} />;
  }
}
```

### 함수형 라이브러리들

React에서 함수형 프로그래밍 경험을 향상시켜주는 몇 가지 라이브러리가 있습니다:

- **Lodash/fp**: 함수가 자동으로 커리되고 데이터가 불변인 Lodash의 버전.
- **Ramda**: 불변성과 함수 커링에 중점을 둔 함수형 프로그래밍을 위한 유틸리티 라이브러리.
- **Recompose**: 함수 컴포넌트와 고차 컴포넌트를 위한 React 유틸리티 벨트.

### React에서의 함수형 프로그래밍의 장점들

- **예측 가능성**: 출력이 입력에만 의해 결정되기 때문에, 함수가 무엇을 반환할지 예측하기가 더 쉽습니다.
- **테스트 가능성**: 순수 함수는 외부 상태에 독립적이기 때문에 테스트하기가 더 쉽습니다.
- **동시성**: 불변 데이터 구조로 인해 동시 변경으로부터 데이터 손상의 위험이 줄어듭니다.

## 결론

함수형 프로그래밍 원칙을 React 개발에 통합함으로써 더 읽기 쉽고, 유지 보수 가능하며, 테스트 가능한 코드로 이어집니다. React가 계속 발전함에 따라, 함수형 프로그래밍 개념과의 조화는 웹 애플리케이션을 구축하는 데 있어 확장 가능하고 효율적인 방법을 보장합니다.